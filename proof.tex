\documentclass{article}
\usepackage[utf8]{inputenc}
% \usepackage[margin=2.5cm]{geometry}
% \pagestyle{plain}
\include{preamble.tex}
\usepackage{amsmath, amssymb, amsthm}

\begin{document}

\section*{Confirmation Rule: Safety}

See:
% \begin{itemize}
%     \item \href{https://github.com/mkalinin/confirmation-rule}{https://github.com/mkalinin/confirmation-rule}
%     \item \href{https://arxiv.org/abs/2405.00549}{https://arxiv.org/abs/2405.00549}
% \end{itemize}

\begin{definition}[LMD-GHOST Safety condition for a single block]
    Given $C \in AU(b):$
    \[
    \isOneConfirmed_v(b, C, t) := Q^{\slot(t)-1,\ v,\ t,\ C}_{b} > \frac{1}{2}\left(1 + \frac{W^C_p}{W^{\slot(t)-1,\ C}_b}\right)
    \]
\end{definition}

Let $\viewattime[val=v,time=\slotstart(s)]$ be the view of a validator $v$ at the start of slot $s$ to which all the votes cast and observed by $v$ before $\slotstart(s)$ are applied.

\begin{algorithm}[H]
\caption{Highest LMD-GHOST confirmed descendant}
\SetAlgoNoLine
\Fn{\isOneConfirmed$_v(b, s)$}{
    \Return{$\isOneConfirmed_v(b, GJ(\viewattime[val=v, time=\slotstart(s-1)]), \slotstart(s))$}\;
}

\Fn{\highestLMDConfirmedDesc$_v(\bconfirmed, s)$}{
    $descs \gets \left\{b' \in \chain(\LMDGHOSTHFC(\viewattime[time=\slotstart(s),val=v])): b' \succ \bconfirmed\right\}$\\
    $confirmed\_descs \gets \left\{b' \in descs : \forall b'' \in descs, b'' \preceq b' \Rightarrow \isOneConfirmed_v(b'', s)\right\}$\\
    \uIf{$confirmed\_descs \ne \emptyset$}{
        \Return{$\argmax_{b' \in confirmed\_descs}\slot(b')$}\;
    }
    \uElse{
        \Return{$\bconfirmed$}\;
    }    
}
\end{algorithm}


\begin{lemma}
If $t$ and $t'$ are any two times, $b := \highestLMDConfirmedDesc_v(\banchor, t)$, $t \leq t'$ and the following holds:
\begin{enumerate}
    \item $\slotstart(\slot(t) - 1) \geq \GST,$
    \item $\banchor$ is canonical in the view of any honest validator $v'$ at time $t,$
    \item $\gjattime[time=t',val=v] \succeq \gjattime[time=\slotstart(\slot(t) - 1),val=v],$
    \item $b \in \filtered[time=t',val=v']$
\end{enumerate}

then $b$ is canonical in the view of any honest validator $v'$ at time $t'$.
\end{lemma}

\begin{proof}
    TBD..
\end{proof}

Let $\viewattime[val=v,time=\slotstart(s)]$ be the view of a validator $v$ at the start of slot $s$ to which all the votes cast and observed by $v$ before $\slotstart(s)$ are applied.

\begin{algorithm}[H]
\caption{Highest confirmed descendant}
% \SetAlgoLined
\SetAlgoNoLine
\Fn{willNotBeFilteredOut$_v(b, s)$}{
    $\head \gets \LMDGHOSTHFC(\viewattime[val=v,time=\slotstart(s)])$\;
    $\phead \gets \LMDGHOSTHFC(\viewattime[val=v,time=\slotstart(s-1)])$\;

    \uIf{epoch(s) = epoch(b)}{
        \Return{$b \preceq \head \wedge \epoch(\gu(head)) \geq \epoch(s)-1$}\;
    }
    \uElseIf{$s = \firstslot(\epoch(s))$}{
        \Return{$\votsource[blck=b, time=\epoch(s)] \geq \epoch(s)-2 \lor
                (b \preceq \phead \wedge \votsource[blck=\phead, time=\epoch(s)] \geq \epoch(s)-2)$}\;
    }
    \uElse {
        \uIf{$b \preceq \head \wedge \epoch(\gu(\head)) \geq \epoch(s) - 1$} {
            \Return{$\votsource[blck=b, time=\epoch(s)] \geq \epoch(s)-2 \lor
                (b \preceq \phead \wedge \votsource[blck=\phead, time=\epoch(s)] \geq \epoch(s)-2)$}\;
        }
        \uElse{
            \Return{$b \preceq \phead \wedge 
                    \epoch(\gu(\phead)) \geq \epoch(s) - 1 \wedge
                    \votsource[blck=\phead, time=\epoch(s)] \geq \epoch(s)-2$}\;
        }
    }
}
\Fn{highestConfirmedDesc$_v(\bconfirmed, s)$}{
    $\blmdconfirmed \gets \highestLMDConfirmedDesc_v(\bconfirmed, s)$\;

    \uIf{$\epoch(\blmdconfirmed) > \epoch(\bconfirmed)$ \textbf{and}
        $\neg \willChkpBeJustified_v(\chkp(\head), s)$} {
        $\mathit{candidates} \gets \{b' \in \chain(\blmdconfirmed), b' \succ \bconfirmed :
            \willNotBeFilteredOut_v(b', s) \wedge \epoch(b') = \epoch(s)-1\}$
    }
    \uElse {
        $\mathit{candidates} \gets \{b' \in \chain(\blmdconfirmed), b' \succ \bconfirmed :
            \willNotBeFilteredOut_v(b', s)\}$
    }

    \uIf{$\mathit{candidates} = \emptyset$}{
        \Return{$\bconfirmed$}\;
    }

    $\bcand \gets \argmax_{b' \in candidates}\slot(b')$\;
    \uIf{$\epoch(s) > \epoch(\bcand)$ \textbf{and}
        $s > \firstslot(epoch(s))$ \textbf{and}
        $\neg \willNoConflictingChkpBeJustified_v(\chkp(\head, \epoch(s), s))$} {
        \Return{$\bconfirmed$}\;
    }
    \uElse {
        \Return{$\bcand$}\;
    }
}
\end{algorithm}

\begin{lemma}
If $t$ and $t'$ are any two times such that $t' \geq t \wedge \epoch(t') = \epoch(t)$, $b := \text{highestConfirmedDesc}_v(\banchor, t)$, $\epoch(b) = \epoch(t) - 1$ and the following holds:

\begin{enumerate}
    \item $\slotstart(\epoch(t) - 1) \geq \GST,$
    \item $\banchor, \epoch(\banchor) = \epoch(t) - 1$ is canonical in the view of any validator $v'$ at time $\slotstart(\slot(t) - 1),$
    \item At the time $t'' \leq \slotstart(\lastslot(\epoch(t) - 1))$ in the view of validator $v$ exists block $b' \preceq b : \epoch(b') = \epoch(t) - 1$ such that $\willChkpBeJustified^{t''}_v(\chkp(b')) = \True,$
    \item At the time $\slotstart(\slot(t) - 1)$ $\exists b'' \succeq \banchor : \epoch(b'') = \epoch(t) - 1 \wedge \epoch(\gu(b'')) \geq \epoch(t) - 2,$
    \item $\gjattime[time=\slotstart(\lastslot(\epoch(t) - 1)),val=v] = \chkp(b, *)$
\end{enumerate}

then $b$ is canonical in the view of any honest validator $v'$ at time $t' < \slotstart(\epoch(b) + 2)$.
\end{lemma}

\begin{proof}
    TBD...
\end{proof}



\begin{lemma}
   If $t$ and $t'$ are any two times such that $t' \geq t$, $b := \text{highestConfirmedDesc}_v(\banchor, t)$, $\epoch(b) = \epoch(t)$ and the following holds:
    
    \begin{enumerate}
        \item $\slotstart(\epoch(t') - 1) \geq \GST,$
        \item $\banchor$ is canonical in the view of any validator $v'$ at time $t,$
        \item At the time $t'' \leq \slotstart(\lastslot(\epoch(t)))$ in the view of validator $v$ exists block $b' \preceq b : \epoch(b') = \epoch(t)$ such that:
        \begin{enumerate}
            \item $willChkpBeJustified^{t''}_v(\chkp(b')),$
            \item $\exists b'' \succeq b' : \epoch(b'') = \epoch(t) \wedge \epoch(\gu(b'')) \geq \epoch(t) - 1,$
        \end{enumerate}
        \item $\guattime[time=\slotstart(\lastslot(\epoch(t) - 1)),val=v] \succeq \chkp(b, \epoch(t) - 2),$
        \item $\gjattime[time=\slotstart(\lastslot(\epoch(t) - 1)),val=v] = \chkp(b, *),$
    \end{enumerate}
    
    then $b$ is canonical in the view of any honest validator $v'$ at time $t' < \slotstart(\epoch(b) + 2)$.
\end{lemma}

\begin{proof}
    TBD...
\end{proof}

% \section*{Algorithm 102}
% \textbf{(Highest confirmed)}

Let $\viewattime[val=v,time=\slotstart(s)]$ be the view of a validator $v$ at the start of slot $s$ to which all the votes cast and observed by $v$ before $\slotstart(s)$ are applied.

\begin{algorithm}[H]
\SetAlgoNoLine
\Fn{$\text{highestConfirmed}_v(s)$}{
    $\varforvalattime[val=v]{\bconfirmed} \gets \text{highestConfirmed}_v(s-1)$\\
    \uIf{
        $\epoch(\varforvalattime[val=v]{\bconfirmed}) \geq \epoch(s) - 1$ \textbf{and}\\
        $\varforvalattime[val=v]{\bconfirmed} \preceq \LMDGHOSTHFC(\viewattime[val=v,time=\slotstart(s)])$}{
        \Return{$\text{highestConfirmedDesc}_v(\varforvalattime[val=v]{\bconfirmed}, s)$}\;
    }
    \uElseIf{
        $s = \firstslot(\epoch(s))$ \textbf{and} \\
        $\epoch(\gu(\viewattime[val=v,time=\slotstart(s-1)])) = \epoch(s) - 1$
    }{
        \Return{$\text{highestConfirmedDesc}_v(\text{block}(\gu(\viewattime[val=v,time=\slotstart(s-1)]), s)$}\;
    }
    \uElse{
        \Return{$b_{\text{fin}}$}\;
    }
}
\caption{Highest Confirmed Block Selection}
\label{alg:highestconfirmed}
\end{algorithm}

\begin{lemma}
    If $t$ and $t'$ are any two times such that $t' \geq t$, $b := \text{highestConfirmed}(\viewatstslottime[val=v,time=t])$ and the following holds:
    
    \begin{enumerate}
        \item $\slotstart(\epoch(t) - 1) \geq \GST,$
    \end{enumerate}
    
    then $b$ is canonical in the view of any honest validator $v'$ at time $t'$.
\end{lemma}

\begin{proof}
    TBD...
\end{proof}


\begin{lemma}
    If $t$ and $t'$ are any two times such that $t' \geq t$ and the following holds:
    
    \begin{enumerate}
        \item $\slotstart(\epoch(t')) \geq \GST,$
        \item $\epoch(\guattime[time=t,val=v]) = \epoch(t),$
        \item $\epoch(\gjattime[time=\slotstart(\slot(t)-1),val=v]) = \epoch(t) - 1,$
        \item $\guattime[time=t,val=v] \succeq \gjattime[time=\slotstart(\slot(t)-1),val=v],$
    \end{enumerate}
    
then $\guattime[time=t,val=v]$ is canonical in the view of any honest validator $v'$ at any time $t'$.
\end{lemma}

\begin{proof}
    TBD...

    \begin{description}
        \item[Case 1: $\epoch(t') = \epoch(t)$.]
        \item[Case 2: $\epoch(t') > \epoch(t)$.]  
    \end{description}
\end{proof}

\subsection*{Roberto's suggested Lemmas}

\SetKw{KwStateK}{State}
\SetKwBlock{KwState}{State:}{}
\SetKwFor{While}{while}{}{}%
\SetKw{Break}{break}
\SetKw{Const}{const}

\begin{algorithm}[H]
\caption{Find latest confirmed descendant}
\label{alg:findlatestconf}
\SetAlgoNoLine
\Fn{$\varforvalattime[val=v]{\mathit{next\_child}}(b,head)$}{
    $extension = \{ b' \in \viewattime[time={\varforvalattime[val=v]{t}},val=v], b \prec b' \preceq head \}$\\
    \uIf{$|extension| > 0$}
    {
        \Return{$\argmin_{b' \in extension} \slot(b')$}
    }
    \uElse{
        \Return{$\bot$}
    }
}

\Fn{$\varforvalattime[val=v]{\mathit{find\_latest\_confirmed\_descendant}}(b_c)$}
{
    $\bcand \gets b_c$\label{ln:bcand-set-beginning-of-find-latest}\\
    \Const $head \gets \LMDGHOSTHFC(\viewattime[time={\varforvalattime[val=v]{t}},val=v])$\\
    \Const $phead \gets \LMDGHOSTHFC(\viewattime[time={\slotstart(\slot(\varforvalattime[val=v]{t})-1)},val=v])$\\
    \uIf{$\slot(\varforvalattime[val=v]{t}) = \firstslot(\epoch(\varforvalattime[val=v]{t}))$} {
        $\chkp_{EBA} \gets \guattime[val=v,time={\slotstart(\slot(\varforvalattime[val=v]{t})-1)}]$
    }
    \uElse {
        $\chkp_{EBA} \gets \gjattime[val=v,time={\slotstart(\slot(\varforvalattime[val=v]{t})-1)}]$
    }
    


    \uIf{$\epoch(\bcand) = \epoch(\varforvalattime[val=v]{t}) - 1$ {\bf and}
        $\votsource[blck=phead, time={\varforvalattime[val=v]{t}}] \geq \epoch(\varforvalattime[val=v]{t}) - 2$ {\bf and}
        $(\slot(\varforvalattime[val=v]{t}) = \firstslot(\epoch(\varforvalattime[val=v]{t}))$ {\bf or}
        $(\willNoConflictingChkpBeJustified_v(\chkp(head, \epoch(\varforvalattime[val=v]{t})))$ {\bf and}
        $(\gu(phead) \geq \epoch(\varforvalattime[val=v]{t}) - 1$ {\bf or}
        $\gu(head) \geq \epoch(\varforvalattime[val=v]{t}) - 1)))$\label{ln:if-prev-epoch}}
    {
        \While{$\varforvalattime[val=v]{\mathit{next\_child}}(\bcand,head) \neq \bot$}
        {
            $\btemp \gets \varforvalattime[val=v]{\mathit{next\_child}}(\bcand,head)$\\
            \uIf{$\epoch(\btemp) < \epoch(\varforvalattime[val=v]{t})$ {\bf and}
                $\btemp \preceq phead$ {\bf and}
                $\isOneConfirmed_v(\btemp, \chkp_W)$}
            {
                $\bcand \gets \btemp$\label{ln:set-bcand-in-prev-epoch-loop}
            }
            \uElse { 
                \Break 
            }
        }
    }

    \uIf{$\slot(\varforvalattime[val=v]{t}) = \firstslot(\epoch(\varforvalattime[val=v]{t}))$ {\bf or}
        $\gu(head) \geq \epoch(\varforvalattime[val=v]{t}) - 1$\nllabel{ln:second-if}}
    {
        $\btcand \gets \bcand$\;
        \While{$\varforvalattime[val=v]{\mathit{next\_child}}(\btcand,head) \neq \bot$}
        {
            $\btemp \gets \varforvalattime[val=v]{\mathit{next\_child}}(\btcand,head)$\\
            \uIf{$\epoch(\btemp) > \epoch(\btcand)$ {\bf and}
                $\neg \willChkpBeJustified_v(\chkp(\btemp))$\label{ln:check-will-chkp-be-justified}}
            {
                \Break
            }
            \uIf{$\isOneConfirmed_v(\btemp, \chkp_W)$\label{ln:if-is-one-confirmed-second-loop}} {
                $\btcand \gets \btemp$\label{set-btcand-to-btemp}
            }
            \uElse { 
                \Break 
            }
        }

        \uIf{$\epoch(\btcand) = \epoch(\varforvalattime[val=v]{t})$ {\bf or}
            $(\votsource[blck=\btcand, time={\varforvalattime[val=v]{t}}] \geq \epoch(\varforvalattime[val=v]{t}) - 2$ {\bf and}
            $(\slot(\varforvalattime[val=v]{t}) = \firstslot(\epoch(\varforvalattime[val=v]{t}))$ {\bf or}
            $\willNoConflictingChkpBeJustified_v(\chkp(head, \epoch(\varforvalattime[val=v]{t})))))$\label{ln:if-to-set-bcand-to-btcand}}
        {
            $\bcand \gets \btcand$\label{ln:set-bcand-to-btcand}
        }
    }

    \Return{$\bcand$}
    \marklastline{lastline}
}
\end{algorithm}

% \setcounter{algocf}{10}
\addtocounter{algocf}{-1}

\begin{algorithm}[H]
\caption{Full Algo}
\label{alg:conffull}
\SetAlgoNoLine
\continuefrom{lastline}
% \DontPrintSemicolon
% \KwStateK{$x \in \mathbb{R}$\\ $y \in \mathbb{R}$}\\
\KwState{
    $\varforvalattime[val=v]{\bconfirmed}$
}
\Upon{$\varforvalattime[val=v]{t} = \varforvalattime[val=v]{\tinit}$}{
    $\varforvalattime[val=v]{\bconfirmed}   \gets \block(\gfattime[time={\varforvalattime[val=v]{t}},val=v])$
}
\Upon{$\varforvalattime[val=v]{t} = \slotstartslot{\varforvalattime[val=v]{t}} \land \varforvalattime[val=v]{t} \geq \varforvalattime[val=v]{\tinit}$}{
    $\varforvalattime[val=v]{\bconfirmed} \gets \varforvalattime[val=v]{\mathit{get\_latest\_confirmed}}(\varforvalattime[val=v]{\bconfirmed})$
}
\Fn{$\varforvalattime[val=v]{\mathit{is\_chain\_one\_confirmed}}(b_c, C)$}{
    $b \gets b_c$\\
    \While{$b \neq \block(C) \land \isOneConfirmed_v(b_c, C)$}{
        $b \gets \parent(b)$
    }

    \Return{$b = \block(C)$}
}
\Proc{$\varforvalattime[val=v]{\mathit{get\_latest\_confirmed}}(b_c)$}{
    $\bcand \gets b_c$\label{ln:set-bcand-beginning-of-get-latest-confirmed}\\
    \Const $\head \gets \LMDGHOSTHFC(\viewattime[time={\varforvalattime[val=v]{t}},val=v])$\\

    \uIf{$\epoch(\bcand) < \epoch(\varforvalattime[val=v]{t}) - 1$ {\bf or}
        $\bcand \npreceq \head$ {\bf or}
        $(\slot(\varforvalattime[val=v]{t}) = \firstslot(\epoch(\varforvalattime[val=v]{t}))$ {\bf and}
        $\epoch(\bcand) \geq \epoch(t)-1$  {\bf and}
        $\neg \varforvalattime[val=v]{\mathit{is\_chain\_one\_confirmed}}(b_c, \guattime[val=v,time=\slotstart(\slot(t)-1)]))$\label{ln:if-bcand-npreceq-head}}{
        $\bcand \gets \block(\gfattime[val=v,time={\varforvalattime[val=v]{t}}])$\label{ln:set-bcand-to-fin}
    }

    \uIf{$\slot(\varforvalattime[val=v]{t}) = \firstslot(\epoch(\varforvalattime[val=v]{t}))$ {\bf and}
        $\epoch(\guattime[val=v,time={\slotstart(\slot(\varforvalattime[val=v]{t})-1)}]) = \epoch(\varforvalattime[val=v]{t})-1$ {\bf and}
        $\slot(\bcand) < \slot(\block(\guattime[val=v,time={\slotstart(\slot(\varforvalattime[val=v]{t})-1)}]))$\label{ln:start-conf-chain}}
    {
        $\bcand \gets \block(\guattime[val=v,time={\slotstart(\slot(\varforvalattime[val=v]{t})-1)}])$\label{ln:set-bcan-on-start-conf-chain}
    }

    \uIf{$\epoch(\bcand) \geq \epoch(\varforvalattime[val=v]{t}) - 1$\label{ln:if-bcand-e-1}}
    {
        $\bcand \gets \varforvalattime[val=v]{\mathit{find\_latest\_confirmed\_descendant}}(\bcand)$\label{ln:set-bcand-to-output-find-latest}
    }

    \Return{$\bcand$}
}
\end{algorithm}

\begin{definition}[Notation]\leavevmode\label{def:b-cand-is-b-conf}
    \begin{enumerate}
        \item Let $\varforvalattime[time=t,val=v]{\bconfirmed}$ be the value of $\varforvalattime[val=v]{\bconfirmed}$ after the execution of any code that should be executed at timer $t$ as per \Cref{alg:conffull}.
        If $t < \varforvalattime[val=v]{\tinit}$, then $\varforvalattime[time=t,val=v]{\bconfirmed}$ corresponds to the value of $\varforvalattime[val=v]{\bconfirmed}$ after executing any code that should be executed at time $\varforvalattime[val=v]{\tinit}$.
        With this convention, we have the property that $\varforvalattime[val=v,time=\slotstart(\slot(t))]{get\_latest\_confirmed}(b_c)$ implies that $b_c = \varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}$.
        \item Let $\varforvalattime[val=v,time=\slotstartslot{t}]{\bcands}$ be the set of all the values assumed by $\bcand$ during the execution of \Cref{alg:conffull} by validator $v$ at time $\slotstartslot{t}$
        \item $\canonical[time=t,blck=b]$ means that any time time $t'\geq t$ block $b$ is canonical in the view of any honest validator.
    \end{enumerate}
\end{definition}

\begin{lemma}[This Lemma is used in the following proofs without explicitly calling it (this is not standard practice though!)]
    \leavevmode
    $\varforvalattime[val=v,time=\slotstart(\slot(t))]{\bconfirmed} \in \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bcands}$
\end{lemma}
\begin{proof}
    Obvious.
\end{proof}

\begin{lemma}\label{lem:conf-current-epoch-then-gu-curr-epoch}
    Pick any $b_c \in  \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bcands}$.
    If
    \begin{enumerate}
        \item $\epoch(b_c) = \epoch(t)$
    \end{enumerate},
    then
    \begin{enumerate}
        \item $\exists b' \in \viewattime[val=v,time=\slotstartslot{t}], b' \succeq b_c \land \epoch(\gu(b')) \geq \epoch(t)-1$
        % \item $\banchor^{v,\slotstart(\slot(t))} \succeq GJ^{v,t}$
    \end{enumerate}
\end{lemma}

\begin{proof}
    % Assume we start executing the algorithm at time $t_0 = \slotstartslot{t_0}$.
    By induction on $\slot(t)$.
    Let $s := \slot(t)$.
    \begin{description}
        \item[Base Case: {$s = \slot(\varforvalattime[val=v]{\tinit})$}.] The Lemma is vacuously true.
        \item[Inductive Case: {$s \geq \slot(\varforvalattime[val=v]{\tinit})$}.] We assume that the Lemma holds for $s$ and prove that it also holds for $s+1$.
        Pick any $b_c \in  \varforvalattime[val=v,time=\slotstart(s+1)]{\bcands}$ such that $\epoch(b_c) = \epoch(s+1)$.
        This implies that slot $s+1 \neq \firstslot(\epoch(s+1))$ as, if so, it could not be that  $\epoch(b_c) = \epoch(s+1)$.
        This then implies that  $\epoch(s+1) = \epoch(s)$.
        \begin{description}
            \item[Case 1: {$b_c = \varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}$}.]
            Just apply the inductive hypothesis.
            \item[Case 2: {$b_c \neq \varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}$}.]
            Given that we assume $\epoch(s+1) = \epoch(b_c)$, it must be that the \KwSty{if} condition at \Cref{ln:second-if} is true.
            Given that  $s+1 \neq \firstslot(\epoch(s+1))$, then $\gu(\head) \geq \epoch(s+1)-1$.
            The \KwSty{if} block at \Cref{ln:if-bcand-npreceq-head} ensures that $b_c \preceq \head$.
        \end{description}
    \end{description}
\end{proof}

% \begin{lemma}[Old. Now reaplced by \Cref{lem:conf-current-epoch-then-gu-curr-epoch}]
%     If
%     \begin{enumerate}
%         \item $\epoch(\varforvalattime[val=v,time=\slotstart(\slot(t))]{\bconfirmed}) = \epoch(t)$
%     \end{enumerate},
%     then
%     \begin{enumerate}
%         \item $\exists b' \in \viewattime[val=v,time=\slotstartslot{t}], \epoch(\gu(b')) \geq \epoch(t)-1$
%         % \item $\banchor^{v,\slotstart(\slot(t))} \succeq GJ^{v,t}$
%     \end{enumerate}
% \end{lemma}

% \begin{proof}
%     % Assume we start executing the algorithm at time $t_0 = \slotstartslot{t_0}$.
%     By induction on $\slot(t)$.
%     Let $s := \slot(t)$.
%     \begin{description}
%         \item[Base Case: {$s = \slot(\varforvalattime[val=v]{\tinit})$}.] The Lemma is vacuously true.
%         \item[Inductive Case: {$s \geq \slot(\varforvalattime[val=v]{\tinit})$}.] We assume that the Lemma holds for $s$ and prove that it also holds for $s+1$.
%         We also assume that $\epoch(\varforvalattime[val=v,time=\slotstart(s+1)]{\bconfirmed}) = \epoch(s+1)$ as the Lemma holds vacuously otherwise.
%         This implies that slot $s+1 \neq \firstslot(\epoch(s+1))$ as, if so, it could not be that  $\epoch(\varforvalattime[val=v,time=\slotstart(s+1)]{\bconfirmed}) = \epoch(s+1)$.
%         This then implies that  $\epoch(s+1) = \epoch(s)$.
%         % This implies that $\epoch(s+1) = \epoch(s)$ as, otherwise, it would mean that we are the beginning of epoch $\epoch(s)+1$ and, therefore, it cannot be that $\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) = \epoch(s+1)$ reaching a contradiction.
%         \begin{description}
%             \item[Case 1: {$\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) = \epoch(s)$}.] Given that $\epoch(s+1) = \epoch(s)$, the proof for this case follows directly from the inductive hypothesis.
%             \item[Case 2: {$\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) \neq \epoch(s)$}.] 
%             Given that $\epoch(\varforvalattime[val=v,time=\slotstart(s+1)]{\bconfirmed}) = \epoch(s+1) = \epoch(s)$, it must be that condition at Line XXX is true which implies that the Lemma holds.
%         \end{description}
%     \end{description}
% \end{proof}

% \begin{lemma}\label{lem:current-epoch-then-gu-prev-epoch}
%     If
%     \begin{enumerate}
%         \item $\epoch(\varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}) = \epoch(t)$
%     \end{enumerate},
%     then
%     \begin{enumerate}
%         \item $\exists b' \in \viewattime[val=v,time=\slotstartslot{t}], b' \succeq \varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed} \land \epoch(\gu(b')) \geq \epoch(t)-1$
%         % \item $\banchor^{v,\slotstart(\slot(t))} \succeq GJ^{v,t}$
%     \end{enumerate}
% \end{lemma}

% \begin{proof}
%     % Assume we start executing the algorithm at time $t_0 = \slotstartslot{t_0}$.
%     By induction on $\slot(t)$.
%     Let $s := \slot(t)$.
%     \begin{description}
%         \item[Base Case: {$s = \slot(\varforvalattime[val=v]{\tinit})$}.] The Lemma is vacuously true.
%         \item[Inductive Case: {$s \geq \slot(\varforvalattime[val=v]{\tinit})$}.] We assume that the Lemma holds for $s$ and prove that it also holds for $s+1$.
%         We also assume that $\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) = \epoch(s+1)$ as the Lemma holds vacuously otherwise.
%         This implies that $\epoch(s+1) = \epoch(s)$ as, otherwise, it would mean that we are the beginning of epoch $\epoch(s)+1$ and, therefore, it cannot be that $\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) = \epoch(s+1)$ reaching a contradiction.
%         \begin{description}
%             \item[Case 1: {$\epoch(\varforvalattime[val=v,time=\slotstart(s-1)]{\bconfirmed}) = \epoch(s)$}.] 
%             Given that $\epoch(s+1) = \epoch(s)$, the proof for this case follows directly from the inductive hypothesis.
%             \item[Case 2: {$\epoch(\varforvalattime[val=v,time=\slotstart(s-1)]{\bconfirmed}) \neq \epoch(s)$}.] 
%             Given that $\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) = \epoch(s+1) = \epoch(s)$, it must be that condition at Line XXX is true which implies that the Lemma holds.
%         \end{description}
%     \end{description}
% \end{proof}

\begin{lemma}\label{lem:output-find-latest-different-to-input}
    Let $b_o := \varforvalattime[val=v]{\mathit{find\_latest\_confirmed\_descendant}}(b_c)$.
    If 
    \begin{enumerate}
        \item $b_o \neq b_c$
        \item $\epoch(b_o) = \epoch(\varforvalattime[val=v]{t}) - 1$
    \end{enumerate},
    then, there exists an honest validator $v'$ such that 
    \begin{enumerate}
        \item $\exists b' \in \left(\viewattime[time=\votingtime(\slot({\varforvalattime[val=v]{t}})-1),val=v'] \cap \viewattime[time=\slotstart(\slot({\varforvalattime[val=v]{t}})),val=v]\right), b' \succeq b_o \land \epoch(\votsource[blck=b',time=\slotstartslot{{\varforvalattime[val=v]{t}}}])\geq \epoch({\varforvalattime[val=v]{t}})-2$
    \end{enumerate}    
\end{lemma}

\begin{proof}
    It must be that $\bcand \gets b_o$ at some point during the execution of   $\mathit{find\_latest\_confirmed\_descendant}$.
    Below by cases on the line  of $\mathit{find\_latest\_confirmed\_descendant}$ where this occurs.
    \begin{description}
        \item[\Cref{ln:bcand-set-beginning-of-find-latest}.]  Impossible as this lines sets $\bcand$ to $b_c \neq b_o$.
        \item[\Cref{ln:set-bcand-in-prev-epoch-loop}.] 
        If $\bcand$ is set to $b_o$ here, then it must be that $b_o \preceq phead$ which also implies $phead \in \viewattime[time=\slotstart({\varforvalattime[val=v]{t}}-1),val=v] \subseteq \viewattime[time=\votingtime({\varforvalattime[val=v]{t}}-1),val=v] \subseteq \viewattime[time=\slotstart({\varforvalattime[val=v]{t}}),val=v]$.
        Then, given \Cref{ln:if-prev-epoch} and the Lemma statement, $phead \succeq b_o \land \epoch(\votsource[blck=phead, time={\slotstartslot{\varforvalattime[val=v]{t}}}]) \geq \epoch({\varforvalattime[val=v]{t}}) - 2$.
        \item[\Cref{ln:set-bcand-to-btcand}] If $\bcand$ is set to $b_o$ here, then, due to \Cref{ln:if-to-set-bcand-to-btcand}, $\epoch(\votsource[blck=b_o, time={\slotstartslot{\varforvalattime[val=v]{t}}}]) \geq \epoch(\varforvalattime[val=v]{t}) - 2$.
        Due to \Cref{ln:if-is-one-confirmed-second-loop,set-btcand-to-btemp}, $\isOneConfirmed(b_o, \cdot)$ which implies\RSfn{We should probably have a Lemma proving such an implication} that there exists an honest validator $v'$ such that
        $b_o \in \left(\viewattime[time=\votingtime({\varforvalattime[val=v]{t}}-1),val=v']\cap \viewattime[time=\slotstart({\varforvalattime[val=v]{t}}),val=v]\right)$.
    \end{description}
\end{proof}

% \begin{lemma}\label{lem:output-find-latest-different-to-input}
%     Let $b_o := \varforvalattime[val=v]{\mathit{find\_latest\_confirmed\_descendant}}(b_c)$.
%     If $b_o \neq b_c$, then
%     then, 
%     \begin{enumerate}
%         \item $\exists b' \in \viewattime[time=\slotstart(\slot({\varforvalattime[val=v]{t}})),val=v'], b' \succeq b_o \land \epoch(\votsource[blck=b',time=\slotstartslot{{\varforvalattime[val=v]{t}}}])\geq \epoch({\varforvalattime[val=v]{t}})-2$
%     \end{enumerate}    
% \end{lemma}

% \begin{proof}
%     It must be that $\bcand \gets b_o$ at some point during the execution of   $\mathit{find\_latest\_confirmed\_descendant}$.
%     Below by cases on the line  of $\mathit{find\_latest\_confirmed\_descendant}$ where this occurs.
%     \begin{description}
%         \item[\Cref{ln:bcand-set-beginning-of-find-latest}.]  Impossible as this lines sets $\bcand$ to $b_c \neq b_o$.
%         \item[\Cref{ln:set-bcand-in-prev-epoch-loop}.] 
%         If $\bcand$ is set here, then it must be that $\bcand \preceq phead$ which also implies $\bcand \in \viewattime[time=\slotstart({\varforvalattime[val=v]{t}}),val=v]$.
%         Then, given \Cref{ln:if-prev-epoch}, $\votsource[blck=phead, time=\slotstart({\varforvalattime[val=v]{t}})] \geq \epoch({\varforvalattime[val=v]{t}}) - 2$.
%         \item[\Cref{ln:set-bcand-to-btcand}] If $\bcand$ is set here, then, due to \Cref{ln:if-to-set-bcand-to-btcand}, $\votsource[blck=\bcand, time={\varforvalattime[val=v]{t}}] \geq \epoch(\varforvalattime[val=v]{t}) - 2$ and clearly $\bcand \in \viewattime[time=\slotstart({\varforvalattime[val=v]{t}}),val=v]$.
%         % Due to \Cref{ln:if-is-one-confirmed-second-loop,set-btcand-to-btemp}, $\isOneConfirmed(\bcand, \cdot)$ which implies\RSfn{We should probably have a Lemma proving such an implication} that there exists an honest validator $v'$ such that
%         % $\bcand \in \viewattime[time=\slotstart({\varforvalattime[val=v]{t}}-1),val=v']$.
%     \end{description}    
% \end{proof}

\begin{lemma}\label{lem:when-restarting-vs-from-prev-epoch}
    Pick any $b_c \in  \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bcands}$.
    If
    \begin{enumerate}
        \item $\epoch(\varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}) < \epoch(t)-1$
        \item $\epoch(b_c) \geq \epoch(t)-1$
    \end{enumerate},
    then, there exists an honest validator $v'$ such that 
    \begin{enumerate}
        \item $\exists b' \in \viewattime[time=\votingtime(\slot(t)-1),val=v'], b' \succeq b_c \land \epoch(\votsource[blck=b',time=\slotstartslot{t}])\geq \epoch(t)-2$
    \end{enumerate}
\end{lemma}
\begin{proof}
    Let $s:= \slot(t)$.
    It must be that we restart the ``confirmation chain'' at time $\slotstart(s)$ as there is no other way to satisfy the conditions in the Lemma's statement.
    This means that conditions at \Cref{ln:start-conf-chain} are true.

    Now, we prove the statement by induction on the lines, in order of execution, where $\bcand$ might be set.
    
    Given the above, we know that the first time it is set is at \Cref{ln:set-bcan-on-start-conf-chain}

    \begin{description}
        \item[\Cref{ln:set-bcan-on-start-conf-chain}.] Obvious. \RSfn{Perhaps explain a bit more why in the future.} 
        \item[\Cref{ln:set-bcand-to-output-find-latest}.] Given $\slot(t) = \firstslot(\epoch(t))$ and the assumption in the Lemma statement, we know that $\epoch(b_c) = \epoch(t) - 1$ and thus can apply \Cref{lem:output-find-latest-different-to-input} to conclude the proof.
    \end{description}
\end{proof}

% \begin{lemma}\label{lem:when-restarting-vs-from-prev-epoch}
%     Pick any $b_c \in  \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bcands}$..
%     If
%     \begin{enumerate}
%         \item $\epoch(\varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}) < \epoch(t)-1$
%         \item $\epoch(b_c) \geq \epoch(t)-1$
%     \end{enumerate},
%     then,
%     \begin{enumerate}
%         \item $\exists b' \in \viewattime[time=\slotstart(\slot(t)),val=v], b' \succeq b_c \land \epoch(\votsource[blck=b',time=\slotstartslot{t}])\geq \epoch(t)-2$
%     \end{enumerate}
% \end{lemma}
% \begin{proof}
%     Let $s:= \slot(t)$.
%     It must be that we restart the ``confirmation chain'' at time $\slotstart(s)$ as there is no other way to satisfy the conditions in the Lemma's statement.
%     This means that conditions at \Cref{ln:start-conf-chain} are true.

%     Now, we prove the statement by induction on the lines, in order of execution, where $\bcand$ might be set.
    
%     Given the above, we know that the first time it is set is at \Cref{ln:set-bcan-on-start-conf-chain}

%     \begin{description}
%         \item[\Cref{ln:set-bcan-on-start-conf-chain}.] Obvious. \RSfn{Perhaps explain a bit more why in the future.} 
%         \item[\Cref{ln:set-bcand-to-output-find-latest}.] Obvious from \Cref{lem:output-find-latest-different-to-input}.
%     \end{description}
% \end{proof}



% \begin{lemma}\label{lem:when-restarting-vs-from-prev-epoch}
%     Pick any $b_c \in  \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bcands}$..
%     If
%     \begin{enumerate}
%         \item $\epoch(\varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}) < \epoch(t)-1$
%         \item $\epoch(b_c) \geq \epoch(t)-1$
%     \end{enumerate},
%     then,
%     \begin{enumerate}
%         \item $\exists b' \in \viewattime[time=\slotstart(\slot(t)),val=v], b' \succeq b_c \land \epoch(\votsource[blck=b',time=\slotstartslot{t}])\geq \epoch(t)-2$
%     \end{enumerate}
% \end{lemma}
% \begin{proof}
%     Let $s:= \slot(t)$.
%     It must be that we restart the ``confirmation chain'' at time $\slotstart(s)$ as there is no other way to satisfy the conditions in the Lemma's statement.
%     This means that conditions at \Cref{ln:start-conf-chain} are true.

%     Now, we prove the statement by induction on the lines, in order of execution, where $\bcand$ might be set.
    
%     Given the above, we know that the first time it is set is at \Cref{ln:set-bcan-on-start-conf-chain}

%     \begin{description}
%         \item[\Cref{ln:set-bcan-on-start-conf-chain}.] Obvious. \RSfn{Perhaps explain a bit more why in the future.} 
%         \item[\Cref{ln:set-bcand-to-output-find-latest}.] Obvious from \Cref{lem:output-find-latest-different-to-input}.
%     \end{description}
% \end{proof}

% \begin{lemma}\label{lem:conf-prev-epoch-then-vs-two-epochs-ago-old}
%     If
%     \begin{enumerate}
%         \item $\epoch(\varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}) \geq \epoch(t)-1$
%     \end{enumerate},
%     then
%     \begin{enumerate}
%         \item $\exists b' \in \viewattime[time=\slotstart(\slot(t)-1),val=v], \epoch(\votsource[blck=b',time=\slotstartslot{t}])\geq \epoch(t)-2$
%         % \item $\banchor^{v,\slotstart(\slot(t))} \succeq GJ^{v,t}$
%     \end{enumerate}
% \end{lemma}

% \begin{lemma}%[Replacement for \Cref{lem:conf-prev-epoch-then-vs-two-epochs-ago-old}]
%     % \label{lem:conf-prev-epoch-then-vs-two-epochs-ago}
%     %  \label{lem:vs-at-least-e-2}
%     Pick any $b_c \in  \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bcands}$.
%     If
%     \begin{enumerate}
%         \item $\epoch(b_c) \geq \epoch(t)-1$
%         \item $\epoch(\varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}) \geq \epoch(t)-1$
%     \end{enumerate},
%     then, 
%     \begin{enumerate}
%         \item $\exists b' \in \viewattime[time=\slotstart(\slot(t)-1),val=v], b' \succeq  b_c \land \epoch(\votsource[blck=b',time=\slotstartslot{t}])\geq \epoch(t)-2$
%         % \item $\banchor^{v,\slotstart(\slot(t))} \succeq GJ^{v,t}$
%     \end{enumerate}
% \end{lemma}

% \begin{proof}
%     By induction on $\slot(t)$.
%     Let $s := \slot(t)$.
%     \begin{description}
%         \item[Base Case: {$s = \slot(\varforvalattime[val=v]{\tinit})$}.] The Lemma is vacuously true.
%         \item[Inductive Case: {$s \geq \slot(\varforvalattime[val=v]{\tinit})$}.] We assume that the Lemma holds for $s$ and prove that it also holds for $s+1$.
%         So let $b_c \in  \varforvalattime[val=v,time=\slotstart(s+1)]{\bcands}$.
%         We also assume that $\epoch(b_c) \geq \epoch(s+1)-1$ and $\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) \geq \epoch(s+1)-1$ as the Lemma holds vacuously otherwise.
%         Note that this implies that $\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) \geq \epoch(s)-1$.
%         By case.
%         \begin{description}
%             \item[Case 1: {$b_c = \varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}$}.] 
%             By sub cases again.
%             \begin{description}
%                 \item[Case 1.1: $\epoch(s+1) = \epoch(s).$] 
%                 Given that $\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed} \in \varforvalattime[val=v,time=\slotstart(s)]{\bcands}$,
%                 we can apply the inductive hypothesis to conclude that $\exists b' \in \viewattime[time=\slotstart(s-1),val=v], b' \succeq b_c \land \epoch(\votsource[blck=b',time=\slotstart(s)])\geq \epoch(s)-2 = \epoch(s+1)-2$.
%                 So, given that $\viewattime[time=\slotstart(s-1),val=v'] \subseteq \viewattime[time=\slotstart(s),val=v']$, the proof for this case is concluded.
%                 \item[Case 1.2: $\epoch(s+1) = \epoch(s) + 1.$]
%                 This Case implies that $\epoch(b_c) = \epoch(s)$ as 
%                 $\epoch(s) = \epoch(s+1) -1 \leq \epoch(b_c) < \epoch(s+1) = \epoch(s) + 1$.
%                 Note also that  $\epoch(s+1) = \epoch(s) + 1$ implies that $s+1 = \firstslot(\epoch(s+1))$.
%                 All of this together with  \Cref{lem:conf-current-epoch-then-gu-curr-epoch} implies that $\exists b' \in \viewattime[time=\slotstart(s),val=v], \epoch(\votsource[blck=b',time=\slotstart(s+1)])\geq \epoch(\gu(b')) \geq \epoch(s)-1\geq\epoch(s+1)-2$.
%             \end{description}
%             \item[Case 2.2: {$b_c \neq \varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}$}.]
%             Now by cases on the first line, in order of execution of the Fast Confirmation Rule algorithm at time $\slotstart(s+1)$, where $\bcand = b_c$. 
%             \begin{description}
%                 \item[\Cref{ln:set-bcand-beginning-of-get-latest-confirmed}.] 
%                 Impossible, as at this line $\bcand = b_c$, but $b_c \neq \varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}$.
%                 \item[\Cref{ln:set-bcand-to-fin}.] Impossible, as at this line $\epoch(\bcand) < \epoch(s+1)-1$, but we assume $\epoch(b_c) \geq \epoch(s+1)-1$.
%                 \item[\Cref{ln:set-bcan-on-start-conf-chain}.] Obvious. \RSfn{Perhaps explain a bit more why in the future.} 
%                 \item[\Cref{ln:set-bcand-to-output-find-latest}.] Obvious from \Cref{lem:output-find-latest-different-to-input}.
%             \end{description}
%         \end{description}
%     \end{description}
% \end{proof}

\begin{lemma}\label{lem:output-find-latest-different-to-input-then-output-older-than-current-slot}
    Let $b_o := \varforvalattime[val=v]{\mathit{find\_latest\_confirmed\_descendant}}(b_c)$.
    If 
    \begin{enumerate}
        \item $b_o \neq b_c$
    \end{enumerate},
    then, 
    \begin{enumerate}
        \item $\slot(b_o) < \slot(\varforvalattime[val=v]{t})$
    \end{enumerate}    
\end{lemma}

\begin{proof}(Sketch)
    Every time that we set $\bcand$, we set it to a block that has received at least a vote from an honest node and honest nodes never vote for blocks in the future.
\end{proof}

\begin{lemma}\label{lem:bcand-less-than-current-slot}
    Pick any $b_c \in  \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bcands}$.
    Then, $\slot(b_c) < \slot(t)$
\end{lemma}

\begin{proof}
    By induction on $\slot(t)$.
    Let $s := \slot(t)$.
    \begin{description}
        \item[Base Case: {$s = \slot(\varforvalattime[val=v]{\tinit})$}.] Obvious.
        \item[Inductive Case: {$s \geq \slot(\varforvalattime[val=v]{\tinit})$}.]
            We assume that the Lemma holds for $s$ and prove that it also holds for $s+1$.
            Pick any $b_c \in \varforvalattime[val=v,time=\slotstart(s+1)]{\bcands}$.
            By cases.
            \begin{description}
                \item[Case 1: {$b_c = \varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}$}.] Then, we can apply the inductive hypothesis and conclude that $\slot(b_c) < s < s+1$.
                \item[Case 2: {$b_c \neq \varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}$}.]
                Now by cases on the first line, in order of execution of the Fast Confirmation Rule algorithm at time $\slotstart(s+1)$, where $\bcand = b_c$. 
                \begin{description}
                    \item[\Cref{ln:set-bcand-beginning-of-get-latest-confirmed}.] 
                    Impossible, as at this line $\bcand = b_c$, but $b_c \neq \varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}$.
                    \item[\Cref{ln:set-bcand-to-fin}.] $\epoch(\bcand) < \epoch(s+1)-1 < \epoch(s+1)$.
                    \item[\Cref{ln:set-bcan-on-start-conf-chain}.] $\epoch(\bcand) = \epoch(s+1)-1 < \epoch(s+1)$. 
                    \item[\Cref{ln:set-bcand-to-output-find-latest}.] Apply \Cref{lem:output-find-latest-different-to-input-then-output-older-than-current-slot}.
                \end{description}
            \end{description}
    \end{description}
\end{proof}


\begin{lemma}\label{lem:bcand-current-epoch-then-no-first-slot}
    Pick any $b_c \in  \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bcands}$.
    If
    \begin{enumerate}
        \item $\epoch(b_c) = \epoch(t)$
    \end{enumerate}
    , then
    \begin{enumerate}
        \item  $\slot(t) > \text{\firstslot}(\epoch(t))$
    \end{enumerate}
\end{lemma}

\begin{proof}(under-construction)\\
    By induction on $\slot(t)$.
    Let $s := \slot(t)$.
    \begin{description}
        \item[Base Case: {$s = \slot(\varforvalattime[val=v]{\tinit})$}.] The Lemma is vacuously true.
        \item[Inductive Case: {$s \geq \slot(\varforvalattime[val=v]{\tinit})$}.]
            We assume that the Lemma holds for $s$ and prove that it also holds for $s+1$.
            Pick any $b_c \in \varforvalattime[val=v,time=\slotstart(s+1)]{\bcands}$ such that $\epoch(b_c) = \epoch(s+1)$.
            By cases.
            \begin{description}
                \item[Case 1: {$b_c = \varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}$}.] From \Cref{lem:bcand-less-than-current-slot} we have that $\slot(b_c) < s$.
                Given that $\firstslot(\epoch(s+1)) \leq \slot(b_c)$, this implies that $\epoch(s) = \epoch(s+1)$.
                By applying the inductive hypothesis, we get $s  \geq \firstslot(\epoch(s)) = \firstslot(\epoch(s+1))$.
                Therefore, $s+1 > s \geq \firstslot(\epoch(s+1))$.
                \item[Case 2: {$b_c \neq \varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}$}.]
                Now by cases on the first line, in order of execution of the Fast Confirmation Rule algorithm at time $\slotstart(s+1)$, where $\bcand = b_c$. 
                \begin{description}
                    \item[\Cref{ln:set-bcand-beginning-of-get-latest-confirmed}.] 
                    Impossible, as at this line $\bcand = b_c$, but $b_c \neq \varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}$.
                    \item[\Cref{ln:set-bcand-to-fin}.] Impossible, as at this line $\epoch(\bcand) < \epoch(s+1)-1$, but we assume $\epoch(b_c) = \epoch(s+1)$.
                    \item[\Cref{ln:set-bcan-on-start-conf-chain}.] Impossible, as at this line $\epoch(\bcand) = \epoch(s+1)-1$. 
                    \item[\Cref{ln:set-bcand-to-output-find-latest}.] From \Cref{lem:bcand-less-than-current-slot}, we have that $\slot(b_c) < \slot(s+1)$. Then, $\slot(s+1) > \slot(b_c) \geq \firstslot(\epoch(s+1))$.
                \end{description}
            \end{description}
    \end{description}
\end{proof}

\begin{lemma}\label{lem:out-find-latest-conf-prec-head}
    Let $b_o := \varforvalattime[val=v]{\mathit{find\_latest\_confirmed\_descendant}}(b_c)$.
    If 
    \begin{enumerate}
        \item $b_o \neq b_c$
    \end{enumerate},
    then, 
    \begin{enumerate}
        \item $b_o \preceq \LMDGHOSTHFC(\viewatstslottime[val=v,time=t])$
    \end{enumerate}
\end{lemma}
\begin{proof}
    Obvious.
\end{proof}

\begin{lemma}
    $\varforvalattime[val=v,time=\slotstart(\slot(t))]{\bconfirmed} \preceq \LMDGHOSTHFC(\viewatstslottime[val=v,time=t])$\label{lem:bconf-always-canonical}
\end{lemma}
\begin{proof}\RSfn{I know that this looks like a very complicated proof to establish something obvious. It's because reasoningon program executions in a manual way is very pedantic in nature.}
    By contradiction, assume that $\varforvalattime[val=v,time=\slotstart(\slot(t))]{\bconfirmed} \npreceq \LMDGHOSTHFC(\viewatstslottime[val=v,time=t])$.
    Note that must be that $\bcand \gets \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bconfirmed}$ at some point during the execution of  $\mathit{find\_latest\_confirmed\_descendant}$ and $\bcand$ is not set any other value (expect for potentially setting it to $\varforvalattime[val=v,time=\slotstart(\slot(t))]{\bconfirmed}$ again) until the \KwSty{return} statement.
    Below by cases on the line  of $\mathit{find\_latest\_confirmed\_descendant}$ where this occurs.
    \begin{description}
        \item[\Cref{ln:set-bcand-beginning-of-get-latest-confirmed}.] 
        If $\bcand = \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bconfirmed} \npreceq \LMDGHOSTHFC(\viewatstslottime[val=v,time=t])$, then \Cref{ln:set-bcand-to-fin} is also executed.
        This line sets $\bcand$ to $\block(\gfattime[val=v,time={\varforvalattime[val=v]{t}}]) \preceq \LMDGHOSTHFC(\viewatstslottime[val=v,time=t])$. 
        Given the above, this implies that \Cref{ln:set-bcand-to-fin} sets $\bcand$ to a value different from $\varforvalattime[val=v,time=\slotstart(\slot(t))]{\bconfirmed}$.
        Therefore \Cref{ln:set-bcand-beginning-of-get-latest-confirmed} is not the last line where $\bcand$ is set $\varforvalattime[val=v,time=\slotstart(\slot(t))]{\bconfirmed}$ and any successive line setting $\bcand$ sets it to $\varforvalattime[val=v,time=\slotstart(\slot(t))]{\bconfirmed}$.\RSfn{Perhaps improve the English here :)}
        \item[\Cref{ln:set-bcand-to-fin}.] Obvious\RSfn{Pehaps explain a bit more why}.
        \item[\Cref{ln:set-bcan-on-start-conf-chain}.] In this case $\bcand = \gjattime[val=v,time=\slot(t)]$ which implies $\varforvalattime[val=v,time=\slotstart(\slot(t))]{\bconfirmed} \preceq \LMDGHOSTHFC(\viewatstslottime[val=v,time=t])$ reaching a contradiction.
        \item[\Cref{ln:set-bcand-to-output-find-latest}.]  \Cref{lem:out-find-latest-conf-prec-head} implies that if this line is executed, then the value of $\bcand$ is not updated which means that there exists a previous line where $\bcand \gets \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bconfirmed}$ reaching a contradiction.
    \end{description}
\end{proof}


\begin{lemma}\label{lem:out-find-latest-conf-descendant-output}
    $\varforvalattime[val=v]{\mathit{find\_latest\_confirmed\_descendant}}(b_c) \succeq b_c$
\end{lemma}
\begin{proof}
    Obvious.
\end{proof}

\begin{lemma}\label{lem:prev-conf-at-least-e-1}
    Pick any $b_c \in  \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bcands}$.
    If
    \begin{enumerate}
        \item $\slot(t) > \text{\firstslot}(\epoch(t))$
        \item $\epoch(b_c) \geq \epoch(t)-1$
    \end{enumerate},
    then
    \begin{enumerate}
        \item $\epoch(\varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}) \geq \epoch(t)-1$
        \item $\varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed} \preceq \LMDGHOSTHFC(\viewatstslottime[val=v,time=t])$
        \item $\varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed} \preceq b_c$
    \end{enumerate}
\end{lemma}

\begin{proof}\RSfn{I think that the structure of this proof should be improved}
By \Cref{def:b-cand-is-b-conf} algorithm execution at $\slotstartslot{t}$ starts with
$b_c = \varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}$.
Given Condition 1 of the Lemma's statement, condition at \Cref{ln:start-conf-chain}
does not hold making code at \Cref{ln:set-bcan-on-start-conf-chain} unreachable.
We also know that condition at \Cref{ln:if-bcand-npreceq-head} does not hold, otherwise,
$b_c = \gfattime[time=\slotstartslot{t},val=v]$
and $\epoch(b_c) \leq \epoch(t) - 2$
which contradicts Condition 2 of the Lemma's statement.

Let's now move to proving Conclusion 3.
By cases.
\begin{description}
    \item[Case 1: {$b_c = \varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bcands}$}.]  Obvious.
    \item[Case 2: {$b_c \neq \varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bcands}$}.]
    Now by cases on the first line, in order of execution of the Fast Confirmation Rule algorithm at time $\slotstart(s+1)$, where $\bcand = b_c$. 
    \begin{description}
        \item[\Cref{ln:set-bcand-beginning-of-get-latest-confirmed}.] 
        Impossible, as at this line $\bcand = b_c$, but $b_c \neq \varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}$.
        \item[\Cref{ln:set-bcand-to-fin}.] Impossible, as at this line $\epoch(\bcand) < \epoch(\slot(t)+1)-1$, but we assume $\epoch(b_c) \geq \epoch(\slot(t)+1) -1$.
        \item[\Cref{ln:set-bcan-on-start-conf-chain}.] Impossible, as at this line cannot be executed if $\slot(t) \neq \firstslot(\epoch(t))$.
        \item[\Cref{ln:set-bcand-to-output-find-latest}.] Given that this is the only line where $\bcand \gets b_c$, \Cref{lem:out-find-latest-conf-descendant-output} implies that $\varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed} \preceq b_c$.
    \end{description}
\end{description}

\end{proof}
\begin{lemma}\label{lem:bcand-prev-epoch-vs-at-least-e-2}
    Pick any $b_c \in  \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bcands}$.
    If
    \begin{enumerate}
        \item $\epoch(b_c) = \epoch(t)-1$
    \end{enumerate},
    then, there exists an honest validator $v'$ such that
    \begin{enumerate}
        \item $\exists b' \in \left(\viewattime[time=\votingtime(\slot(t)-1),val=v'] \cap \viewattime[time=\slotstart(\slot(t)),val=v']\right), b' \succeq b_c \land \epoch(\votsource[blck=b',time=\slotstartslot{t}])\geq \epoch(t)-2$
    \end{enumerate}
\end{lemma}

\begin{proof}
    By induction on $\slot(t)$.
    Let $s := \slot(t)$.
    \begin{description}
        \item[Base Case: {$s = \slot(\varforvalattime[val=v]{\tinit})$}.] The Lemma is vacuously true.
        \item[Inductive Case: {$s \geq \slot(\varforvalattime[val=v]{\tinit})$}.] We assume that the Lemma holds for $s$ and prove that it also holds for $s+1$.
        Pick any $b_c \in \varforvalattime[val=v,time=\slotstart(s+1)]{\bcands}$ such that $\epoch(b_c) \geq \epoch(s+1)-1$.
        % We also assume that $\epoch(b_c) \geq \epoch(s+1)-1$ as the Lemma holds vacuously otherwise.
        \begin{description}
            \item[Case 1: {$\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) < \epoch(s+1)-1$}.] Apply  \Cref{lem:when-restarting-vs-from-prev-epoch}.
            \item[Case 2: {$\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) \geq \epoch(s+1)-1$}.]
            % To prove the Lemma is sufficient 
            By sub cases.
            \begin{description}
                \item[Case 2.1: {$b_c = \varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}$}.] 
                By sub cases again.
                \begin{description}
                    \item[Case 2.1.1: $\epoch(s+1) = \epoch(s).$] 
                    Given that $\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed} \in \varforvalattime[val=v,time=\slotstart(s)]{\bcands}$,
                    we can apply the inductive hypothesis to conclude that there exists an honest validator $v'$ such that $\exists b' \in \left(\viewattime[time=\slotstart(s-1),val=v'] \cap \viewattime[time=\slotstart(s),val=v]\right), b' \succeq b_c \land \epoch(\votsource[blck=b',time=\slotstart(s)])\geq \epoch(s)-2 = \epoch(s+1)-2$.
                    So, given that $\viewattime[time=\slotstart(s-1),val=v'] \subseteq \viewattime[time=\slotstart(s),val=v']$ and $\viewattime[time=\slotstart(s),val=v] \subseteq \viewattime[time=\slotstart(s+1),val=v]$, the proof for this case is concluded.
                    \item[Case 2.1.2: $\epoch(s+1) = \epoch(s) + 1.$]
                    This Case implies that $\epoch(b_c) = \epoch(s)$ as 
                    $\epoch(s) = \epoch(s+1) -1 \leq \epoch(b_c) < \epoch(s+1) = \epoch(s) + 1$.
                    Note also that  $\epoch(s+1) = \epoch(s) + 1$ implies that $s+1 = \firstslot(\epoch(s+1))$.
                    All of this together with  \Cref{lem:conf-current-epoch-then-gu-curr-epoch} implies that $\exists b' \in \viewattime[time=\slotstart(s),val=v] \subseteq \viewattime[time=\slotstart(s+1),val=v], b' \succeq b_c \land \epoch(\votsource[blck=b',time=\slotstart(s+1)])\geq \epoch(\gu(b')) \geq \epoch(s)-1\geq\epoch(s+1)-2$.
                \end{description}
                \item[Case 2.2: {$b_c \neq \varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}$}.]
                Now by cases on the first line, in order of execution of the Fast Confirmation Rule algorithm at time $\slotstart(s+1)$, where $\bcand = b_c$. 
                \begin{description}
                    \item[\Cref{ln:set-bcand-beginning-of-get-latest-confirmed}.] 
                    Impossible, as at this line $\bcand = b_c$, but $b_c \neq \varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}$.
                    \item[\Cref{ln:set-bcand-to-fin}.] Impossible, as at this line $\epoch(\bcand) < \epoch(s+1)-1$, but we assume $\epoch(b_c) \geq \epoch(s+1)-1$.
                    \item[\Cref{ln:set-bcan-on-start-conf-chain}.] Obvious. \RSfn{Perhaps explain a bit more why in the future.} 
                    \item[\Cref{ln:set-bcand-to-output-find-latest}.]
                    The Lemma's statement implies $\epoch(b_c) = \epoch(s+1) - 1$. Then apply \Cref{lem:output-find-latest-different-to-input}.
                \end{description}
            \end{description}
        \end{description}
    \end{description}
\end{proof}

\begin{lemma}\label{lem:bconfirmed-at-first-slot-is-from-e-1}
    Pick any $b_c \in \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bcands}$.
    If
    \begin{enumerate}
        \item $\epoch(b_c) \geq \epoch(t)-1$
    \end{enumerate},
    then,
    \begin{enumerate}
        \item $\epoch(\varforvalattime[val=v,time=\slotstart(\firstslot(\epoch(t)))]{\bconfirmed}) = \epoch(t)-1$.
    \end{enumerate}
\end{lemma}

\begin{proof}
    Let $s := \slot(t)$.
    We know that honest validators do not vote for blocks from the future slots which implies an impossibility of $\epoch(b_c) > \epoch(t)-1$ for any $b_c \in \varforvalattime[val=v,time=\slotstart(s)]{\bcands}$ if $s=\firstslot(\epoch(t))$.
    By cases.
    \begin{description}
        \item[Case 1: {$s = \firstslot(\epoch(t))$}.]
        From the Lemma's condition and the above impossibility we know that $\epoch(b_c) = \epoch(t)-1$ in this case.
        Then the fact that $\varforvalattime[val=v,time=\slotstartslot{t})]{\bconfirmed} \in \varforvalattime[val=v,time=\slotstartslot{t})]{\bcands}$ concludes the proof.
        \item[Case 2: {$s \neq \firstslot(\epoch(t))$}.] Implies $s > \firstslot(\epoch(t))$.
        By contradiction.
        Suppose $\epoch(\varforvalattime[val=v,time=\slotstart(\firstslot(\epoch(t)))]{\bconfirmed}) < \epoch(t)-1$.
        Then consider a slot $s' \geq s$ to be the lowest slot in $\epoch(t)$ for which $\epoch(b') \geq \epoch(t)-1$ for any $b' \in \varforvalattime[val=v,time=\slotstart(s')]{\bcands}$.
        Now by cases on the first line, in order of execution of the Fast Confirmation Rule algorithm at time $\slotstart(s')$, where $\bcand = b_c$. 
        \begin{description}
            \item[\Cref{ln:set-bcand-beginning-of-get-latest-confirmed}.] 
            Impossible, as at this line $\bcand = \varforvalattime[val=v,time=\slotstart(s'-1)]{\bconfirmed}$ but $s'$ is the lowest slot for which $\epoch(b_c) \geq \epoch(t)-1$.
            \item[\Cref{ln:set-bcand-to-fin}.] Impossible, as at this line $\epoch(\bcand) = \epoch(\block(\gfattime[val=v,time=\slotstart(s')])) < \epoch(t)-1$.
            \item[\Cref{ln:set-bcan-on-start-conf-chain}.] Impossible, as $s' \geq s > \firstslot(\epoch(t))$.
            \item[\Cref{ln:set-bcand-to-output-find-latest}.] Impossible, as this line requires $\epoch(\bcand) \geq \epoch(t)-1$ while due to the above $\epoch(\bcand) < \epoch(t)-1$ in this case.
        \end{description}
        Due to the fact that we have reached impossiblity in any of the above cases the proof is concluded.
    \end{description}
\end{proof}

\begin{lemma}\label{lem:exists-b-vs-at-least-e-2}
    Pick any $b_c \in \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bcands}$.
    If
    \begin{enumerate}
        \item $\lastslot(\epoch(t)-1) \geq \GST$
        \item $\epoch(b_c) \geq \epoch(t)-1$
    \end{enumerate},
    then for any honest validator $v'$,
    \begin{enumerate}
        \item $\exists b' \in \viewattime[val=v',time=\slotstart(\epoch(t))]$ such that $\votsource[blck=b',time=\epoch(t)] \geq \epoch(t)-2$.
    \end{enumerate}
\end{lemma}

\begin{proof}
    Due to \Cref{lem:bconfirmed-at-first-slot-is-from-e-1} we know that $\exists b_c \in \varforvalattime[val=v,time=\slotstart(\firstslot(\epoch(t)))]{\bcands}$ such that $\epoch(b_c) = \epoch(t)-1$.
    Then by \Cref{lem:bcand-prev-epoch-vs-at-least-e-2} we know that there exists an honest validator $v^h$ for which $\exists b' \in \viewattime[time=\votingtime(\lastslot(\epoch(t)-1)),val=v^h]$ such that $\epoch(\votsource[blck=b',time=\epoch(t)]) \geq \epoch(t)-2$.
    This together with the synchrony assumption concludes the proof.
\end{proof}

\begin{lemma}\label{lem:gj-at-least-e-2-alt}
    Pick any $b_c \in  \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bcands}$, any time $t' \geq \slotstart(\epoch(t))$ and any honest validator $v'$.
    If
    \begin{enumerate}
        \item $\slotstart(\lastslot(\epoch(t)-1)) \geq \GST$
        \item $\epoch(b_c) \geq \epoch(t)-1$
    \end{enumerate},
    then,
    \begin{enumerate}
        \item $\epoch(\gjattime[val=v',time=t']) \geq \epoch(t)-2$.
    \end{enumerate}
\end{lemma}

\begin{proof}
    Due to \Cref{lem:exists-b-vs-at-least-e-2}, Definition 3 of the Paper and the monotonicity property of the greatest justified checkpoint.
\end{proof}

\begin{lemma}%[Replacement for \Cref{lem:conf-prev-epoch-then-vs-two-epochs-ago-old}]
    \label{lem:conf-prev-epoch-then-vs-two-epochs-ago}
     \label{lem:vs-at-least-e-2}
    Pick any $b_c \in  \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bcands}$.
    If
    \begin{enumerate}
        \item $\slotstart(\lastslot(\epoch(t)-1)) \geq \GST$
        \item $\epoch(b_c) \geq \epoch(t)-1$
    \end{enumerate},
    then, there exists an honest validator $v'$ such that
    \begin{enumerate}
        \item $\exists b' \in \left(\viewattime[time=\votingtime(\slot(t)-1),val=v'] \cap \viewattime[time=\slotstart(\slot(t)),val=v]\right), b' \succeq b_c \land \epoch(\votsource[blck=b',time=\slotstartslot{t}])\geq \epoch(t)-2$
        % \item $\banchor^{v,\slotstart(\slot(t))} \succeq GJ^{v,t}$
    \end{enumerate}
\end{lemma}

\begin{proof}
    Let $s := \slot(t)$.
    \begin{description}
        \item[Case 1: {$\epoch(b_c) = \epoch(s)-1$}.] Apply \Cref{lem:bcand-prev-epoch-vs-at-least-e-2}.
        \item[Case 2: {$\epoch(b_c) \neq \epoch(s)-1$}.] The Lemma's statement implies $\epoch(b_c) = \epoch(s)$ for this case.
        Due to \Cref{ln:if-is-one-confirmed-second-loop,set-btcand-to-btemp}, $\isOneConfirmed(b_c, \cdot)$ which implies\MKfn{We probably should have a Lemma proving such an implication} that there exists an honest validator $v^h$ such that
        $b_c \preceq \LMDGHOSTHFC(\viewattime[val=v^h,time=\votingtime(s')])$ for $s'<s$ which implies $b_c \in \filtered[val=v^h,time=\votingtime(s')]$ . Given that $\epoch(b_c) = \epoch(s)$ and the fact that honest validators never vote for blocks from the future slots, we conclude that $\epoch(s') = \epoch(s)$.
        Then due to \Cref{lem:gj-at-least-e-2-alt} we know that $\epoch(\gjattime[val=v^h,time=\votingtime(s')]) \geq \epoch(s)-2$.
        Given that $b_c \in \filtered[val=v^h,time=\votingtime(s')]$, it must be true that $\exists b' \in \viewattime[val=v^h,time=\votingtime(s')]$ such that $b' \succeq b_c$ and one of the following conditions hold:
        \begin{enumerate}
            \item $\epoch(\votsource[blck=b',time=\slotstart(s)]) = \epoch(\gjattime[val=v^h,time=\votingtime(s')]) \geq \epoch(s)-2$
            \item $\epoch(\votsource[blck=b',time=\slotstart(s)]) \geq \epoch(s)-2$
        \end{enumerate}
        In either case $\epoch(\votsource[blck=b',time=\slotstart(s)]) \geq \epoch(s)-2$.
        Then the fact that $\viewattime[val=v^h,time=\votingtime(s')] \subseteq \viewattime[val=v^h,time=\votingtime(s-1)] \subseteq \viewattime[val=v^h, time=\slotstart(s)]$ concludes the proof.
    \end{description}
\end{proof}

% \begin{lemma}%[Replacement for \Cref{lem:conf-prev-epoch-then-vs-two-epochs-ago-old}]
%     \label{lem:conf-prev-epoch-then-vs-two-epochs-ago}
%      \label{lem:vs-at-least-e-2}
%     Pick any $b_c \in  \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bcands}$.
%     If
%     \begin{enumerate}
%         \item $\epoch(b_c) \geq \epoch(t)-1$
%         % \item $\varforvalattime[val=v,time=\slotstart()]{}
%     \end{enumerate},
%     then, 
%     \begin{enumerate}
%         \item $\exists b' \in \viewattime[time=\slotstart(\slot(t)),val=v], b' \succeq  b_c \land \epoch(\votsource[blck=b',time=\slotstartslot{t}])\geq \epoch(t)-2$
%         % \item $\banchor^{v,\slotstart(\slot(t))} \succeq GJ^{v,t}$
%     \end{enumerate}
% \end{lemma}

% \begin{proof}
%     By induction on $\slot(t)$.
%     Let $s := \slot(t)$.
%     \begin{description}
%         \item[Base Case: {$s = \slot(\varforvalattime[val=v]{\tinit})$}.] The Lemma is vacuously true.
%         \item[Inductive Case: {$s \geq \slot(\varforvalattime[val=v]{\tinit})$}.] We assume that the Lemma holds for $s$ and prove that it also holds for $s+1$.
%         We also assume that $\epoch(b_c) \geq \epoch(s+1)-1$ as the Lemma holds vacuously otherwise.
%         \begin{description}
%             \item[Case 1: {$\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) < \epoch(s+1)-1$}.] Apply  \Cref{lem:when-restarting-vs-from-prev-epoch}.
%             \item[Case 2: {$\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) \geq \epoch(s+1)-1$}.]
%             % To prove the Lemma is sufficient 
%             By sub cases.
%             \begin{description}
%                 \item[Case 2.1: {$b_c = \varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}$}.] 
%                 By sub cases again.
%                 \begin{description}
%                     \item[Case 2.1.1: $\epoch(s+1) = \epoch(s).$] 
%                     Given that $\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed} \in \varforvalattime[val=v,time=\slotstart(s)]{\bcands}$,
%                     we can apply the inductive hypothesis to conclude that  $\exists b' \in \viewattime[time=\slotstart(s),val=v], b' \succeq b_c \land \epoch(\votsource[blck=b',time=\slotstart(s)])\geq \epoch(s)-2 = \epoch(s+1)-2$.
%                     So, given that $\viewattime[time=\slotstart(s),val=v'] \subseteq \viewattime[time=\slotstart(s+1),val=v']$, the proof for this case is concluded.
%                     \item[Case 2.1.2: $\epoch(s+1) = \epoch(s) + 1.$]
%                     This Case implies that $\epoch(b_c) = \epoch(s)$ as 
%                     $\epoch(s) = \epoch(s+1) -1 \leq \epoch(b_c) < \epoch(s+1) = \epoch(s) + 1$.
%                     Note also that  $\epoch(s+1) = \epoch(s) + 1$ implies that $s+1 = \firstslot(\epoch(s+1))$.
%                     All of this together with  \Cref{lem:conf-current-epoch-then-gu-curr-epoch} implies that $\exists b' \in \viewattime[time=\slotstart(s),val=v] \subseteq \viewattime[time=\slotstart(s+1),val=v], \epoch(\votsource[blck=b',time=\slotstart(s+1)])\geq \epoch(\gu(b')) \geq \epoch(s)-1\geq\epoch(s+1)-2$.
%                 \end{description}
%                 \item[Case 2.2: {$b_c \neq \varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}$}.]
%                 Now by cases on the first line, in order of execution of the Fast Confirmation Rule algorithm at time $\slotstart(s+1)$, where $\bcand = b_c$. 
%                 \begin{description}
%                     \item[\Cref{ln:set-bcand-beginning-of-get-latest-confirmed}.] 
%                     Impossible, as at this line $\bcand = b_c$, but $b_c \neq \varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}$.
%                     \item[\Cref{ln:set-bcand-to-fin}.] Impossible, as at this line $\epoch(\bcand) < \epoch(s+1)-1$, but we assume $\epoch(b_c) \geq \epoch(s+1)-1$.
%                     \item[\Cref{ln:set-bcan-on-start-conf-chain}.] Obvious. \RSfn{Perhaps explain a bit more why in the future.} 
%                     \item[\Cref{ln:set-bcand-to-output-find-latest}.] Obvious from \Cref{lem:output-find-latest-different-to-input}.
%                 \end{description}
%             \end{description}
%         \end{description}
%     \end{description}
% \end{proof}


% \begin{lemma}%[Replacement for \Cref{lem:conf-prev-epoch-then-vs-two-epochs-ago-old}]
%     %\label{lem:conf-prev-epoch-then-vs-two-epochs-ago}
%     If
%     \begin{enumerate}
%         \item $\epoch(\varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}) \geq \epoch(t)-1$
%     \end{enumerate},
%     then, there exists an honest validator $v'$ such taht
%     \begin{enumerate}
%         \item $\exists b' \in \viewattime[time=\slotstart(\slot(t)-1),val=v'], b' \succeq  \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bconfirmed} \land \epoch(\votsource[blck=b',time=\slotstartslot{t}])\geq \epoch(t)-2$
%         % \item $\banchor^{v,\slotstart(\slot(t))} \succeq GJ^{v,t}$
%     \end{enumerate}
% \end{lemma}

% \begin{proof}
%     By induction on $\slot(t)$.
%     Let $s := \slot(t)$.
%     \begin{description}
%         \item[Base Case: {$s = \slot(\varforvalattime[val=v]{\tinit})$}.] The Lemma is vacuously true.
%         \item[Inductive Case: {$s \geq \slot(\varforvalattime[val=v]{\tinit})$}.] We assume that the Lemma holds for $s$ and prove that it also holds for $s+1$.
%         We also assume that $\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) \geq \epoch(s+1)-1$ as the Lemma holds vacuously otherwise.
%         % This implies that $\epoch(s+1) = \epoch(s)$ as, otherwise, it would mean that we are the beginning of epoch $\epoch(s)+1$ and, therefore, it cannot be that $\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) = \epoch(s+1)$ reaching a contradiction.
%         \begin{description}
%             \item[{Case 1: $\epoch(\varforvalattime[val=v,time=\slotstart(s-1)]{\bconfirmed}) < \epoch(s)-1$}.] Follows from \Cref{lem:when-restarting-vs-from-prev-epoch}.
%             \item[{Case 2: $\epoch(\varforvalattime[val=v,time=\slotstart(s-1)]{\bconfirmed}) \geq \epoch(s)-1$}] 
%             By the inductive hypothesis, we know that there exists an honest validator $v'$ such that $\exists b' \in \viewattime[time=\slotstart(s-1),val=v'], b' \succeq \varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed} \land \epoch(\votsource[blck=b',time=\slotstart(s)])\geq \epoch(s)-2$.
%             Clearly $b' \in \viewattime[time=\slotstart(s),val=v']$.
%             By cases again
%             \begin{description}
%                 \item[Case 2.1: $\epoch(s+1) = \epoch(s)$.]  Then $\epoch(\votsource[blck=b',time=\slotstart(s+1)])\geq\epoch(\votsource[blck=b',time=\slotstart(s)])\geq \epoch(s)-2 = \epoch(s+1)-2$.
%                 \item[Case 2.2: $\epoch(s+1) = \epoch(s) + 1$.] From our assumption above, $\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) \geq \epoch(s+1)-1 = \epoch(s)$.
%                 Given that $\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) \leq \epoch(s)$, we can conclude that $\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed})= \epoch(s)$.
%                 Note also that  $\epoch(s+1) = \epoch(s) + 1$ implies that $s+1 = \firstslot(\epoch(s+1))$.
%                 All of this together with  \Cref{lem:conf-current-epoch-then-gu-curr-epoch} implies that $\exists b' \in \viewattime[time=\slotstart(s-1),val=v], \epoch(\votsource[blck=b',time=\slotstart(s)])\geq \epoch(s)-1\geq\epoch(s+1)-2$.
%             \end{description}
%         \end{description}
%     \end{description}
% \end{proof}

% \begin{proof}
%     By induction on $\slot(t)$.
%     Let $s := \slot(t)$.
%     \begin{description}
%         \item[Base Case: {$s = \slot(\varforvalattime[val=v]{\tinit})$}.] The Lemma is vacuously true.
%         \item[Inductive Case: {$s \geq \slot(\varforvalattime[val=v]{\tinit})$}.] We assume that the Lemma holds for $s$ and prove that it also holds for $s+1$.
%         We also assume that $\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) \geq \epoch(s+1)-1$ as the Lemma holds vacuously otherwise.
%         % This implies that $\epoch(s+1) = \epoch(s)$ as, otherwise, it would mean that we are the beginning of epoch $\epoch(s)+1$ and, therefore, it cannot be that $\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) = \epoch(s+1)$ reaching a contradiction.
%         \begin{description}
%             \item[{Case 1: $\epoch(\varforvalattime[val=v,time=\slotstart(s-1)]{\bconfirmed}) < \epoch(s)-1$}.] Follows from \Cref{lem:when-restarting-vs-from-prev-epoch}.
%             \item[{Case 2: $\epoch(\varforvalattime[val=v,time=\slotstart(s-1)]{\bconfirmed}) \geq \epoch(s)-1$}] 
%             By the inductive hypothesis, we know that $\exists b' \in \viewattime[time=\slotstart(s-1),val=v], \epoch(\votsource[blck=b',time=\slotstart(s)])\geq \epoch(s)-2$.
%             By cases again
%             \begin{description}
%                 \item[Case 2.1: $\epoch(s+1) = \epoch(s)$.]  Then $\epoch(\votsource[blck=b',time=\slotstart(s+1)])\geq\epoch(\votsource[blck=b',time=\slotstart(s)])\geq \epoch(s)-2 = \epoch(s+1)-2$.
%                 \item[Case 2.2: $\epoch(s+1) = \epoch(s) + 1$.] From our assumption above, $\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) \geq \epoch(s+1)-1 = \epoch(s)$.
%                 Given that $\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) \leq \epoch(s)$, we can conclude that $\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed})= \epoch(s)$.
%                 Note also that  $\epoch(s+1) = \epoch(s) + 1$ implies that $s+1 = \firstslot(\epoch(s+1))$.
%                 All of this together with  \Cref{lem:conf-current-epoch-then-gu-curr-epoch} implies that $\exists b' \in \viewattime[time=\slotstart(s-1),val=v], \epoch(\votsource[blck=b',time=\slotstart(s)])\geq \epoch(s)-1\geq\epoch(s+1)-2$.
%             \end{description}
%         \end{description}
%     \end{description}
% \end{proof}

% \begin{lemma}\label{lem:conf-prev-epoch-then-gj-two-epochs-ago}
%     If
%     \begin{enumerate}
%         \item $\epoch(\varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}) \geq \epoch(t)-1$
%     \end{enumerate},
%     then
%     \begin{enumerate}
%         \item $\epoch(\gjattime[val=v,time=\slotstart(\slot(t))]) \geq \epoch(t)-2$
%         % \item $\banchor^{v,\slotstart(\slot(t))} \succeq GJ^{v,t}$
%     \end{enumerate}
% \end{lemma}

% \begin{proof}
%     By induction on $\slot(t)$.
%     Let $s := \slot(t)$.
%     \begin{description}
%         \item[Base Case: {$s = \slot(\varforvalattime[val=v]{\tinit})$}.] The Lemma is vacuously true.
%         \item[Inductive Case: {$s \geq \slot(\varforvalattime[val=v]{\tinit})$}.] We assume that the Lemma holds for $s$ and prove that it also holds for $s+1$.
%         We also assume that $\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) \geq \epoch(s+1)-1$ as the Lemma holds vacuously otherwise.
%         % This implies that $\epoch(s+1) = \epoch(s)$ as, otherwise, it would mean that we are the beginning of epoch $\epoch(s)+1$ and, therefore, it cannot be that $\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) = \epoch(s+1)$ reaching a contradiction.
%         \begin{description}
%             \item[{Case 1: $\epoch(\varforvalattime[val=v,time=\slotstart(s-1)]{\bconfirmed}) < \epoch(s)-1$}.] Given that we assume that $\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed} ) \geq \epoch(s)-1$, it must be that we restart ``confirmation chain'' at time $\slotstart(s)$. 
%             Therefore $s = \firstslot(\epoch(s))$ and we know that $\epoch(\gjattime[time=\slotstart(s),val=v])=\epoch(s)-1$.
%             This means that we know $\epoch(\gjattime[time=\slotstart(s+1),val=v])\geq\epoch(\gjattime[time=\slotstart(s),val=v])\geq\epoch(s)-1=\epoch(s+1)-1$.
%             \item[{Case 2: $\epoch(\varforvalattime[val=v,time=\slotstart(s-1)]{\bconfirmed}) \geq \epoch(s)-1$}] 
%             By the induction hypothesis, we know that $\epoch(\gjattime[time=\slotstart(s),val=v]) \geq \epoch(s)-2$.
%             By cases again
%             \begin{description}
%                 \item[Case 2.1: $\epoch(s+1) = \epoch(s)$.]  Then $\epoch(\gjattime[time=\slotstart(s+1),val=v])\geq\epoch(\gjattime[time=\slotstart(s),val=v])\geq \epoch(s)-2 = \epoch(s+1)-2$.
%                 \item[Case 2.2: $\epoch(s+1) = \epoch(s) + 1$.] From our assumption above, $\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) \geq \epoch(s+1)-1 = \epoch(s)$.
%                 Given that $\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) \leq \epoch(s)$, we can conclude that $\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed})= \epoch(s)$.
%                 Note also that  $\epoch(s+1) = \epoch(s) + 1$ implies that $s+1 = \firstslot(\epoch(s+1))$.
%                 All of this together with  \Cref{lem:current-epoch-then-gu-curr-epoch} implies that $\epoch(\gjattime[val=v,time=\slotstart(s+1)]) \geq \epoch(s)-1 = \epoch(s+1)-2$.
%             \end{description}
%         \end{description}
%     \end{description}
% \end{proof}

% \begin{proof}(Sketch)
%     By induction on $\slot(t)$.
%     Let $s := \slot(t)$.
%     \begin{description}
%         \item[{Base Case: $\varforvalattime[val=v,time=\slotstart(s-1)]{\bconfirmed} = \block(\gfattime[time=\slotstart(s-1),val=v])$.}] Clearly, $\epoch(\varforvalattime[val=v,time=\slotstart(s-1)]{\bconfirmed} ) < \epoch(t) -1$. Assume then that $\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed} ) \geq \epoch(t)-1$.
%         This means that we restart the confirmation chain, which means that we know that $\epoch(\gjattime[time=\slotstart(s+1),val=v])=\epoch(t)=\epoch(s+1)-1$.
%         \item[Inductive Case.] 
%         We assume the Lemma holds for slot $s$ and prove that it also holds for slot $s+1$.
%         We also assume $\epoch(\varforvalattime[val=v,time=\slotstart(s+1)]{\bconfirmed}) \geq \epoch(s+1)-1$  as the Lemma holds vacuously otherwise. 
%         Now, by cases.
%         \begin{description}
%             \item[{Case 1: $\epoch(\varforvalattime[val=v,time=\slotstart(s-1)]{\bconfirmed}) < \epoch(s)-1$}] Same reasoning as for the base case.
%             \item[{Case 2: $\epoch(\varforvalattime[val=v,time=\slotstart(s-1)]{\bconfirmed}) \geq \epoch(s)-1$}] 
%             By the induction hypothesis, we know that $\epoch(\gjattime[time=\slotstart(s),val=v]) \geq \epoch(s)-2$.
%             By cases again
%             \begin{description}
%                 \item[Case 2.1: $\epoch(s+1) = \epoch(s)$.]  Then $\epoch(\gjattime[time=\slotstart(s+1),val=v])\geq\epoch(\gjattime[time=\slotstart(s),val=v])\geq \epoch(s)-2 = \epoch(s+1)-2$.
%                 \item[Case 2.2: $\epoch(s+1) = \epoch(s) + 1$.] This implies that  $\epoch(\varforvalattime[val=v,time=\slotstart(s+1)]{\bconfirmed}) = \epoch(s)$ as we are at the beginning of epoch $\epoch(s+1)$ so we cannot confirm any block from epoch $\epoch(s+1)$.
%             \end{description}
%         \end{description}
%     \end{description}
%     We prove the following equivalent statement inductively.
%     If $\epoch(\varforvalattime[val=v,time=\slotstartslot{t}]{\isOneConfirmed}) \geq \epoch(s+1)-1$,
%     then $\epoch(\gjattime[val=v,time=\slotstart(s+1)]) \geq \epoch(s+1)-2$.

% \end{proof}

% \begin{lemma}\label{lem:vs-at-least-e-2-old}
%     If
%     \begin{enumerate}
%         \item $\epoch(\varforvalattime[val=v,time=\slotstartslot{t}]{\bcand}) \geq \epoch(t)-1$
%     \end{enumerate},
%     then
%     \begin{enumerate}
%         \item $\exists b' \in \viewattime[time=\slotstart(\slot(t)-1),val=v], \epoch(\votsource[blck=b',time=\slotstartslot{t}])\geq \epoch(t)-2$
%         % \item $\banchor^{v,\slotstart(\slot(t))} \succeq GJ^{v,t}$
%     \end{enumerate}
% \end{lemma}


% \begin{lemma}%[Replacement of \Cref{lem:vs-at-least-e-2-old}]
%     \label{lem:vs-at-least-e-2}
%     If
%     \begin{enumerate}
%         \item $\epoch(\varforvalattime[val=v,time=\slotstartslot{t}]{\bcand}) \geq \epoch(t)-1$
%     \end{enumerate},
%     then
%     \begin{enumerate}
%         \item $\exists b' \in \viewattime[time=\slotstart(\slot(t)-1),val=v], b' \succeq \varforvalattime[val=v,time=\slotstartslot{t}]{\bcand} \land \epoch(\votsource[blck=b',time=\slotstartslot{t}])\geq \epoch(t)-2$
%         % \item $\banchor^{v,\slotstart(\slot(t))} \succeq GJ^{v,t}$
%     \end{enumerate}
% \end{lemma}

% \begin{proof}
%     TBD
% \end{proof}


% \begin{proof}
% By cases.
% \begin{description}
%     \item[Case 1: {$\epoch(\varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}) \geq \epoch(s)-1$}.] Follows from \Cref{lem:conf-prev-epoch-then-vs-two-epochs-ago}.
%     \item[Case 2: {$\epoch(\varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}) < \epoch(s)-1$}.] 
%     From $\epoch(\varforvalattime[val=v,time=\slotstartslot{t}]{\bcand}) \geq \epoch(t)-1$, we can conclude that  $\epoch(\varforvalattime[val=v,time=\slotstartslot{t}]{\bconfirmed}) \geq \epoch(t)-1$.
%     Then, apply \Cref{lem:when-restarting-vs-from-prev-epoch}.
% \end{description}
% \end{proof}

% \begin{lemma}
%     Let $\varforvalattime[val=v,time=\slotstartslot{t}]{\bcand}$ be any of the possible values assumed by $\bcand$ during the execution of \Cref{alg:conffull} by validator $v$ at time $\slotstartslot{t}$
%     If
%     \begin{enumerate}
%         \item $\epoch(\varforvalattime[val=v,time=\slotstartslot{t}]{\bcand}) \geq \epoch(t)-1$
%     \end{enumerate},
%     then
%     \begin{enumerate}
%         \item $\epoch(\gjattime[val=v,time=\slotstart(\slot(t))]) \geq \epoch(t)-2$
%         % \item $\banchor^{v,\slotstart(\slot(t))} \succeq GJ^{v,t}$
%     \end{enumerate}
% \end{lemma}

% \begin{proof}(Sketch)
% \begin{description}
%     \item[Case 1: {$\epoch(\varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}) \geq \epoch(s)-1$}.] Follows from \Cref{lem:conf-prev-epoch-then-gj-two-epochs-ago}.
%     \item[Case 2: {$\epoch(\varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}) < \epoch(s)-1$}.] 
%     Assume that  $\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed} ) \geq \epoch(s)-1$ as, otherwise, the Lemma holds vacuously.
%     Then, it must be that we restart ``confirmation chain'' at time $\slotstart(s)$. 
%     Therefore $s = \firstslot(\epoch(s))$ and we know that $\epoch(\gjattime[time=\slotstart(s),val=v])=\epoch(s)-1$.
% \end{description}
% \end{proof}

% \begin{lemma}\label{lem:no-conflict-chkp-is-justified}
%     % Take an honest validator $v$ and a time $t$.
%     Pick any $b_c \in  \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bcands}$.
%     If
%     \begin{enumerate}
%         % \item $\slotstart(\epoch(t)-1) \geq \GST$
%         \item $\epoch(b_c) \geq \epoch(t) - 1$
%     \end{enumerate},
%     then at least one of the following statements hold:
%     \begin{enumerate}
%         \item $\gjattime[time=\slotstartslot{t},val=v] = \chkp(b_c)$
%         \item there exists a time $t' \leq t$ such that
%         \begin{enumerate}
%             \item $t' = \slotstartslot{t'}$
%             \item $\epoch(t') = \epoch(b_c)$
%             \item $\varforvalattime[val=v,time=t']{\willChkpBeJustified}(\chkp(b_c))$
%         \end{enumerate}
%     \end{enumerate}
% \end{lemma}

% \begin{proof}(by Roberto)
%     By induction on $\slot(t)$.
%     Let $s := \slot(t)$.
%     \begin{description}
%         \item[Base Case: {$s = \slot(\varforvalattime[val=v]{\tinit})$}.] The Lemma is vacuously true.
%         \item[Inductive Case: {$s \geq \slot(\varforvalattime[val=v]{\tinit})$}.]
%             We assume that the Lemma holds for $s$ and prove that it also holds for $s+1$.
%         \begin{description}
%             \item[{Case 1: $\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) < \epoch(s+1) - 1$}.]
%                 We assume condition at \Cref{ln:start-conf-chain} holds, otherwise,
%                 $\varforvalattime[val=v,time=\slotstartslot{s+1}]{\bcand} < \epoch(s+1) - 1$ and the Lemma is vacuously true.
%                 That condition implies $\gjattime[val=v,time=\slotstart(s+1)] = \guattime[val=v,time=\slotstart(s)]$,
%                 $\varforvalattime[val=v,time=\slotstart(s+1)]{\bcand} \succeq \block(\guattime[val=v,time=\slotstart(s)]) = \block(\gjattime[val=v,time=\slotstart(s+1)])$,
%                 $\epoch(\varforvalattime[val=v,time=\slotstart(s+1)]{\bcand}) = \epoch(s+1)-1$.
%                 Thus, $\gjattime[val=v,time=\slotstart(s+1)] = \chkp(\varforvalattime[val=v,time=\slotstart(s+1)]{\bcand},\epoch(s+1)-1)$
%                 concluding Statement 1 of the Lemma.
%             \item[Case 2: {$\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) \geq \epoch(s+1) - 1$}.]
%             Clearly $\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) \geq \epoch(s) - 1$, so the inductive hypothesis holds non-vacuously for $s$.
%             By sub-cases.
%             \begin{description} 
%                 \item[Case 2.1: {$\epoch(\varforvalattime[val=v,time=\slotstart(s+1)]{\bcand}) = \epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bcand})$}.] 
%                 This implies that $\chkp(\varforvalattime[val=v,time=\slotstart(s+1)]{\bcand}) = \chkp(\varforvalattime[val=v,time=\slotstart(s)]{\bcand})$.
%                 \sloppy{Note that if $\gjattime[time=\slotstartslot{t},val=v] = \chkp(\varforvalattime[val=v,time=\slotstartslot{t}]{\bcand})$, then $\varforvalattime[val=v,time=\slotstartslot{t}]{\willChkpBeJustified}(\chkp(\varforvalattime[val=v,time=\slotstartslot{t}]{\bcand}))$.}
%                 Then, the rest follows from the inductive hypothesis.
%                 \item[Case 2.2: {$\epoch(\varforvalattime[val=v,time=\slotstart(s+1)]{\bcand}) = \epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bcand}) + 1$}.] 
%                 Given that $\epoch(\varforvalattime[val=v,time=\slotstart(s+1)]{\bcand}) \leq \epoch(s+1)$, this implies that $\epoch(\varforvalattime[val=v,time=\slotstart(s+1)]{\bcand}) = \epoch(s+1)$.
%                 Then, it must be that the \KwSty{if} blocks at line 23 is executed proving the lemma.
%             \end{description}
%         \end{description}
%     \end{description}
% \end{proof}

% \begin{lemma}\label{lem:no-conflict-chkp-is-justified}
%     Take an honest validator $v$ and a time $t$.
%     If
%     \begin{enumerate}
%         % \item $\slotstart(\epoch(t)-1) \geq \GST$
%         \item $\epoch(\varforvalattime[val=v,time=\slotstartslot{t}]{\bcand}) \geq \epoch(t) - 1$
%     \end{enumerate},
%     then at least one of the following statements hold:
%     \begin{enumerate}
%         \item $\gjattime[time=\slotstartslot{t},val=v] = \chkp(\varforvalattime[val=v,time=\slotstartslot{t}]{\bcand})$
%         \item there exists a time $t' \leq t$ such that
%         \begin{enumerate}
%             \item $t' = \slotstartslot{t'}$
%             \item $\epoch(t') = \epoch(\varforvalattime[val=v,time=\slotstartslot{t}]{\bcand})$
%             \item $\varforvalattime[val=v,time=t']{\willChkpBeJustified}(\chkp(\varforvalattime[val=v,time=\slotstartslot{t}]{\bcand}))$
%         \end{enumerate}
%     \end{enumerate}
% \end{lemma}

% \begin{proof}(by Roberto)
%     By induction on $\slot(t)$.
%     Let $s := \slot(t)$.
%     \begin{description}
%         \item[Base Case: {$s = \slot(\varforvalattime[val=v]{\tinit})$}.] The Lemma is vacuously true.
%         \item[Inductive Case: {$s \geq \slot(\varforvalattime[val=v]{\tinit})$}.]
%             We assume that the Lemma holds for $s$ and prove that it also holds for $s+1$.
%         \begin{description}
%             \item[{Case 1: $\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) < \epoch(s+1) - 1$}.]
%                 We assume condition in line 14 of \Cref{alg:conffull} holds, otherwise,
%                 $\varforvalattime[val=v,time=\slotstartslot{s+1}]{\bcand} < \epoch(s+1) - 1$ and the Lemma is vacuously true.
%                 That condition implies $\gjattime[val=v,time=\slotstart(s+1)] = \guattime[val=v,time=\slotstart(s)]$,
%                 $\varforvalattime[val=v,time=\slotstart(s+1)]{\bcand} \succeq \block(\guattime[val=v,time=\slotstart(s)]) = \block(\gjattime[val=v,time=\slotstart(s+1)])$,
%                 $\epoch(\varforvalattime[val=v,time=\slotstart(s+1)]{\bcand}) = \epoch(s+1)-1$.
%                 Thus, $\gjattime[val=v,time=\slotstart(s+1)] = \chkp(\varforvalattime[val=v,time=\slotstart(s+1)]{\bcand},\epoch(s+1)-1)$
%                 concluding Statement 1 of the Lemma.
%             \item[Case 2: {$\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) \geq \epoch(s+1) - 1$}.]
%             Clearly $\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) \geq \epoch(s) - 1$, so the inductive hypothesis holds non-vacuously for $s$.
%             By sub-cases.
%             \begin{description} 
%                 \item[Case 2.1: {$\epoch(\varforvalattime[val=v,time=\slotstart(s+1)]{\bcand}) = \epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bcand})$}.] 
%                 This implies that $\chkp(\varforvalattime[val=v,time=\slotstart(s+1)]{\bcand}) = \chkp(\varforvalattime[val=v,time=\slotstart(s)]{\bcand})$.
%                 \sloppy{Note that if $\gjattime[time=\slotstartslot{t},val=v] = \chkp(\varforvalattime[val=v,time=\slotstartslot{t}]{\bcand})$, then $\varforvalattime[val=v,time=\slotstartslot{t}]{\willChkpBeJustified}(\chkp(\varforvalattime[val=v,time=\slotstartslot{t}]{\bcand}))$.}
%                 Then, the rest follows from the inductive hypothesis.
%                 \item[Case 2.2: {$\epoch(\varforvalattime[val=v,time=\slotstart(s+1)]{\bcand}) = \epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bcand}) + 1$}.] 
%                 Given that $\epoch(\varforvalattime[val=v,time=\slotstart(s+1)]{\bcand}) \leq \epoch(s+1)$, this implies that $\epoch(\varforvalattime[val=v,time=\slotstart(s+1)]{\bcand}) = \epoch(s+1)$.
%                 Then, it must be that the \KwSty{if} blocks at line 23 is executed proving the lemma.
%             \end{description}
%         \end{description}
%     \end{description}
% \end{proof}







\begin{lemma}\label{lem:no-curr-epochconflict-chkp-is-justified}
    Pick any $b_c \in  \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bcands}$.
    % Take an honest validator $v$ and a time $t$.
    If
    \begin{enumerate}
        % \item $\slotstart(\epoch(t)-1) \geq \GST$
        \item $\epoch(b_c) = \epoch(t)$
    \end{enumerate},
    then,\
    \begin{enumerate}
        % \item $\gjattime[time=\slotstartslot{t},val=v] = \chkp(b_c,\epoch(t) - 1)$
        \item there exists a time $t' \leq t$ such that
        \begin{enumerate}
            \item $t' = \slotstartslot{t'}$
            \item $\epoch(t') = \epoch(t)$
            \item $\varforvalattime[val=v,time=t']{\willChkpBeJustified}(\chkp(b_c))$
        \end{enumerate}
    \end{enumerate}
\end{lemma}

\begin{proof}
    By induction on $\slot(t)$.
    Let $s := \slot(t)$.
    \begin{description}
        \item[Base Case: {$s = \slot(\varforvalattime[val=v]{\tinit})$}.] The Lemma is vacuously true.
        \item[Inductive Case: {$s \geq \slot(\varforvalattime[val=v]{\tinit})$}.]
            We assume that the Lemma holds for $s$ and prove that it also holds for $s+1$.
            Pick any $b_c \in \varforvalattime[val=v,time=\slotstart(s+1)]{\bcands}$ such that $\epoch(b_c) = \epoch(s+1)$.
            This implies $s+1 \neq \firstslot(\epoch(s+1))$ and therfore $\epoch(s) = \epoch(s+1)$.
            By cases.
            \begin{description}
                \item[Case 1: {$\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) = \epoch(s)$}.] 
                % This implies that $s \neq \firstslot(\epoch(s))$.
                \Cref{lem:prev-conf-at-least-e-1} implies that $\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed} \preceq \LMDGHOSTHFC(\viewattime[val=v,time=\slotstart(s+1)])$.
                This implies that $b_c \succeq \varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}$.
                Given that $\epoch(b_c) = \epoch(s) = \epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed})$, $\chkp(b_c) = \chkp(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed})$.
                Then apply the inductive hypothesis.
                \item[Case 2: {$\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) < \epoch(s)$}.] 
                Given that $\epoch(b_c) = \epoch(s+1)$, condition at line \Cref{ln:check-will-chkp-be-justified} must be true for a $\btemp = b'$ such that $b' \preceq b_c \land \epoch(b') = \epoch(b_c)$.
                Hence, $\chkp(b') = \chkp(b_c)$.
                This implies that $\varforvalattime[val=v,time=\slotstart(s+1)]{\willChkpBeJustified}(\chkp(b_c))$.
            \end{description}
    \end{description}
\end{proof}

\RSfn{\Cref{lem:restart-condition-cannot-cause-issues} perhaps not needed.}
\begin{lemma}\label{lem:restart-condition-cannot-cause-issues}
    If
    \begin{enumerate}
        \item $\epoch(\varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}) \geq \epoch(t) - 1$
        \item $\slot(t) = \firstslot(\epoch(t))$
        \item $\epoch(\guattime[time=\slotstart(\slot(t)-1),val=v]) = \epoch(t)-1$
    \end{enumerate},
    then
    \begin{enumerate}
        \item $\block(\guattime[time=\slotstart(\slot(t)-1),val=v])$ does not coflict with $\varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}$.
    \end{enumerate}
\end{lemma}

\begin{proof}
    The Lemma's condition imply that $\epoch(\varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}) = \epoch(\slot(t)-1)$ as $\epoch(\slot(t)-1) = \epoch(t)-1 \leq \epoch(\varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}) < \epoch(t)$.
    Given the $\epoch(\chkp(\varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed})) = \epoch(t)-1$ and $\epoch(\guattime[time=\slotstart(\slot(t)-1),val=v]) = \epoch(t)-1$, 
    \Cref{lem:no-curr-epochconflict-chkp-is-justified} implies that $\guattime[time=\slotstart(\slot(t)-1),val=v]= \chkp(\varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed})$.
    Given that $\chkp(\varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed})$ does not conflict with $\varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}$, the  proof is concluded.
\end{proof}



\begin{lemma}\label{lem:no-prev-epochconflict-chkp-is-justified}
    Pick any $b_c \in  \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bcands}$.
    % Take an honest validator $v$ and a time $t$.
    If
    \begin{enumerate}
        % \item $\slotstart(\epoch(t)-1) \geq \GST$
        \item $\epoch(b_c) \geq \epoch(t) - 1$
    \end{enumerate},
    then at least one of the following statements hold:
    \begin{enumerate}
        % \item $\gjattime[time=\slotstartslot{t},val=v] = \chkp(b_c,\epoch(t) - 1)$
        \item $\chkp(b_c,\epoch(t) - 1) \in \allU(\viewattime[time=\slotstart(\slot(t)-1),val=v])$
        \item there exists a time $t' \leq \slotstart(\lastslot(\epoch(t)-1))$ such that
        \begin{enumerate}
            \item $t' = \slotstartslot{t'}$
            \item $\epoch(t') = \epoch(t)-1$
            \item $\varforvalattime[val=v,time=t']{\willChkpBeJustified}(\chkp(b_c,\epoch(t) - 1))$
        \end{enumerate}
    \end{enumerate}
\end{lemma}

\begin{proof}
    By induction on $\slot(t)$.
    Let $s := \slot(t)$.
    \begin{description}
        \item[Base Case: {$s = \slot(\varforvalattime[val=v]{\tinit})$}.] The Lemma is vacuously true.
        \item[Inductive Case: {$s \geq \slot(\varforvalattime[val=v]{\tinit})$}.]
            We assume that the Lemma holds for $s$ and prove that it also holds for $s+1$.
            Pick any $b_c \in \varforvalattime[val=v,time=\slotstart(s+1)]{\bcands}$ such that $\epoch(b_c) \geq \epoch(s+1) - 1$
        \begin{description}
            \item[{Case 1: $\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) < \epoch(s+1) - 1  \lor \varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed} \npreceq \LMDGHOSTHFC(\viewatstslottime[val=v,time=\slotstart(s+1)])$}.]
                Given that $\epoch(b_c) \geq \epoch(s+1) - 1$, it follows \RSfn{Perhaps we should have a Lemma about this} that condition at \Cref{ln:start-conf-chain} holds.
                This implies that $\gjattime[val=v,time=\slotstart(s+1)] = \guattime[val=v,time=\slotstart(s)]$,
                $b_c \succeq \block(\guattime[val=v,time=\slotstart(s)]) = \block(\gjattime[val=v,time=\slotstart(s+1)])$,
                $\epoch(\guattime[val=v,time=\slotstart(s)]) = \epoch(s+1)-1$.
                Thus, $\gjattime[val=v,time=\slotstart(s+1)] =\guattime[val=v,time=\slotstart(s)]= \chkp(b_c,\epoch(s+1)-1)$
                proving that Statement 1 holds.
            \item[Case 2: {$\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) \geq \epoch(s+1) - 1 \land \varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed} \preceq \LMDGHOSTHFC(\viewatstslottime[val=v,time=\slotstart(s+1)])$}.]
            This case and \Cref{lem:restart-condition-cannot-cause-issues} imply\RSfn{Perhaps we need a Lemma for this} that $b_c \succeq \varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}$.
            Also, clearly $\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) \geq \epoch(s) - 1$, so the inductive hypothesis holds non-vacuously for $s$.
            By sub-cases.
            \begin{description} 
                \item[Case 2.1: $\epoch(s+1)=\epoch(s)$.]
                Given that $b_c \succeq \varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}$ and $\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) \geq \epoch(s+1) - 1$,
                this implies that $\chkp(b_c,\epoch(s+1)-1) = \chkp(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed},\epoch(s)-1)$.
                Then apply the inductive hypothesis.
                \item[Case 2.2: $\epoch(s+1)=\epoch(s)+1$.]
                This case implies that $\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) = \epoch(s)$.
                Then from \Cref{lem:no-curr-epochconflict-chkp-is-justified}, we know that $\exists t', t' =\slotstartslot{t'}\land \epoch(t') = \epoch(s) = \epoch(s+1)-1 \land \varforvalattime[val=v,time=t']{\willChkpBeJustified}(\chkp(\varforvalattime[val=v,time=\slotstartslot{t}]{\bconfirmed}))$.
                Given that $\chkp(\varforvalattime[val=v,time=\slotstartslot{t}]{\bconfirmed}) =  \chkp(\varforvalattime[val=v,time=\slotstartslot{t}]{\bconfirmed},\epoch(s)) = \chkp(\varforvalattime[val=v,time=\slotstartslot{t}]{\bconfirmed},\epoch(s+1)-1)$, the proof for this case is concluded.
                % \item[Case 2.1: {$\epoch(b_c) = \epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed})$}.] 
                % Given that $b_c \succeq \varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}$,
                % this implies that $\chkp(b_c,\epoch()) = \chkp(\varforvalattime[val=v,time=\slotstart(s)]{\bcand})$.
                % \sloppy{Note that if $\gjattime[time=\slotstartslot{t},val=v] = \chkp(\varforvalattime[val=v,time=\slotstartslot{t}]{\bcand})$, then $\varforvalattime[val=v,time=\slotstartslot{t}]{\willChkpBeJustified}(\chkp(\varforvalattime[val=v,time=\slotstartslot{t}]{\bcand}))$.}
                % Then, the rest follows from the inductive hypothesis.
                % \item[Case 2.2: {$\epoch(b_c) = \epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) + 1$}.] 
                % Given that $\epoch(\varforvalattime[val=v,time=\slotstart(s+1)]{\bcand}) \leq \epoch(s+1)$, this implies that $\epoch(\varforvalattime[val=v,time=\slotstart(s+1)]{\bcand}) = \epoch(s+1)$.
                % Then, it must be that the \KwSty{if} blocks at line 23 is executed proving the lemma.
            \end{description}
        \end{description}
    \end{description}
\end{proof}

% \begin{proof}
%     By induction on $\slot(t)$.
%     Let $s := \slot(t)$.
%     \begin{description}
%         \item[Base Case: {$s = \slot(\varforvalattime[val=v]{\tinit})$}.] The Lemma is vacuously true.
%         \item[Inductive Case: {$s \geq \slot(\varforvalattime[val=v]{\tinit})$}.]
%             We assume that the Lemma holds for $s$ and prove that it also holds for $s+1$.
%             Given this, $\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) \geq \epoch(s) - 1$.
%             We also know that $\epoch(\varforvalattime[val=v,time=\slotstart(s+1)]{\bcand}) \leq \epoch(s+1)$.
%             With all this we proceed by cases.
%         \begin{description}
%             \item[{Case 1: $\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) < \epoch(s+1) - 1$}.]
%                 We assume condition in line 14 of \Cref{alg:conffull} holds, otherwise,
%                 $\varforvalattime[val=v,time=\slotstartslot{s+1}]{\bcand} < \epoch(s+1) - 1$ and the Lemma is vacuously true.
%                 That condition implies $\gjattime[val=v,time=\slotstart(s+1)] = \guattime[val=v,time=\slotstart(s)]$,
%                 $\varforvalattime[val=v,time=\slotstart(s+1)]{\bcand} \succeq \block(\guattime[val=v,time=\slotstart(s)]) = \block(\gjattime[val=v,time=\slotstart(s+1)])$,
%                 $\epoch(\varforvalattime[val=v,time=\slotstart(s+1)]{\bcand}) = \epoch(s+1)-1$.
%                 Thus, $\gjattime[val=v,time=\slotstart(s+1)] = \chkp(\varforvalattime[val=v,time=\slotstart(s+1)]{\bcand},\epoch(s+1)-1)$
%                 concluding Statement 1 of the Lemma.
%             \item[{Case 2: $\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) = \epoch(s+1)-1$}]. By cases again.
%                 \begin{description}
%                     \item[{Case 2.1: $\epoch(\varforvalattime[val=v,time=\slotstart(s+1)]{\bcand}) = \epoch(s+1)-1$}].
%                         $\epoch(\varforvalattime[val=v,time=\slotstart(s+1)]{\bcand}) = \epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bcand})$
%                         and $\varforvalattime[val=v,time=\slotstart(s+1)]{\bcand} \succeq \varforvalattime[val=v,time=\slotstart(s)]{\bcand}$
%                         due to line 17 of \Cref{alg:conffull} imply $\chkp(\varforvalattime[val=v,time=\slotstart(s+1)]{\bcand}) = \chkp(\varforvalattime[val=v,time=\slotstart(s)]{\bcand})$.
%                         Then by subcases.
%                         \begin{description}
%                             \item[{Case 2.1.1: $\gjattime[val=v,time=\slotstart(s+1)] = \gjattime[val=v,time=\slotstart(s)]$}].
%                                 By the inductive hypothesis assume Statement 1 holds for $\varforvalattime[val=v,time=\slotstart(s)]{\bcand}$,
%                                 then it's clearly holds for $\varforvalattime[val=v,time=\slotstart(s+1)]{\bcand}$.
%                                 Now assume that only Statement 2 holds for $\varforvalattime[val=v,time=\slotstart(s)]{\bcand}$,
%                                 then there must be $t' \leq st(s)$, $\epoch(t') = \epoch(s)-1 = \epoch(s+1)-1$
%                                 for which $\varforvalattime[val=v,time=t']{\willChkpBeJustified}(\chkp(\varforvalattime[val=v,time=\slotstart(s)]{\bcand}))$.
%                                 Then, clearly Statement 2 holds for slot $s+1$.
%                             \item[{Case 2.1.2: $\gjattime[val=v,time=\slotstart(s+1)] \ne \gjattime[val=v,time=\slotstart(s)]$}].
%                                 From \Cref{lem:gj-at-least-e-2} it follows that
%                                 $\epoch(\gjattime[val=v,time=\slotstart(s)]) \geq \epoch(s) - 2$.
%                                 Then, by definition and monotonicity property of greatest justified checkpoint,
%                                 we have $\epoch(\gjattime[val=v,time=\slotstart(s)]) = \epoch(s)-2$ and
%                                 $\epoch(\gjattime[val=v,time=\slotstart(s+1)]) = \epoch(s)-1$.
%                                 Thus, Statement 1 doesn't hold for slot $s$, and then by inductive hypothesis
%                                 it must be that Statement 2 holds, which implies
%                                 $\varforvalattime[val=v,time=t']{\willChkpBeJustified}(\chkp(\varforvalattime[val=v,time=\slotstart(s)]{\bcand}))$,
%                                 $\epoch(t') = \epoch(s)-1$. Given that, the syncrhony assumption and the fact that
%                                 $\epoch(\gjattime[val=v,time=\slotstart(s+1)]) = \epoch(s) - 1$ we conclude
%                                 $\gjattime[val=v,time=\slotstart(s+1)] = \chkp(\varforvalattime[val=v,time=\slotstart(s)]{\bcand})$.
%                                 Thus, Statement 1 of the Lemma holds for slot $s+1$.
%                         \end{description}
%                     \item[{Case 2.2: $\epoch(\varforvalattime[val=v,time=\slotstart(s+1)]{\bcand}) = \epoch(s+1)$}].
%                         This case is only possible if condition in line 23 of \Cref{alg:findlatestconf}
%                         holds for $b' \in \viewattime[val=v,time=s+1]$, $\epoch(b') = \epoch(s+1)$,
%                         thus $\varforvalattime[val=v,time=\slotstart(s+1)]{\willChkpBeJustified}(\chkp(b'))$.
%                         By lines 1-7 and 22 of \Cref{alg:findlatestconf} we know that $\varforvalattime[val=v,time=\slotstart(s+1)]{\bcand} \succeq b'$,
%                         this and the fact that $\epoch(b') = \epoch(\varforvalattime[val=v,time=\slotstart(s+1)]{\bcand})$ implies
%                         $\chkp(\varforvalattime[val=v,time=\slotstart(s+1)]{\bcand}) = \chkp(b')$.
%                         From this it follows that Statement 2 of the Lemma holds for $t' = \slotstart(s+1)$.
%                 \end{description}
%             \item[{Case 3: $\epoch(\varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed}) = \epoch(s+1)$}].
%                 By definition $\epoch(\gjattime[val=v,time=\slotstart(s+1)]) < \epoch(s+1)$, thus, Statement 1 of the Lemma cannot hold for this case.
%                 Then, by the inductive hypothesis, we know that Statement 2 of the Lemma holds for $t' \leq \slotstart(s)$.
%                 We also have $\varforvalattime[val=v,time=\slotstart(s+1)]{\bcand} \succeq \varforvalattime[val=v,time=\slotstart(s)]{\bcand}$
%                 due to line 17 of \Cref{alg:conffull}.
%                 Thus, $\chkp(\varforvalattime[val=v,time=\slotstart(s+1)]{\bcand}) = \chkp(\varforvalattime[val=v,time=\slotstart(s)]{\bcand})$
%                 which together with the inductive hypothesis concludes proof for the Statement 2 of the Lemma for slot $s+1$.
%         \end{description}
%     \end{description}    
% \end{proof}

\begin{property}\label{prop:on-chkp-prec}
    Let $C_1$ be a checkpoint and $e$ be an epoch.
    If
    \begin{enumerate}
        \item $b \preceq b'$
        \item $C_1 \preceq b'$
        \item $\epoch(C_1) \leq \epoch(b)$
    \end{enumerate}, 
    then, for any $e \geq \epoch(C_1)$,
    \begin{enumerate}
        \item $C_1 \preceq \chkp(b,e)$
    \end{enumerate}
\end{property}

\begin{lemma}\label{lem:gj-does-not-conflict}
    Pick any $b_c \in  \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bcands}$.
    If
    \begin{enumerate}
        \item $\slotstart(\lastslot(\epoch(t)-1)) \geq \GST$
        \item $\epoch(b_c) \geq \epoch(t) - 1$
    \end{enumerate},
    then, for any honest validator $v'$,
    \begin{enumerate}
        \item $\gjattime[time=\slotstartslot{t},val=v'] \preceq b_c$
        % \item $\gjattime[val=v', time=\slotstart(\slot(t))] \succeq \gjattime[val=v, time=\slotstart(\slot(t)-1)]$
    \end{enumerate}
\end{lemma}

\begin{proof}
    Let $s := \slot(t)$.
    Due to \Cref{lem:vs-at-least-e-2}, we know that there exists an honest validator $v_h$ such that $\exists b' \in \viewattime[time=\votingtime(s-1),val=v_h], b' \succeq b_c \land \epoch(\votsource[blck=b',time=\slotstart(s)])\geq \epoch(s)-2$.
    Due to synchrony this implies that $\epoch(s)-2 \leq \epoch(\votsource[blck=b',time=\slotstart(s)]) \leq \epoch(\gjattime[time=\slotstart(s-1),val=v_h]) \leq \epoch(\gjattime[time=\slotstart(s),val=v']) \leq \epoch(s)-1$.
    By cases.
    \begin{description}
        \item[Case 1: {$\epoch(\gjattime[time=\slotstart(s),val=v']) = \epoch(s)-1$}.] 
        % By sub cases.
        % \begin{description}
        %     \item[Case 1.1: $\epoch(b_c) = \epoch(s)$.] 
        %             We can apply \Cref{lem:conf-current-epoch-then-gu-curr-epoch} to conclude that $\gjattime[time=\slotstart(s),val=v']$ does not conflict with $b_c$.
        %     \item[Case 1.2: $\epoch(b_c) = \epoch(s)-1$.] 
            We can apply \Cref{lem:no-prev-epochconflict-chkp-is-justified} to conclude that $\gjattime[time=\slotstartslot{t},val=v'] = \chkp(b_c, \epoch(s)-1)\preceq b_c$.
        % \end{description}
        \item[Case 2: {$\epoch(\gjattime[time=\slotstart(s),val=v']) = \epoch(s)-2$}.] This implies that $\epoch(\gjattime[time=\slotstart(s-1),val=v_h])= \epoch(s)-2$ which further implies that $\epoch(\votsource[blck=b',time=\slotstart(s)]) = \epoch(s)-2$.
        Hence, $\gjattime[time=\slotstartslot{t},val=v'] = \votsource[blck=b',time=\slotstart(s)]$.
        Given that $b' \succeq b_c \land \epoch(b_c) \geq \epoch(\votsource[blck=b',time=\slotstart(s)])$ we can apply \Cref{prop:on-chkp-prec} to conclude  $\gjattime[time=\slotstartslot{t},val=v'] = \votsource[blck=b',time=\slotstart(s)] \preceq b_c$.
    \end{description}
\end{proof}



% \begin{proof}(by Roberto)
%     Let $s := \slot(t)$.
%     Due to the synchrony assumption and \Cref{lem:vs-at-least-e-2}, we know that $\exists b' \in \viewattime[time=\slotstart(s),val=v] \cap \viewattime[time=\slotstart(s),val=v'] , b' \succeq  b_c \land \epoch(\votsource[blck=b',time=\slotstart(s)])\geq \epoch(s)-2$.
%     This implies that \{$\epoch(\gjattime[time=\slotstart(s),val=v]),\epoch(\gjattime[time=\slotstart(s),val=v'])\} \subseteq \{\epoch(s)-2,\epoch(s)-1\}$.
%     \begin{description}
%         \item[Case 1: {$\epoch(\gjattime[time=\slotstartslot{t},val=v']) = \epoch(s)-1$}.] 
%         We can apply \Cref{lem:no-conflict-chkp-is-justified} to conclude that $\gjattime[time=\slotstartslot{t},val=v']$ does not conflict with $b_c$.

%         \item[Case 2: {$\epoch(\gjattime[time=\slotstartslot{t},val=v']) = \epoch(s)-2$}.] Due to synchrony, $\epoch(\gjattime[time=\slotstart(s),val=v']) \geq \epoch(\gjattime[time=\slotstart(s-1),val=v])$ which implies that $\epoch(\gjattime[time=\slotstart(s-1),val=v])= \epoch(s)-2$.
         
%     \end{description}

%     Given that $\epoch(\varforvalattime[val=v,time=\slotstart(s-1)]{\bcand}) = \epoch(s) - 1 \geq \epoch(s-1)-1$, we can apply \Cref{lem:no-conflict-chkp-is-justified} to conclude that if $\epoch(\gjattime[time=\slotstartslot{t},val=v']) = \epoch(s)-1$, then $\gjattime[time=\slotstartslot{t},val=v']$ does not conflict with $\varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bcand}$.

% \end{proof}

% \begin{lemma}%\label{lem:gj-does-not-conflict-e-1}
%     Pick any $b_c \in  \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bcands}$.
%     If
%     \begin{enumerate}
%         \item $\text{\slotstart}(\text{\lastslot}(\text{\epoch}(t) - 1)) \geq \GST$
%         \item $\epoch(b_c) = \epoch(t) - 1$
%     \end{enumerate},
%     then, for any honest validator $v'$,
%     \begin{enumerate}
%         \item $\gjattime[time=\slotstartslot{t},val=v']$ does not conflict with $b_c$
%         % \item $\gjattime[val=v', time=\slotstart(\slot(t))] \succeq \gjattime[val=v, time=\slotstart(\slot(t)-1)]$
%     \end{enumerate}
% \end{lemma}

% \begin{proof}(by Roberto)
%     Let $s := \slot(t)$.
%     Due the synchrony assumption and \Cref{lem:vs-at-least-e-2}, we know that $\exists b' \in \viewattime[time=\slotstart(s)-1,val=v], b' \succeq  \varforvalattime[val=v,time=\slotstart(s)]{\bconfirmed} \land \epoch(\votsource[blck=b',time=\slotstart(s)])\geq \epoch(s)-2$.
%     This implies that $\epoch(\gjattime[time=\slotstart(s-1),val=v]) \in \{\epoch(s)-2,\epoch(s)-1\}$.
%     \begin{description}
%         \item[Case 1: {$\epoch(\gjattime[time=\slotstartslot{t},val=v']) = \epoch(s)-1$}.] 
%         We can apply \Cref{lem:no-conflict-chkp-is-justified} to conclude that $\gjattime[time=\slotstartslot{t},val=v']$ does not conflict with $\varforvalattime[val=v,time=\slotstart(s)]{\bcand}$.

%         \item[Case 2: {$\epoch(\gjattime[time=\slotstartslot{t},val=v']) = \epoch(s)-2$}.] Due to synchrony, $\epoch(\gjattime[time=\slotstart(s),val=v']) \geq \epoch(\gjattime[time=\slotstart(s-1),val=v])$ which implies that $\epoch(\gjattime[time=\slotstart(s-1),val=v])= \epoch(s)-2$.
         
%     \end{description}

%     Given that $\epoch(\varforvalattime[val=v,time=\slotstart(s-1)]{\bcand}) = \epoch(s) - 1 \geq \epoch(s-1)-1$, we can apply \Cref{lem:no-conflict-chkp-is-justified} to conclude that if $\epoch(\gjattime[time=\slotstartslot{t},val=v']) = \epoch(s)-1$, then $\gjattime[time=\slotstartslot{t},val=v']$ does not conflict with $\varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bcand}$.

% \end{proof}

% \begin{proof}
%     Just a property of how checkpoints are computed.
% \end{proof}

\begin{lemma}\label{lem:gu-prec-gj-start-epoch-when-prec-conf-from-at-least-prev-epoch}
    If
    \begin{enumerate}
        \item $\slotstart(\slot(t)-1)\geq \GST$
        \item $\epoch(\varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}) \geq \epoch(t) - 1$
        \item $\slot(t) = \firstslot(\epoch(t))$
    \end{enumerate},
    then
    \begin{enumerate}
        \item $\guattime[time=\slotstart(\slot(t)-1),val=v] \preceq \gjattime[time=\slotstartslot{t},val=v']$
    \end{enumerate}
\end{lemma}

\begin{proof}
    Let $s:= \slot(t)$.
    The Lemma's condition imply that $\epoch(\varforvalattime[val=v,time=\slotstart(s-1)]{\bconfirmed}) = \epoch(s-1)$ as $\epoch(s-1) = \epoch(s)-1 \leq \epoch(\varforvalattime[val=v,time=\slotstart(s-1)]{\bconfirmed}) < \epoch(t)$.
    \Cref{lem:conf-current-epoch-then-gu-curr-epoch} implies that $\exists b' \in \viewattime[val=v,time=\slotstart(s-1)], b' \succeq \varforvalattime[val=v,time=\slotstart(s-1)]{\bconfirmed} \land \epoch(\gu(b')) \geq \epoch(s-1) = \epoch(s)-2$.
    This and the synchrony assumption imply that $\epoch(s)-2 \leq \epoch(\gu(b')) \leq \epoch(\guattime[time=\slotstart(s-1),val=v] ) \leq \epoch(\gjattime[time=\slotstart(s),val=v']) \leq \epoch(s)-1$.
    By cases on $\epoch(\guattime[time=\slotstart(s-1),val=v] )$.
    \begin{description}
        % \item[Case 1: ${\epoch(\gjattime[time=\slotstart(s),val=v']) = \epoch(s)-1}$.] 
        \item[Case 1: {$\epoch(\guattime[time=\slotstart(s-1),val=v] ) = \epoch(\gjattime[time=\slotstart(s),val=v'])$}.] This implies that  $\guattime[time=\slotstart(s-1),val=v]  = \gjattime[time=\slotstart(s),val=v']$.
        \item[Case 2: {$\epoch(\guattime[time=\slotstart(s-1),val=v] ) \neq \epoch(\gjattime[time=\slotstart(s),val=v'])$}.] This case implies that $\epoch(\gu(b'))= \epoch(\guattime[time=\slotstart(s-1),val=v] ) = \epoch(s)-2$ and $\epoch(\gjattime[time=\slotstart(s),val=v']) = \epoch(s)-1$.
        Given that  $\epoch(\varforvalattime[val=v,time=\slotstart(s-1)]{\bconfirmed}) = \epoch(s-1) = \epoch(s)-1$, \Cref{lem:no-prev-epochconflict-chkp-is-justified} implies that $\gjattime[time=\slotstart(s),val=v'] = \chkp(\varforvalattime[val=v,time=\slotstart(s-1)]{\bconfirmed})$.
        Because $\epoch(\gu(b')) = \epoch(\guattime[time=\slotstart(s-1),val=v] ) \leq \epoch(\gjattime[time=\slotstart(s),val=v']) = \epoch(\chkp(\varforvalattime[val=v,time=\slotstart(s-1)]{\bconfirmed}))$ and $b' \succeq \varforvalattime[val=v,time=\slotstart(s-1)]{\bconfirmed}$, \Cref{prop:on-chkp-prec} implies that $\guattime[time=\slotstart(s-1),val=v] = \gu(b')\preceq \gjattime[time=\slotstart(s),val=v']$.
    \end{description}
\end{proof}

\begin{lemma}
    Pick any $b_c \in  \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bcands}$. 
    If
    \begin{enumerate}
        \item $\slotstart(\slot(t)-1)\geq \GST$
        \item $\epoch(b_c) \geq \epoch(t) - 1$
        \item $\slot(t) = \firstslot(\epoch(t))$
    \end{enumerate},
    then
    \begin{enumerate}
        \item $\guattime[time=\slotstart(\slot(t)-1),val=v] \preceq \gjattime[time=\slotstartslot{t},val=v']$
    \end{enumerate}
\end{lemma}

\begin{proof}
    Let $s:= \slot(t)$.
    By cases.
    \begin{description}
        \item[Case 1: {$\epoch(\varforvalattime[val=v,time=\slotstart(s-1)]{\bconfirmed}) < \epoch(s) - 1$}.] 
        Given that $\epoch(b_c) \geq \epoch(s)-1$, it must be that we restart the ``confirmation chain'' at time $\slotstart(s)$ as there is no other way to satisfy the conditions in the Lemma's statement.
        This means that conditions at \Cref{ln:start-conf-chain} are true.
        Therefore, due to the synchrony assumption, $\gjattime[time=\slotstartslot{t},val=v'] = \guattime[time=\slotstart(s-1),val=v]$.
        \item[Case 2: {$\epoch(\varforvalattime[val=v,time=\slotstart(s-1)]{\bconfirmed}) \geq \epoch(s) - 1$}.] Apply \Cref{lem:gu-prec-gj-start-epoch-when-prec-conf-from-at-least-prev-epoch}.
    \end{description}
\end{proof}

% \begin{lemma}%\label{prop:on-chkp-prec}
%     If
%     \begin{enumerate}
%         \item $C_1 \preceq b'$
%         \item $b \preceq b'$
%         \item $C_2 \preceq b$
%         \item $\epoch(C_1) \leq \epoch(C_2)$
%     \end{enumerate}, 
%     then
%     \begin{enumerate}
%         \item $C_1 \preceq C_2$
%     \end{enumerate}
% \end{lemma}
% \begin{proof}
%     Just a property of how checkpoints are computed.
% \end{proof}


\RS{After all, \Cref{lem:prev-gj-prec-others-gj} is probably not needed :'(}
\begin{lemma}\label{lem:prev-gj-prec-others-gj}
    If
    \begin{enumerate}
        \item $\slotstart(\lastslot(\epoch(t)-1))\geq \GST$
        \item $\epoch(\varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}) \geq \epoch(t) - 1$
        % \item $\slot(t) = \firstslot(\epoch(t))$
    \end{enumerate},
    then
    \begin{enumerate}
        \item $\gjattime[time=\slotstart(\slot(t)-1),val=v] \preceq \gjattime[time=\slotstartslot{t},val=v']$
    \end{enumerate}    
\end{lemma}

\begin{proof}
    By cases.
    From \Cref{lem:vs-at-least-e-2}, we know that $\exists b' \in \viewattime[time=\votingtime(s-1),val=v], b' \succeq \varforvalattime[val=v,time=\slotstart(s-1)]{\bconfirmed} \land \epoch(\votsource[blck=b',time=\slotstart(s-1)])\geq \epoch(s-1)-2$.
    We have $ \epoch(s-1)-2 \leq \epoch(\votsource[blck=b',time=\slotstart(s-1)]) \leq  \epoch(\gjattime[time=\slotstart(s-1),val=v]) \leq   \epoch(s-1)-1$.
    \begin{description}
        \item[Case 1: {$\epoch(\gjattime[time=\slotstart(s),val=v']) \leq \epoch(s-1)-1$}.]
        This case and the synchrony assumption imply that 
        $ \epoch(s-1)-2 \leq \epoch(\votsource[blck=b',time=\slotstart(s-1)]) \leq  \epoch(\gjattime[time=\slotstart(s-1),val=v]) \leq  \epoch(\gjattime[time=\slotstart(s),val=v']) \leq \epoch(s-1)-1$.
        \begin{description}
            \item[Case 1.1: {$\epoch(\gjattime[time=\slotstart(s-1),val=v]) =  \epoch(\gjattime[time=\slotstart(s),val=v'])$}.] Obvious.
            \item[Case 1.2: {$\epoch(\gjattime[time=\slotstart(s-1),val=v]) \neq  \epoch(\gjattime[time=\slotstart(s),val=v'])$}.]
            This case implies that $\epoch(\gjattime[time=\slotstart(s-1),val=v]) = \epoch(s-1)-2 = \epoch(\votsource[blck=b',time=\slotstart(s-1)])$ and $\epoch(\gjattime[time=\slotstart(s),val=v']) = \epoch(s-1)-1$.
            Because $\epoch(\votsource[blck=b',time=\slotstart(s-1)]) = \epoch(s-1) -2 < \epoch(s-1) -1 \leq \epoch(s)-1 \leq \epoch(\varforvalattime[val=v,time=\slotstart(s-1)]{\bconfirmed})$,  $b' \succeq \varforvalattime[val=v,time=\slotstart(s-1)]{\bconfirmed}$, we can apply \Cref{prop:on-chkp-prec} to conclude that $\votsource[blck=b',time=\slotstart(s-1)] \preceq \chkp(\varforvalattime[val=v,time=\slotstart(s-1)]{\bconfirmed},\epoch(s-1)-1)$.
            From $\epoch(\votsource[blck=b',time=\slotstart(s-1)]) = \epoch(\gjattime[time=\slotstart(s-1),val=v] )$ and \Cref{lem:no-prev-epochconflict-chkp-is-justified}, it follows that $\gjattime[time=\slotstart(s-1),val=v] =\votsource[blck=b',time=\slotstart(s-1)] \prec  \chkp(\varforvalattime[val=v,time=\slotstart(s-1)]{\bconfirmed},\epoch(s-1)-1) =  \gjattime[time=\slotstartslot{t},val=v']$.
        \end{description}
        \item[Case 2: {$\epoch(\gjattime[time=\slotstart(s),val=v']) > \epoch(s-1)-1$}.]
        This case implies that $\epoch(\gjattime[time=\slotstart(s),val=v']) = \epoch(s-1) = \epoch(s)-1$ and $s = \firstslot(\epoch(s))$.
        Hence, $\epoch(\varforvalattime[val=v,time=\slotstart(s-1)]{\bconfirmed})= \epoch(s-1)$.
        From \Cref{lem:no-curr-epochconflict-chkp-is-justified} we then have that $\gjattime[time=\slotstart(s),val=v'] = \chkp(\varforvalattime[val=v,time=\slotstart(s-1)]{\bconfirmed})$.
        By sub-cases
        \begin{description}
            \item[Case 2.1: {$\epoch(\gjattime[time=\slotstart(s-1),val=v])= \epoch(s-1)-2$}.] 
            This case implies that $\epoch(\gjattime[time=\slotstart(s-1),val=v])= \epoch(s-1)-2 = \epoch(\votsource[blck=b',time=\slotstart(s-1)])$ which further imples that $\gjattime[time=\slotstart(s-1),val=v] = \votsource[blck=b',time=\slotstart(s-1)]$.
            Because $\epoch(\votsource[blck=b',time=\slotstart(s-1)]) = \epoch(s-1) -2 < \epoch(s-1) = \epoch(\varforvalattime[val=v,time=\slotstart(s-1)]{\bconfirmed})$,  $b' \succeq \varforvalattime[val=v,time=\slotstart(s-1)]{\bconfirmed}$, we can appy \Cref{prop:on-chkp-prec} which, together with $\epoch(\gjattime[time=\slotstart(s),val=v']) = \epoch(s-1)$, allows us to conclude that $\gjattime[time=\slotstart(s-1),val=v] = \votsource[blck=b',time=\slotstart(s-1)] \preceq \chkp(\varforvalattime[val=v,time=\slotstart(s-1)]{\bconfirmed},\epoch(s-1))= \chkp(\varforvalattime[val=v,time=\slotstart(s-1)]{\bconfirmed})= \gjattime[time=\slotstart(s),val=v']$.
            \item[Case 2.2: {$\epoch(\gjattime[time=\slotstart(s-1),val=v])= \epoch(s-1)-1$}.] 
            \Cref{lem:no-prev-epochconflict-chkp-is-justified} implies that $\gjattime[time=\slotstart(s-1),val=v'] = \chkp(\varforvalattime[val=v,time=\slotstart(s-1)]{\bconfirmed},\epoch(s-1)-1)$.
            Then clearly $\gjattime[time=\slotstart(s-1),val=v'] = \chkp(\varforvalattime[val=v,time=\slotstart(s-1)]{\bconfirmed},\epoch(s-1)-1) \preceq \chkp(\varforvalattime[val=v,time=\slotstart(s-1)]{\bconfirmed}) = \gjattime[time=\slotstart(s),val=v']$.
        \end{description}
    \end{description}    
\end{proof}

\begin{lemma}\label{lem:prev-gj-prec-others-gj-alt}
    Pick any $b_c \in  \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bcands}$.
    If
    \begin{enumerate}
        \item $\slotstart(\lastslot(\epoch(t)-1)) \geq \GST$
        \item $\epoch(b_c) \geq \epoch(t)-1$
        \item $\slot(t) \neq \firstslot(\epoch(t))$
    \end{enumerate},
    then
    \begin{enumerate}
        \item $\gjattime[time=\slotstart(\slot(t)-1),val=v] \preceq \gjattime[time=\slotstartslot{t},val=v']$
    \end{enumerate}
\end{lemma}

\begin{proof}
    \Cref{lem:prev-conf-at-least-e-1} implies that $\epoch(\varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}) \geq \epoch(t)-1$.
    Then apply \Cref{lem:prev-gj-prec-others-gj}.
\end{proof}

\begin{proof}(that does not require \Cref{lem:prev-gj-prec-others-gj})
    \Cref{lem:prev-conf-at-least-e-1} together with \Cref{lem:bconf-always-canonical} imply $b_c \succeq \varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed} \succeq \gjattime[time=\slotstart(\slot(t)-1),val=v]$.
    Also, due to \Cref{lem:gj-does-not-conflict}, we have that  $b_c \succeq \gjattime[time=\slotstartslot{t},val=v']$.
    Finally, the synchrony assumption implies that $\gjattime[time=\slotstart(\slot(t)-1),val=v] \leq \gjattime[time=\slotstartslot{t},val=v']$ which concludes the proof.
\end{proof}

% \begin{proof}
%     By cases.
%     \begin{description}
%         \item[Case 1: $\epoch(s+1) = \epoch(s)$.]
%         \item[] 
%         \item[Case 2: $\epoch(s+1) = \epoch(s)+1$]  
%     \end{description}
% \end{proof}

% \begin{lemma}\label{lem:gj-does-not-conflict-e-1-old}
%     If
%     \begin{enumerate}
%         \item $\text{\slotstart}(\text{\lastslot}(\text{\epoch}(t) - 1)) \geq \GST$
%         \item $\epoch(\varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bcand}) = \epoch(t) - 1$
%     \end{enumerate},
%     then, for any honest validator $v'$,
%     \begin{enumerate}
%         \item $\gjattime[time=\slotstartslot{t},val=v']$ does not conflict with $\varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bcand}$
%         \item $\gjattime[val=v', time=\slotstart(\slot(t))] \succeq \gjattime[val=v, time=\slotstart(\slot(t)-1)]$
%     \end{enumerate}
% \end{lemma}

% \begin{proof}(by Roberto)
%     Let $s := \slot(t)$.
%     Note that $\epoch(\varforvalattime[val=v,time=\slotstart(s-1)]{\bcand}) = \epoch(s) - 1 \geq \epoch(s-1)-1$. 
%     From \Cref{lem:gj-at-least-e-2-curr-slot}, we know that $\epoch(\gjattime[time=\slotstartslot{t},val=v']) \in \{\epoch(s)-2,\epoch(s)-1\}$.
%     From \Cref{lem:conf-prev-epoch-then-vs-two-epochs-ago}, we know that $\exists b' \in \viewattime[time=\slotstart(\slot(t)-1),val=v], b' \succeq  \varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed} \land \epoch(\votsource[blck=b',time=\slotstartslot{t}])\geq \epoch(t)-2$.
%     Given that $\epoch(\varforvalattime[val=v,time=\slotstart(s-1)]{\bcand}) = \epoch(s) - 1 \geq \epoch(s-1)-1$, we can apply \Cref{lem:no-conflict-chkp-is-justified} to conclude that if $\epoch(\gjattime[time=\slotstartslot{t},val=v']) = \epoch(s)-1$, then $\gjattime[time=\slotstartslot{t},val=v']$ does not conflict with $\varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bcand}$.

% \end{proof}

% \begin{proof}
%     By cases. Let $s := \slot(t)$.
%     \begin{description}
%         \item[Case 1: {$\epoch(\varforvalattime[val=v,time=\slotstart(\slot(t)-2)]{\bconfirmed}) < \epoch(t) - 1$}.]
%             We must have restarted the confirmation chain, otherwise, Condition 2 of the Lemma wouldn't held.
%             Then from lines xxx of \Cref{alg:conffull} and because of the synchrony assumption we have
%             $\varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bcand} \succeq \gjattime[val=v',time=\slotstartslot{t}]$
%             which makes Statement 1 and 2 hold.
%         \item[Case 2: {$\epoch(\varforvalattime[val=v,time=\slotstart(\slot(t)-2)]{\bconfirmed}) >= \epoch(t) - 1$}.]
%             Due to lines xxx of \Cref{alg:conffull} we know that
%             $\exists b' \in \viewattime[val=v,time=\slotstart(s-1)], b' \succeq \varforvalattime[val=v,time=\slotstart(s-1)]{\bcand} \land \epoch(\gu(b')) \geq \epoch(s)-2$.
%             Because $\varforvalattime[val=v,time=\slotstart(s-1)]{\bcand} \preceq \varforvalattime[val=v,time=\slotstart(s-1)]{\LMDGHOSTHFC}$
%             we know that $\chkp(\varforvalattime[val=v,time=\slotstart(s-1)]{\bcand}) \succeq \gu(b') \succeq \gjattime[val=v,time=\slotstart(s-1)]$ for this case.
%             \begin{description}
%                 \item[Subcase 1.1: {$\epoch(\gu(b')) > \epoch(s)-2$}].
%                     Thus, $\epoch(\gu(b')) = \epoch(s)-1$.
%                     It is clear that $\gu(b') = \chkp(\varforvalattime[val=v,time=\slotstart(s-1)]{\bcand})$.
%                     Then because of the synchrony assumption
%                     $\gjattime[val=v',time=\slotstart(s)] = \gu(b') = \chkp(\varforvalattime[val=v,time=\slotstart(s-1)]{\bcand}) \succ \gjattime[val=v,time=\slotstart(s-1)]$
%                     which proves Statement 1 and 2.
%                 \item[Subcase 1.2: {$\epoch(\gu(b')) = \epoch(s)-2$}].
%                     Then because of the synchrony assumption $\epoch(\gjattime[val=v',time=\slotstart(s)]) \geq \epoch(s)-2$.
%                     Also note that $\chkp(\varforvalattime[val=v,time=\slotstart(s-1)]{\bcand}) \succ \gu(b')$ in this case.
%                     Suppose $\epoch(\gjattime[val=v',time=\slotstart(s)]) = \epoch(s)-2$,
%                     then clearly $\chkp(\varforvalattime[val=v,time=\slotstart(s-1)]{\bcand}) \succ \gjattime[val=v',time=\slotstart(s)] = \gu(b') \succeq  \gjattime[val=v,time=\slotstart(s-1)]$.
%                     Otherwise $\epoch(\gjattime[val=v',time=\slotstart(s)])$ must be equal to $\epoch(s)-1$ and then
%                     because of the \Cref{lem:no-conflict-chkp-is-justified}
%                     we have $\gjattime[val=v',time=\slotstart(s)] = \chkp(\varforvalattime[val=v,time=\slotstart(s-1)]{\bcand}) \succ \gu(b') \succeq \gjattime[val=v,time=\slotstart(s-1)]$.
%                     In both of these cases Statement 1 and 2 hold.
%             \end{description}

%     \end{description}
% \end{proof}

% \begin{lemma}\label{lem:gj-does-not-conflict}
%     If
%     \begin{enumerate}
%         \item $\slotstart(\firstslot(\epoch(t)-1)) \geq \GST$
%         \item $\epoch(\varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bcand}) = \epoch(t)$
%     \end{enumerate},
%     then, for any honest validator $v'$,
%     \begin{enumerate}
%         \item $\gjattime[time=\slotstartslot{t},val=v']$ does not conflict with $\varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bcand}$
%         \item $\gjattime[val=v', time=\slotstart(\slot(t))] \succeq \gjattime[val=v, time=\slotstart(\slot(t)-1)]$
%     \end{enumerate}
% \end{lemma}

% \begin{proof}
%     By induction on $\slot(t)$.
%     Let $s := \slot(t)$.
%     \begin{description}
%         \item[Base Case: {$s = \slot(\varforvalattime[val=v]{\tinit})$}.] The Lemma is vacuously true.
%         \item[Inductive Case: {$s \geq \slot(\varforvalattime[val=v]{\tinit})$}.]
%             We assume that the Lemma holds for $s$ and prove that it also holds for $s+1$.
%             \begin{description}
%                 \item[Case 1: {$\epoch(s+1) = \epoch(s)$}.]
%                     Clearly $s-1 > \firstslot(\epoch(s))$, otherwise,
%                     $\epoch(\varforvalattime[val=v,time=\slotstart(s-1)]{\bcand}) = \epoch(s)$ would be impossible.
%                     By \Cref{lem:gj-at-least-e-2-curr-slot} $\epoch(\gjattime[val=v',time=\slotstart(s-1)]) \geq \epoch(s)-2$.
%                     \begin{description}
%                         \item[Subcase 1.1: {$\epoch(\gjattime[val=v,time=\slotstart(s-1)]) > \epoch(s)-2$}.]
%                             Clearly $\epoch(\gjattime[val=v,time=\slotstart(s-1)]) = \epoch(s)-1$ in this case.
%                             Due to line xxx of \Cref{alg:conffull}
%                             $\varforvalattime[val=v,time=\slotstart(s-1)]{\bcand} \succeq \gjattime[val=v,time=\slotstart(s-1)]$,
%                             thus $\gjattime[val=v,time=\slotstart(s-1)] = \chkp(\varforvalattime[val=v,time=\slotstart(s-1)]{\bcand}, \epoch(s)-1)$.
%                             In this case it must be that $\gjattime[val=v',time=\slotstart(s)] \nsucc \gjattime[val=v,time=\slotstart(s-1)]$
%                             as $\gjattime[val=v,time=\slotstart(s-1)]$ has the greatest possible epoch,
%                             thus by the inductive hypothesis $\gjattime[val=v',time=\slotstart(s)] = \gjattime[val=v,time=\slotstart(s-1)]$.
%                             Following the above reasoning $\gjattime[val=v',time=\slotstart(s+1)] = \gjattime[val=v,time=\slotstart(s)] = \gjattime[val=v,time=\slotstart(s-1)]$
%                             which proves Statement 2. Due to line xxx of \Cref{alg:conffull}
%                             $\varforvalattime[val=v,time=\slotstart(s)]{\bcand} \succeq \gjattime[val=v,time=\slotstart(s)]$
%                             proving Statement 1.
%                         \item[Subcase 1.2 (Sketch): {$\epoch(\gjattime[val=v,time=\slotstart(s-1)]) = \epoch(s)-2$}.]
%                             By the inductive hypothesis
%                             $\gjattime[val=v',time=\slotstart(s+1)] \in \{\gjattime[val=v,time=\slotstart(s-1)], \chkp(\varforvalattime[val=v,time=\slotstart(s-1)]{\bcand}, \epoch(s)-1)\}$,
%                             so does the $\gjattime[val=v,time=\slotstart(s)]$.
%                             $\varforvalattime[val=v,time=\slotstart(s)]{\bcand} \succeq \chkp(\varforvalattime[val=v,time=\slotstart(s-1)]{\bcand}, \epoch(s)-1) \succeq \gjattime[val=v,time=\slotstart(s-1)]$.
%                             Thus both statements hold.                            
%                     \end{description}
%                 \item[Case 2: {$\epoch(s+1) > \epoch(s)$}.]
%                     Then we have $\epoch(\varforvalattime[val=v,time=\slotstart((s+1)-1)]{\bcand}) = \epoch(s+1)-1$.
%                     Apply \Cref{lem:gj-does-not-conflict-e-1}.
%             \end{description}
%     \end{description}
% \end{proof}

\RS{Done till here. Some of the Lemmas below might not be necessary anymore. Possibly because they have been replaced by a stronger Lemma above.}

\begin{lemma}\label{lem:gj-at-least-e-2-curr-slot}
    Pick any $b_c \in  \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bcands}$.
    If
    \begin{enumerate}
        \item $\slotstart(\lastslot(\epoch(t)-1)) \geq \GST$
        \item $\epoch(b_c) \geq \epoch(t)-1$
    \end{enumerate},
    then, for any honest validator $v'$,
    \begin{enumerate}
        \item $\epoch(\gjattime[val=v',time=\slotstart(\slot(t))]) \geq \epoch(t)-2$
    \end{enumerate}
\end{lemma}

\begin{proof}
From \Cref{lem:vs-at-least-e-2} we know that there exists an honest validator $v_h$ such that $\exists b' \in \viewattime[time=\votingtime(\slot(t)-1),val=v_h], \epoch(\votsource[blck=b',time=\slotstartslot{t}])\geq \epoch(t)-2$.
Then, because of the synchrony assumption, $b' \in \viewattime[time=\slotstart(\slot(t)),val=v']$.
Finally, by the Definition 3 of the paper $\epoch(\gjattime[val=v',time=\slotstartslot{t}]) = \epoch(\max(\{\votsource[blck=b,time=t]: b \in \viewatstslottime[val=v',time=t]\}))
\geq \epoch(\votsource[blck=b',time=\slotstartslot{t}]) \geq \epoch(t) - 2$.
\end{proof}

\MK{\Cref{lem:gj-at-least-e-2-curr-slot} might not be needed as we have \Cref{lem:gj-at-least-e-2-alt}}.

\begin{lemma}\label{lem:gu-e-1-canonical}
    If
    \begin{enumerate}
        \item $\slotstart(\slot(t)-1) \geq \GST$
        \item $\slot(t) = \firstslot(\epoch(t))$
        \item $\epoch(\guattime[val=v,time=\slotstart(\slot(t)-1)]) = \epoch(t)-1$
    \end{enumerate},
    then,
    \begin{enumerate}
        \item $\canonical[blck={\block(\guattime[val=v,time=\slotstart(\slot(t)-1)])},time=\slotstartslot{t}]$.
    \end{enumerate}
\end{lemma}

\begin{proof}
    By induction on $t' \geq \slotstartslot{t}$.
    Let $b := \block(\guattime[val=v,time=\slotstart(\slot(t)-1)])$.
    We will show that $b \preceq \LMDGHOSTHFC(\viewattime[val=v',time=t'])$.
    \begin{description}
        \item[Base case: {$\epoch(t') = \epoch(t)$}.] Because of the synchrony assumption and the fact that $\epoch(\guattime[val=v,time=\slotstart(\slot(t)-1)]) = \epoch(t)-1$,
        we know that $\gjattime[val=v',time=t'] = \guattime[val=v,time=\slotstart(\slot(t)-1)]$ for any honest validator $v'$ and time $t'$ such that $\epoch(t') = \epoch(t)$.
        Clearly, $b \preceq \LMDGHOSTHFC(\viewattime[val=v',time=t'])$.
        \item[Inductive case: {$\epoch(t') > \epoch(t)$}.] We assume that the Lemma holds for any $t'' \geq t$ such that $\epoch(t'') < \epoch(t')$ and prove that it also holds for $t'$.        
        We will show that $b \preceq \gjattime[val=v',time=t']$. Then, clearly, $b \preceq \LMDGHOSTHFC(\viewattime[val=v',time=t'])$.
        By cases.
        \begin{description}
            \item[Case 1: {$\epoch(\gjattime[val=v',time=t']) = \epoch(\guattime[val=v,time=\slotstart(\slot(t)-1)])$}.] Clearly, $\gjattime[val=v',time=t'] = \guattime[val=v,time=\slotstart(\slot(t)-1)]$ in this case, thus $b = \block(\gjattime[val=v',time=t'])$.
            \item[Case 2: {$\epoch(\gjattime[val=v',time=t']) \neq \epoch(\guattime[val=v,time=\slotstart(\slot(t)-1)])$}.]
            By the definition of the greatest justified checkpoint, $\epoch(\gjattime[val=v',time=t']) \leq \epoch(t')-1$ which implies $\epoch(t) \leq \epoch(\gjattime[val=v',time=t']) \leq \epoch(t'')$ for this case.
            From the inductive hypothesis we know that $b \preceq \LMDGHOSTHFC(\viewattime[val=v',time=t''])$ which implies that during each epoch $e \in \left[\epoch(t), \epoch(t'')\right]$ all honest validators cast their FFG votes in the support of $\chkp(b',e)$ such that $b' \succeq b$.
            Thus, given the synchrony assumption no checkpoint $\chkp'$ conflicting with $b$ such that $\epoch(\chkp') \in \left[\epoch(t), \epoch(t'')\right]$ can ever be justified.
            Given that, we conclude $b \prec \gjattime[val=v',time=t']$.
        \end{description}
        We have show that $b \preceq \gjattime[val=v',time=t']$ which concludes the proof.
    \end{description}
\end{proof}

\begin{definition}
    We define $\varforvalattime[val=v,time=\slotstartslot{t}]{\chkp_{EBA}}$ as the source of the effective balance assignment used by the execution of the Fast Confirmation Rule algorithm at the time $t = \slotstartslot{t}$.
    \begin{equation*}
        {\varforvalattime[val=v,time=\slotstartslot{t}]{\chkp_{EBA}}:=}
        \begin{cases}
            {\guattime[val=v,time=\slotstart(\slot(t)-1)], \text{if } \slot(t)=\firstslot(\epoch(t))},\\
            {\gjattime[val=v,time=\slotstart(\slot(t)-1)], \text{otherwise}}.
        \end{cases}
    \end{equation*}
\end{definition}

\begin{lemma}\label{lem:gj-desc-c-w}
    Pick any $b_c \in  \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bcands}$, any time $t' \geq \slotstartslot{t}$ and any honest validator $v'$.
    If
    \begin{enumerate}
        \item $\slotstart(\lastslot(\epoch(t)-1)) \geq \GST$
        \item $\epoch(b_c) \geq \epoch(t)-1$
        \item $b_c \in \filtered[val=v',time=t']$
    \end{enumerate},
    then
    \begin{enumerate}
        \item $\varforvalattime[val=v,time=\slotstartslot{t}]{\chkp_{EBA}} \preceq \gjattime[val=v',time=t']$.
    \end{enumerate}
\end{lemma}

\begin{proof}
    From \Cref{lem:gu-prec-gj-start-epoch-when-prec-conf-from-at-least-prev-epoch} and \Cref{lem:prev-gj-prec-others-gj-alt} we know that $\varforvalattime[val=v,time=\slotstartslot{t}]{\chkp_{EBA}} \preceq \gjattime[val=v',time=\slotstartslot{t}]$.
    Then due to \Cref{lem:gj-does-not-conflict} $\varforvalattime[val=v,time=\slotstartslot{t}]{\chkp_{EBA}} \preceq \gjattime[val=v',time=\slotstartslot{t}] \preceq b_c$.
    From the definition of the greatest justified checkpoint we have $\epoch(\varforvalattime[val=v,time=\slotstartslot{t}]{\chkp_{EBA}}) \leq \epoch(\gjattime[val=v',time=\slotstartslot{t}]) \leq \epoch(\gjattime[val=v',time=t'])$.
    Given that $b_c \in \filtered[val=v',time=t']$, we know that $b_c$ does not conflict with $\gjattime[val=v',time=t']$.
    With all this in mind we proceed by cases.
    \begin{description}
        \item[Case 1: {$\gjattime[val=v',time=t'] \preceq b_c$}.] Then $\varforvalattime[val=v,time=\slotstartslot{t}]{\chkp_{EBA}} \preceq \gjattime[val=v',time=\slotstartslot{t}] \preceq \gjattime[val=v',time=t'] \preceq b_c$.
        \item[Case 2: {$\gjattime[val=v',time=t'] \npreceq b_c$}.] Implies $b_c \prec \gjattime[val=v',time=t']$, then $\varforvalattime[val=v,time=\slotstartslot{t}]{\chkp_{EBA}} \preceq \gjattime[val=v',time=\slotstartslot{t}] \preceq b_c \prec \gjattime[val=v',time=t']$.
    \end{description}
    In either case $\varforvalattime[val=v,time=\slotstartslot{t}]{\chkp_{EBA}} \preceq \gjattime[val=v',time=t']$.
\end{proof}

\begin{lemma}\label{lem:canonical-if-in-filtered}
    Pick any $b_c \in  \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bcands}$, any time $t' \geq \slotstartslot{t}$ and any honest validator $v'$.
    If
    \begin{enumerate}
        \item $\slotstart(\lastslot(\epoch(t)-1)) \geq \GST$
        \item $\epoch(b_c) \geq \epoch(t)-1$
        \item $b_c \in \filtered[val=v',time=t']$
    \end{enumerate},
    then
    \begin{enumerate}
        \item $b \preceq \LMDGHOSTHFC(\viewattime[val=v',time=t'])$.
    \end{enumerate}
\end{lemma}

\begin{proof}
    (Sketch)
    By induction on $t' \geq \slotstartslot{t}$.
    \begin{description}
        \item[Base case: {$t' < \slotstartslot{t}$}.] The Lemma is vacuously true.
        \item[Inductive case: {$t' \geq \slotstartslot{t}$}.] Let $s:=\slot(t)$, $s':=\slot(t')$
        We assume that the Lemma holds at time $t''$ such that $t'' < t'$ and prove that it also holds at time $t'$.
        From \Cref{lem:gj-desc-c-w} we know that $\varforvalattime[val=v,time=\slotstartslot{t}]{\chkp_{EBA}} \preceq \gjattime[val=v',time=t']$.
        Then the fact that we re-confirm the confirmed chain at the beginning of each epoch together with the reasoning from the Lemma 6 of the Paper should conclude the proof.
    \end{description}
\end{proof}

\begin{lemma}\label{lem:gj-does-not-conflict-during-e}
    Pick any $b_c \in  \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bcands}$, any honest validator $v'$ and time $t' \geq \slotstartslot{t}$ such that $\epoch(t') = \epoch(t)$.
    If
    \begin{enumerate}
        \item $\slotstart(\lastslot(\epoch(t)-1)) \geq \GST$
        \item $\epoch(b_c) \geq \epoch(t)-1$
    \end{enumerate},
    then,
    \begin{enumerate}
        \item No checkpoint $\chkp'$ conflicting with $b_c$ such that $\epoch(\chkp') = \epoch(t)-1$ can ever be justified.
        \item $b_c \succeq \gjattime[val=v',time=t']$
    \end{enumerate}
\end{lemma}

\begin{proof}
    By induction on $t'$.
    \begin{description}
        \item[Base case: {$t' = \slotstartslot{t}$}.] Apply \Cref{lem:gj-does-not-conflict}.
        \item[Inductive case: {$t' \geq \slotstartslot{t}$}.] We assume that the Lemma holds for any $t''$ such that $\slotstartslot{t} \leq t'' < t'$ and we prove that it holds at time $t'$ as well.
        Due to \Cref{lem:no-prev-epochconflict-chkp-is-justified} and the synchrony assumption we know that no checkpoint $\chkp'$ such that $\epoch(\chkp')=\epoch(t)-1$ conflicting with $\chkp(b_c, \epoch(t)-1)$ can ever be justified which proves the first statement.
        Then we proceed by cases.
        \begin{description}
            \item[Case 1: {$\epoch(\gjattime[val=v',time=t']) = \epoch(\gjattime[val=v',time=t''])$}.] Apply the inductive hypothesis.
            \item[Case 2: {$\epoch(\gjattime[val=v',time=t']) \neq \epoch(\gjattime[val=v',time=t''])$}.]
            Then \Cref{lem:gj-at-least-e-2-alt} implies $\epoch(t)-2 = \epoch(\gjattime[val=v',time=t'']) < \epoch(\gjattime[val=v',time=t']) = \epoch(t)-1$.
            The fact that no checkpoint $\chkp'$ conflicting with $b_c$ such that $\epoch(\chkp') = \epoch(t)-1$ can ever be justified and also that $\epoch(b_c) \geq \epoch(t)-1$ implies $\gjattime[val=v',time=t'] \preceq b_c$ in this case.
        \end{description}
    \end{description}
\end{proof}

\begin{lemma}\label{lem:bcand-in-filtered-during-e}
    Pick any $b_c \in  \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bcands}$, any time $t' \geq \slotstartslot{t}$ such that $\epoch(t')=\epoch(t)$ and any honest validator $v'$.
    If
    \begin{enumerate}
        \item $\slotstart(\lastslot(\epoch(t)-1)) \geq \GST$
        \item $\epoch(b_c) \geq \epoch(t)-1$
    \end{enumerate},
    then
    \begin{enumerate}
        \item $b_c \in \filtered[val=v',time=t']$.
    \end{enumerate}
\end{lemma}

\begin{proof}
    From \Cref{lem:gj-does-not-conflict-during-e} we know that $\gjattime[val=v',time=t'] \preceq b_c$.
    From \Cref{lem:vs-at-least-e-2} we know that $\exists b' \in \left(\viewattime[time=\votingtime(\slot(t)-1),val=v'] \cap \viewattime[time=\slotstart(\slot(t)),val=v]\right), b' \succeq b_c \land \epoch(\votsource[blck=b',time=\slotstartslot{t}])\geq \epoch(t)-2$.
    All these together with the synchrony assumption concludes the proof.
\end{proof}

\begin{assumption}\label{assm:bcand-chkp-in-allu}
    (Strenghthened Assumption 5.3 of the Paper).
    Given a block $b$ and epoch $e \geq \epoch(b)$ such that $\slotstart(e+1) \geq \GST$, if for any time $t$ with $\epoch(t) = e+1$ and honest validator $v$,
    \begin{enumerate}
        \item $b$ is canonical in the view of $v$ at time $t$,
        \item for any block $b' \succeq \chkp(b,e)$ in the view of $v$ we have enough support to justify $\chkp(b,e)$,
    \end{enumerate}
    then, by time $\slotstart(e+2)$, the view of validator $v$ includes a block $b' \succeq b$ such that $\epoch(b') < e+2 \land \chkp(b,e) \in \allU(b')$.
\end{assumption}

\begin{lemma}\label{lem:if-firstslot-chkp-bcand-is-in-allu}
    Pick any $b_c \in  \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bcands}$, any time $t'$ such that $t' < \slotstart(\epoch(t)+1)$ and any honest validator $v'$.
    If
    \begin{enumerate}
        \item $\slotstart(\epoch(t)-1) \geq \GST$
        \item $\epoch(b_c) = \epoch(t)-1$
        \item $\slot(t) = \firstslot(\epoch(t))$
    \end{enumerate},
    then
    \begin{enumerate}
        \item $\exists b' \in \viewattime[val=v',time=t']$ such that $b' \succeq b_c \land \chkp(b_c) \in \allU(b')$.
    \end{enumerate}
\end{lemma}

\begin{proof}
    \Cref{lem:bcand-in-filtered-during-e} together with \Cref{lem:canonical-if-in-filtered} implies $b_c \preceq \LMDGHOSTHFC(\viewattime[val=v',time=t''])$ for any $t''$ such that $\epoch(t'') = \epoch(t)$.
    Then \Cref{assm:bcand-chkp-in-allu} and \Cref{lem:no-prev-epochconflict-chkp-is-justified} together with the synchrony concludes the proof.
\end{proof}

\begin{lemma}\label{lem:no-conflicting-chkp-justified-in-e-e+1}
    Pick any $b_c \in  \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bcands}$.
    If
    \begin{enumerate}
        \item $\slotstart(\lastslot(\epoch(t)-1)) \geq \GST$
        \item $\epoch(b_c) \geq \epoch(t)-1$
    \end{enumerate},
    then,
    \begin{enumerate}
        \item No checkpoint $\chkp'$ conflicting with $b_c$ such that $\epoch(\chkp') \in \left\{\epoch(t)-1,\epoch(t)\right\}$ can ever be justified.
    \end{enumerate}
\end{lemma}

\begin{proof}
    By cases.
    \begin{description}
        \item[Case 1: {$\epoch(b_c) = \epoch(t)$}.]
        Due to \Cref{lem:no-curr-epochconflict-chkp-is-justified} and the synchrony assumption, no checkpoint $\chkp'$ such that $\epoch(\chkp') = \epoch(t)$ conflicting with $b_c$ can ever be justified in this case.
        \item[Case 2: {$\epoch(b_c) \neq \epoch(t)$}.] Implies $\epoch(b_c) = \epoch(t)-1$. By sub cases.
        \begin{description}
            \item[Case 2.1: {$\slot(t) = \firstslot(\epoch(t))$}.] Due to \Cref{lem:bcand-in-filtered-during-e} together with \Cref{lem:canonical-if-in-filtered} $b_c \preceq \LMDGHOSTHFC(\viewattime[val=v',time=t''])$ for any time $t''$ such that $\epoch(t'')=\epoch(t)$.
            Which implies that all honest validators in the committees of $\epoch(t)$ send their FFG votes targeting a checkpoint that is a descendant of $b_c$.
            This, the Property 1.6 of the paper and the synchrony assumption imply that no checkpoint $\chkp'$ conflicting with $b_c$ such that $\epoch(\chkp')=\epoch(t)$ can ever be justified in this case.
            \item[Case 2.2: {$\slot(t) \neq \firstslot(\epoch(t))$}.] By contradiction.
            Suppose $\exists b', \chkp(b',\epoch(t)) \in \allU(\viewattime[val=v',time=t'])$ and $b_c \npreceq \chkp(b',\epoch(t))$.
            Then, given the synchrony assumption and the fact that $\epoch(b_c)=\epoch(t)-1$,
            
            $\willNoConflictingChkpBeJustified_v(\chkp(b', \epoch(t)))$ check in \Cref{ln:if-prev-epoch} and \Cref{ln:if-to-set-bcand-to-btcand} must have never be true,
            thus either $\slot(t) = \firstslot(\epoch(t))$ or $\epoch(b_c) \neq \epoch(t)-1$.
        \end{description}
    \end{description}
    All the above together with \Cref{lem:gj-does-not-conflict-during-e} concludes the proof.
\end{proof}

\begin{lemma}\label{lem:gj-does-not-conflict-during-e+1}
    Pick any $b_c \in  \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bcands}$, any honest validator $v'$ and time $t' \geq \slotstartslot{t}$ such that $\epoch(t') \in \left\{\epoch(t),\epoch(t)+1\right\}$.
    If
    \begin{enumerate}
        \item $\slotstart(\lastslot(\epoch(t)-1)) \geq \GST$
        \item $\epoch(b_c) \geq \epoch(t)-1$
    \end{enumerate},
    then,
    \begin{enumerate}
        \item $b_c$ does not conflict with $\gjattime[val=v',time=t']$.
    \end{enumerate}
\end{lemma}

\begin{proof}
    By induction on $t'$.
    \begin{description}
        \item[Base case: {$t' = \slotstartslot{t}$}.] Apply \Cref{lem:gj-does-not-conflict}.
        \item[Inductive case: {$t' \geq \slotstartslot{t}$}.] We assume that the Lemma holds for any $t''$ such that $\slotstartslot{t} \leq t'' < t'$ and we prove that it holds at time $t'$ as well.
        By cases.
        \begin{description}
            \item[Case 1: {$\epoch(\gjattime[val=v',time=t']) = \epoch(\gjattime[val=v',time=t''])$}.] Apply the inductive hypothesis.
            \item[Case 2: {$\epoch(\gjattime[val=v',time=t']) \neq \epoch(\gjattime[val=v',time=t''])$}.]
            Then \Cref{lem:gj-at-least-e-2-alt} and the definition of the greatest justified checkpoint imply $\epoch(t)-2 \leq \epoch(\gjattime[val=v',time=t'']) < \epoch(\gjattime[val=v',time=t']) \leq \epoch(t)$, thus $\epoch(\gjattime[val=v',time=t']) \in \left\{\epoch(t)-1, \epoch(t)\right\}$.
            Then \Cref{lem:no-conflicting-chkp-justified-in-e-e+1} concludes the proof for this case.
        \end{description}
    \end{description}
\end{proof}

\begin{lemma}\label{lem:find-latest-conf-desc-output-in-filtered-during-e+1}
    Let $b_o := \varforvalattime[val=v]{\mathit{find\_latest\_confirmed\_descendant}}(b_c)$.
    Pick any honest validator $v'$ and time $t'$ such that $\epoch(t') = \epoch(t)+1$.
    If
    \begin{enumerate}
        \item $\slotstart(\epoch(t)-1) \geq \GST$
        \item $\epoch(b_c) \geq \epoch(t)-1$
        \item $b_o \neq b_c$
    \end{enumerate},
    then
    \begin{enumerate}
        \item $\exists b' \in \viewattime[val=v',time=t']$ such that $b' \succeq b_o \land \votsource[blck=b',time=\epoch(t')] \geq \epoch(t')-2$.
    \end{enumerate}
\end{lemma}

\begin{proof}
    By cases.
    \begin{description}
        \item[Case 1: {$\slot(t) = \firstslot(\epoch(t))$}.] Implies $\epoch(b_o)=\epoch(t)-1$.
        \Cref{lem:bcand-in-filtered-during-e} together with \Cref{lem:canonical-if-in-filtered} implies $b_o \preceq \LMDGHOSTHFC(\viewattime[val=v',time=t''])$ for any $t''$ such that $\epoch(t'') = \epoch(t)$.
        Then due to \Cref{lem:if-firstslot-chkp-bcand-is-in-allu} we know that $\exists b' \in \viewattime[val=v',time=t']$ such that $b' \succeq b_o \land \votsource[blck=b',time=\epoch(t')] \geq \epoch(t')-2$.
        \item[Case 2: {$\slot(t) \neq \firstslot(\epoch(t))$}.]
        Because of the check in \Cref{ln:if-prev-epoch} and \Cref{ln:second-if} we know that $\exists b' \in \viewattime[val=v,time=\slotstartslot{t}]$ such that $b' \succeq b \land \gu(b') \geq \epoch(t)-1$.
        This, the fact that $\epoch(t)-1 = \epoch(t')-2$ and the synchrony assumption imply $\exists b' \in \viewattime[val=v',time=t']$ such that $b' \succeq b_o \land \votsource[blck=b',time=\epoch(t')] \geq \epoch(t')-2$.
    \end{description}
\end{proof}

\begin{lemma}\label{lem:if-restarted-bcand-in-filtered-during-e-e+1}
    Pick any $b_c \in  \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bcands}$, any time $t'$ such that $\epoch(t') = \epoch(t)+1$ and any honest validator $v'$.
    If
    \begin{enumerate}
        \item $\slotstart(\slot(t)-1) \geq \GST$
        \item $\epoch(\varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}) < \epoch(t)-1$
        \item $\epoch(b_c) \geq \epoch(t)-1$
    \end{enumerate},
    then
    \begin{enumerate}
        \item $b_c \in \filtered[val=v',time=t']$
    \end{enumerate}
\end{lemma}

\begin{proof}
    It must be that all conditions in \Cref{ln:start-conf-chain} are true, otherwise, it is impossible to satisfy the Lemma statement.
    Now by cases on the first line, in order of execution of the Fast Confirmation Rule algorithm at time $\slotstartslot{t}$, where $\bcand = b_c$. 
    \begin{description}
        \item[\Cref{ln:set-bcand-beginning-of-get-latest-confirmed}.] $\epoch(b_c) < \epoch(t)-1$ thus the Lemma is vacuously true.
        \item[\Cref{ln:set-bcand-to-fin}.] $\epoch(b_c) < \epoch(t)-1$ thus the Lemma is vacuously true.
        \item[\Cref{ln:set-bcan-on-start-conf-chain}.] Due to \Cref{lem:gu-e-1-canonical} $b_c \preceq \LMDGHOSTHFC(\viewattime[val=v',time=t'])$ which implies $b_c \in \filtered[val=v',time=t']$.
        \item[\Cref{ln:set-bcand-to-output-find-latest}.]
        Let $b_o := \varforvalattime[val=v]{\mathit{find\_latest\_confirmed\_descendant}}(b_c)$.
        By cases.
        \begin{description}
            \item[Case 1: {$b_o = b_c$}.] It must be that $b_o = \block(\guattime[val=v,time=\slotstart(\slot(t)-1)])$ in this case. Then apply \Cref{lem:gu-e-1-canonical}.
            \item[Case 2: {$b_o \neq b_c$}.] Due to \Cref{lem:find-latest-conf-desc-output-in-filtered-during-e+1} we know that $\exists b' \in \viewattime[val=v',time=t']$ such that $b' \succeq b_o \land \votsource[blck=b',time=\epoch(t')] \geq \epoch(t')-2$, then \Cref{lem:gj-does-not-conflict-during-e+1} concldues the proof for this case.
        \end{description}
    \end{description}
\end{proof}

\begin{lemma}\label{lem:bcand-in-filtered-during-e-e+1}
    Pick any $b_c \in  \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bcands}$, any time $t' \geq \slotstartslot{t}$ such that $\epoch(t') \in \left\{\epoch(t), \epoch(t)+1\right\}$ and any honest validator $v'$.
    If
    \begin{enumerate}
        \item $\slotstart(\epoch(t)-1) \geq \GST$
        \item $\epoch(b_c) \geq \epoch(t)-1$
    \end{enumerate},
    then
    \begin{enumerate}
        \item $b_c \in \filtered[val=v',time=t']$
    \end{enumerate}
\end{lemma}

\begin{proof}
    By induction on $\slot(t)$. Let $s := \slot(t)$.
    \begin{description}
        \item[Base Case: {$s = \slot(\varforvalattime[val=v]{\tinit})$}.] The Lemma is vacuously true.
        \item[Inductive Case: {$s \geq \slot(\varforvalattime[val=v]{\tinit})$}.] We assume that the Lemma holds for slot $s$ and prove that it also holds for slot $s+1$.
        Pick any $b_c \in \varforvalattime[val=v,time=\slotstart(s+1)]{\bcands}$ such that $\epoch(b_c) \geq \epoch(s+1)-1$. By cases.
        \begin{description}
            \item[Case 1: {$\epoch(t') = \epoch(t)$}.] Apply \Cref{lem:bcand-in-filtered-during-e}.
            \item[Case 2: {$\epoch(t') = \epoch(t)+1$}.]
            By sub cases.
            \begin{description}
                \item[Case 2.1: {$\epoch(\varforvalattime[val=v,time=\slot(s)]{\bconfirmed}) < \epoch(s+1)-1$}.] Apply \Cref{lem:if-restarted-bcand-in-filtered-during-e-e+1}.
                \item[Case 2.2: {$\epoch(\varforvalattime[val=v,time=\slot(s)]{\bconfirmed}) \geq \epoch(s+1)-1$}.]
                Now by cases on the first line, in order of execution of the Fast Confirmation Rule algorithm at time $\slotstart(s+1)$, where $\bcand = b_c$. 
                \begin{description}
                    \item[\Cref{ln:set-bcand-beginning-of-get-latest-confirmed}.] Given that $b_c = \varforvalattime[val=v,time=\slot(s)]{\bconfirmed} \in \varforvalattime[val=v,time=\slotstart(s)]{\bcands}$ in this case, the inductive hypothesis concludes the proof.
                    \item[\Cref{ln:set-bcand-to-fin}.] Impossible, as at this line $\epoch(\varforvalattime[val=v,time=\slot(s)]{\bconfirmed}) < \epoch(s+1)-1$, but we assume $\epoch(\varforvalattime[val=v,time=\slot(s)]{\bconfirmed}) \geq \epoch(s+1)-1$.
                    \item[\Cref{ln:set-bcan-on-start-conf-chain}.] Impossible, as at this line $\epoch(\varforvalattime[val=v,time=\slot(s)]{\bconfirmed}) < \epoch(s+1)-1$, but we assume $\epoch(\varforvalattime[val=v,time=\slot(s)]{\bconfirmed}) \geq \epoch(s+1)-1$.
                    \item[\Cref{ln:set-bcand-to-output-find-latest}.]
                    Let $b_o := \varforvalattime[val=v]{\mathit{find\_latest\_confirmed\_descendant}}(b_c)$.
                    By sub cases again.
                    \begin{description}
                        \item[Case 2.2.1: {$b_o = b_c$}.] It must be that $b_o = \varforvalattime[val=v,time=\slot(s)]{\bconfirmed}$ in this case. Then apply the inductive hypothesis.
                        \item[Case 2.2.2: {$b_o \neq b_c$}.] Due to \Cref{lem:find-latest-conf-desc-output-in-filtered-during-e+1} we know that $\exists b' \in \viewattime[val=v',time=t']$ such that $b' \succeq b_o \land \votsource[blck=b',time=\epoch(t')] \geq \epoch(t')-2$, then \Cref{lem:gj-does-not-conflict-during-e+1} concldues the proof for this case.
                    \end{description}
                \end{description}
            \end{description}
        \end{description}
    \end{description}
\end{proof}

\begin{lemma}\label{lem:chkp-bcand-is-in-allu}
    Pick any $b_c \in  \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bcands}$, any time $t'$ such that $t' < \slotstart(\epoch(t)+2)$ and any honest validator $v'$.
    If
    \begin{enumerate}
        \item $\slotstart(\epoch(t)-1) \geq \GST$
        \item $\epoch(b_c) \geq \epoch(t)-1$
    \end{enumerate},
    then
    \begin{enumerate}
        \item $\exists b' \in \viewattime[val=v',time=t']$ such that $b' \succeq b_c \land \chkp(b_c) \in \allU(b')$.
    \end{enumerate}
\end{lemma}

\begin{proof}
    By cases.
    \begin{description}
        \item[Case 1: {$\slot(t)=\firstslot(\epoch(t))$}.] Implies $\epoch(b_c) = \epoch(t)-1$. Apply \Cref{lem:if-firstslot-chkp-bcand-is-in-allu}.
        \item[Case 2: {$\slot(t) \neq \firstslot(\epoch(t))$}.] \Cref{lem:bcand-in-filtered-during-e-e+1} together with \Cref{lem:canonical-if-in-filtered} implies $b_c \preceq \LMDGHOSTHFC(\viewattime[val=v',time=t''])$ for any $t''$ such that $\epoch(t'') = \epoch(t)+1$. By sub cases.
        \begin{description}
            \item[Case 2.1: {$\epoch(b_c) = \epoch(t)-1$}.] Then \Cref{assm:bcand-chkp-in-allu} and \Cref{lem:no-prev-epochconflict-chkp-is-justified} together with the synchrony assumption concludes the proof.
            \item[Case 2.2: {$\epoch(b_c) \neq \epoch(t)-1$}.] Implies $\epoch(b_c)=\epoch(t)$. Then \Cref{assm:bcand-chkp-in-allu} and \Cref{lem:no-curr-epochconflict-chkp-is-justified} together with the synchrony assumption concludes the proof.
        \end{description}
    \end{description}
\end{proof}

\begin{lemma}\label{lem:bcand-canonical}
    Pick any $b_c \in  \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bcands}$, any time $t' \geq \slotstartslot{t}$ and any honest validator $v'$.
    If
    \begin{enumerate}
        \item $\slotstart(\epoch(t)-1) \geq \GST$
        \item $\epoch(b_c) \geq \epoch(t)-1$
    \end{enumerate},
    then,
    \begin{enumerate}
        \item $b_c \preceq \LMDGHOSTHFC(\viewattime[val=v',time=t'])$.
    \end{enumerate}
\end{lemma}

\begin{proof}
    By induction on $t' \geq \slotstartslot{t}$.
    \begin{description}
        \item[Base case: {$\epoch(t') \in \left[\epoch(t),\epoch(t)+1\right]$}.]
        \Cref{lem:bcand-in-filtered-during-e-e+1} and \Cref{lem:canonical-if-in-filtered} conclude the proof for this case.
        \item[Inductive case: {$\epoch(t') > \epoch(t)+1$}.] We assume that the Lemma holds for any $t'' \geq t$ such that $\epoch(t'') < \epoch(t')$ and prove that it also holds for $t'$.
        From \Cref{lem:chkp-bcand-is-in-allu} we know that for at the time $t''' < \slotstart(\epoch(t)+1)$ $\exists b' \in \viewattime[val=v',time=t''']$ such that $b' \succeq b_c \land \chkp(b_c) \in \allU(b')$.
        This and the definition of the greatest justified checkpoint imply $\epoch(\gjattime[val=v',time=t']) \geq \epoch(\chkp(b_c))$. By cases.
        \begin{description}
            \item[Case 1: {$\epoch(\gjattime[val=v',time=t']) = \epoch(\chkp(b_c))$}.] Clearly, $\gjattime[val=v',time=t'] = \chkp(b_c)$ in this case. Also this and the definition of the greatest justified checkpoint implies $\gjblock(b') = \chkp(b_c)$ thus $b_c \in \filtered[val=v',time=t']$.
            \item[Case 2: {$\epoch(\gjattime[val=v',time=t']) \neq \epoch(\chkp(b_c))$}.]
            By the definition of the greatest justified checkpoint, $\epoch(\gjattime[val=v',time=t']) \leq \epoch(t')-1$ which implies $\epoch(\chkp(b_c)) < \epoch(\gjattime[val=v',time=t']) \leq \epoch(t'')$ for this case.
            From the inductive hypothesis we know that $b_c \preceq \LMDGHOSTHFC(\viewattime[val=v',time=t''])$ which implies that during each epoch $e \in \left[\epoch(t), \epoch(t'')\right]$ all honest validators cast their FFG votes in the support of $\chkp(b'',e)$ such that $b'' \succeq b$.
            Thus, given the synchrony assumption no checkpoint $\chkp'$ conflicting with $b_c$ such that $\epoch(\chkp') \in \left[\epoch(t), \epoch(t'')\right]$ can ever be justified.
            Given that, we conclude $b_c \prec \gjattime[val=v',time=t']$ which implies $b_c \in \filtered[val=v',time=t']$.
        \end{description}
        We have show that $b_c \in \filtered[val=v',time=t']$, then \Cref{lem:canonical-if-in-filtered} concludes the proof.
    \end{description}
\end{proof}

\begin{lemma}
    Take $b = \varforvalattime[val=v,time=\slotstartslot{t}]{\bconfirmed}$.
    If
    \begin{enumerate}
        \item $\slotstart(\epoch(t)-1) \geq \GST$
        \item $\epoch(b) \geq \epoch(t)-1$
    \end{enumerate},
    then,
    \begin{enumerate}
        \item $\canonical[blck=b,time=t]$
    \end{enumerate}
\end{lemma}

\begin{proof}
    Follows from \Cref{lem:bcand-canonical} and the fact that $\varforvalattime[val=v,time=\slotstart(\slot(t))]{\bconfirmed} \in \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bcands}$.
\end{proof}

\MK{Done till here. The rest of the lemmas must be revisited as might not be needed.}

\begin{lemma}\label{lem:bcand-prev-epoch-no-conflict-with-gj}
    Pick any $b_c \in  \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bcands}$.
    If
    \begin{enumerate}
        \item $\slotstart(\firstslot(\epoch(t)-1)) \geq \GST$
        \item $\epoch(b_c) = \epoch(t)-1$
    \end{enumerate},
    then for any honest validator $v'$ and time $t' \geq \slotstartslot{t}$ such that $\epoch(t') \in \left\{\epoch(t), \epoch(t)+1\right\}$,
    \begin{enumerate}
        \item $b_c$ does not conflict with $\gjattime[val=v',time=t']$
    \end{enumerate}
\end{lemma}

\begin{proof}
    By induction on $t'$.
    \begin{description}
        \item[Base case: {$t' = \slotstartslot{t}$}.]
        Due to \Cref{lem:gj-does-not-conflict} for any $b_c \in \varforvalattime[val=v,time=\slotstart(\slot(t))]{\bcands}$, $\epoch(b_c) = \epoch(t)-1$, $b_c \succeq \gjattime[val=v',time=\slotstartslot{t}]$ which concludes the proof for the base case.
        \item[Inductive case: {$t' \geq \slotstartslot{t}$}.] We assume that the Lemma holds for any time $t''$ such that $t \leq t'' < t'$ and prove that it holds at time $t'$ as well.
        By cases.
        \begin{description}
            \item[Case 1: {$\epoch(\gjattime[val=v',time=t']) = \epoch(\gjattime[val=v',time=t''])$}.]
            It implies $\gjattime[val=v',time=t'] = \gjattime[val=v',time=t'']$ and then the inductive hypothesis concludes the proof for this case.
            \item[Case 2: {$\epoch(\gjattime[val=v',time=t']) \neq \epoch(\gjattime[val=v',time=t''])$}.]
            \Cref{lem:gj-at-least-e-2-alt} implies $\epoch(t)-2 \leq \epoch(\gjattime[val=v',time=t'']) < \epoch(\gjattime[val=v',time=t']) \leq \epoch(t)$.
            By sub cases.
            \begin{description}
                \item[Case 2.1: {$\epoch(\gjattime[val=v',time=t']) = \epoch(t)-1$}.]
                Apply \Cref{lem:bcand-prev-epoch-descendant-of-gj-eq-e-1}.
                \item[Case 2.2: {$\epoch(\gjattime[val=v',time=t']) \neq \epoch(t)-1$}.]
                Given that $\epoch(\gjattime[val=v',time=t']) \neq \epoch(\gjattime[val=v',time=t''])$ and $\epoch(t)-2 \leq \epoch(\gjattime[val=v',time=t'']) \leq \epoch(\gjattime[val=v',time=t']) \leq \epoch(t)$,
                it must be that $\epoch(\gjattime[val=v',time=t']) = \epoch(t)$, it implies $\exists b' \in \viewattime[val=v',time=t'], \chkp(b', \epoch(t)) \in \allU(\viewattime[val=v',time=t'])$. Then apply \Cref{lem:bcand-prev-epoch-descendant-of-gj-eq-e}.
            \end{description}
        \end{description}
    \end{description}
\end{proof}

\begin{lemma}\label{lem:gj-at-least-e-2}
    If
    \begin{enumerate}
        \item $\text{\slotstart}(\text{\lastslot}(\text{\epoch}(t) - 1)) \geq \GST$
        \item $\slot(t) > \text{\firstslot}(\epoch(t))$
        \item $\epoch(\varforvalattime[val=v,time=\slotstartslot{t}]{\bcand}) \geq \epoch(t)-1$
    \end{enumerate},
    then, for any honest validator $v'$,
    \begin{enumerate}
        \item $\epoch(\gjattime[val=v',time=\slotstart(\slot(t)-1)]) \geq \epoch(t)-2$
    \end{enumerate}
\end{lemma}

\begin{proof}
Given Condition 2 and 3 of the Lemma's statement we apply \Cref{lem:prev-conf-at-least-e-1} to conclude
$\epoch(\varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}) \geq \epoch(t)-1$.
Thus $\epoch(\varforvalattime[val=v,time=\slotstart(\slot(t)-1)]{\bcand}) \geq \epoch(t)-1$.
With Condition 2 of the Lemma's statement we can also conclde that $\slotstart(\slot(t)-2) \geq \GST$.
Then, by following the same reasoning that is used to proof \Cref{lem:gj-at-least-e-2-alt}
but for $\slot(t)-1$ instead of $\slot(t)$ we conclude the proof.
\end{proof}

\begin{lemma}
    % Let $GU^{v,t-1} := GU(V^{v,\slotstart(\slot(t)-1)},\slotstart(\slot(t)-1))$.
    If
    \begin{enumerate}
        \item $\text{\slotstart}(\text{\lastslot}(\text{\epoch}(t) - 1)) \geq \GST$
        \item $t = \slotstart(\epoch(t))$
        \item $\epoch(\guattime[val=v,time=\slotstart(\slot(t)-1)]) = \epoch(t)-1$
    \end{enumerate},
    then for any honest validator $v'$ and time $t'$ such that $\epoch(t') \in \{\epoch(t),\epoch(t)+1\}$,
    \begin{enumerate}
        \item $\block(\guattime[val=v,time=\slotstart(\slot(t)-1)]) \in \filtered[time=t',val=v']$
    \end{enumerate}
\end{lemma}

\begin{proof}
    Consider time $t'', \epoch(t'') = \epoch(t)$.
    $\gjattime[val=v',time=t''] = \guattime[val=v,time=\slotstart(\slot(t)-1)]$
    follows from Conditions 1 and 3 of the Lemma's statement together with Definitions 1-3 of the paper.
    Clearly, $\block(\guattime[val=v,time=\slotstart(\slot(t)-1)]) \in \filtered[time=t'',val=v']$
    and $\canonical[blck={\block(\guattime[val=v,time=\slotstart(\slot(t)-1)])},time=t'']$.
    Due to Condition 2 of the Lemma's statement all honest validators in the committee of $\epoch(t)$
    will vote in the support of $\block(\guattime[val=v,time=\slotstart(\slot(t)-1)])$.
    Then, by the Property 1.6 from the paper, no checkpoint $\chkp$ conflicting with $\block(\guattime[val=v,time=\slotstart(\slot(t)-1)])$
    such that $\epoch(C) = \epoch(t)$ can ever be justified.
    Thus, either $\gjattime[val=v',time=t'''] = \guattime[val=v,time=\slotstart(\slot(t)-1)]$
    or $\gjattime[val=v',time=t'''] = \chkp(b', \epoch(t)), b' \succeq \block(\guattime[val=v,time=\slotstart(\slot(t)-1)])$,
    $\epoch(t''') = \epoch(t) + 1$. In either case $\block(\guattime[val=v,time=\slotstart(\slot(t)-1)]) \in \filtered[time=t''',val=v']$.
\end{proof}

\begin{lemma}
    Take an honest validator $v$ and a block $b$.
    If
    \begin{enumerate}
        \item $t = \slotstart(\epoch(t))$
        \item $\epoch(b) = \epoch(t)-1$
        \item $\varforvalattime[val=v,time=t]{\isOneConfirmed}(b, \gjattime[val=v,time=t])$
        \item $\epoch(\gu(b)) \geq \epoch(t)-2$
    \end{enumerate},
    then for any honest validator $v'$ and time $t'$ such that $\epoch(t') = \epoch(t)$,
    \begin{enumerate}
        \item $b \in \filtered[time=t',val=v']$
    \end{enumerate}
\end{lemma}

\begin{proof} (by Mikhail)
    From \Cref{lem:no-conflict-chkp-is-justified} we know that no checkpoint conflicting with
    $\chkp(\varforvalattime[val=v,time=\slotstartslot{t}]{\bcand})$ can be justified.
    Given this, Condition 4 of the Lemma's statement together with the synchrony assumption
    we know that $\varforvalattime[val=v,time=\slotstartslot{t}]{\bcand} \succeq \block(\gjattime[val=v',time=\slotstartslot{t}])$
    and $\votsource[blck={\varforvalattime[val=v,time=\slotstartslot{t}]{\bcand}},time=t] \geq \epoch(t)-2$.
    Thus, $\varforvalattime[val=v,time=\slotstartslot{t}]{\bcand} \in \filtered[time=t',val=v']$ for $\epoch(t')=\epoch(t)$.
    Given the fact that $\varforvalattime[val=v,time=\slotstartslot{t}]{\bcand}$ remains canonical during the whole $\epoch(t)$
    and Property 1.6 from the paper we know that no $\epoch(t)$ checkpoint conflicting with
    $\varforvalattime[val=v,time=\slotstartslot{t}]{\bcand}$ can be justified.
    Which concludes the proof for $\epoch(t') = \epoch(t)+1$.
\end{proof}

\begin{lemma}
    Take an honest validator $v$ and a block $b$.
    If
    \begin{enumerate}
        \item $t = \slotstart(\epoch(t))$
        \item $\epoch(b) = \epoch(t)-1$
        \item $\varforvalattime[val=v,time=t]{\isOneConfirmed}(b, \gjattime[val=v,time=t])$
        \item $b \preceq \LMDGHOST(\viewattime[val=v',time=t''])$ for any $t''$ such that $\epoch(t'') = \epoch(t)$
        \item $\epoch(\gu(b)) \geq \epoch(t)-2$
    \end{enumerate},
    then for any honest validator $v'$ and time $t'$ such that $\epoch(t') = \epoch(t)+1$,
    \begin{enumerate}
        \item $b \in \filtered[time=t',val=v']$
    \end{enumerate}
\end{lemma}

\begin{lemma}
    Take an honest validator $v$ and a block $b$.
    If
    \begin{enumerate}
        \item $t = \slotstartslot{t}$
        \item $\epoch(b) = \epoch(t)-1$
        \item $\exists b' \in \viewattime[val=v,time=\slotstart(\slot(t)-1)], b' \succeq b \land \epoch(\votsource[blck=b',time=t]) \geq \epoch(t)-2$
        \item $\exists b', b' \succeq b \land \epoch(\gu(b')) \geq \epoch(t)-1$
        \item $\exists C, C \succeq b \land \epoch(C) = \epoch(t) \land \text{will\_no\_conflicting\_checkpoint\_be\_justified}(C)$
    \end{enumerate},
    then for any honest validator $v'$ and time $t' \geq t$ such that $\epoch(t') \in \{\epoch(t),\epoch(t)+1\}$,
    \begin{enumerate}
        \item $b \in \filtered[time=t',val=v']$
    \end{enumerate}
\end{lemma}

\begin{lemma}
    If
    \begin{enumerate}
        \item $\varforvalattime[val=v,time=\slotstart(\slot(t))]{\isOneConfirmed}(b, \gjattime[val=v,time=\slotstart(\slot(t))])$
        \item $\epoch(b) = \epoch(t)$
    \end{enumerate},
    then, for any honest validator $v'$ and time $t' \geq t$ such that $\epoch(t') = \epoch(t)$
    \begin{enumerate}
        \item $b \in \filtered[time=t',val=v']$
    \end{enumerate}
\end{lemma}

\begin{proof}(Sketch)
    At least one honest validator $v'$ voted for $b$ in the previous \slot.
    This also implies that $\slot(t) > first_slot(\epoch(t))$. 
    Given, \Cref{lem:gj-at-least-e-2} and that $\epoch(\slot(t)-1) = \epoch(t)$,  it must be that $v'$'s view includes a block $b' \succeq b$ such that $\epoch(\votsource[blck=b',time=\slotstart(\slot(t)-1)]) \geq \epoch(t)-2$.
    By $\slotstart(\slot(t))$, $b'$ is in the view of any honest validator.
    Hence, $b'$ is not filtered out by any honest validator at time $\slotstart(\slot(t))$ or after during epoch $\epoch(t)$.
\end{proof}

\begin{lemma}
    % Let $GU^{v,t-1} := GU(V^{v,\slotstart(\slot(t)-1)},\slotstart(\slot(t)-1))$.
    If
    \begin{enumerate}
        \item $t = \slotstart(\epoch(t))$
        \item $\epoch(\guattime[val=v,time=\slotstart(\slot(t)-1)]) = \epoch(t)-1$
    \end{enumerate},
    then, $\canonical[time=t,blck={\block(\guattime[val=v,time=\slotstart(\slot(t)-1)])}]$
\end{lemma}

\begin{lemma}
    If
    \begin{enumerate}
        \item $t = \slotstart(\epoch(t))$
        \item $\epoch(b) = \epoch(t)-1$
        \item $\epoch(\gu(b)) \geq \epoch(t)-2$
        \item $\canonical[time=t,blck=b_c]$
        \item $\forall b': b_c \prec b' \preceq b \implies \varforvalattime[val=v,time=t]{\isOneConfirmed}(b', \gjattime[val=v,time=\slotstart(\slot(t)-1)])$
    \end{enumerate},
    then $\canonical[time=t,blck=b]$
\end{lemma}

\begin{lemma}
    Take an honest validator $v$ and a block $b$.
    If
    \begin{enumerate}
        \item $t = \slotstartslot{t}$
        \item $\epoch(b) = \epoch(t)-1$
        \item $\exists b' \in \viewattime[val=v,time=\slotstart(\slot(t)-1)], b' \succeq b \land \epoch(\votsource[blck=b',time=t]) \geq \epoch(t)-2$
        \item $\exists b', b' \succeq b \land \epoch(\gu(b')) \geq \epoch(t)-1$
        \item $\exists C, C \succeq b \land \epoch(C) = \epoch(t) \land \text{will\_no\_conflicting\_checkpoint\_be\_justified}(C)$
        \item $\canonical[time=t,blck=b_c]$
        \item $\forall b': b_c \prec b' \preceq b \implies \varforvalattime[val=v,time=t]{\isOneConfirmed}(b', \gjattime[val=v,time=\slotstart(\slot(t)-1)])$        
    \end{enumerate},
    then $\canonical[time=t,blck=b]$
\end{lemma}

\begin{lemma}
    If
    \begin{enumerate}
        \item $\epoch(b) = \epoch(t)$
        \item $\canonical[time=t,blck=b_c]$
        \item $\forall b': b_c \prec b' \preceq b \implies \varforvalattime[val=v,time=t]{\isOneConfirmed}(b', \gjattime[val=v,time=\slotstart(\slot(t)-1)])$  
    \end{enumerate},
    then, $\canonical[time=t,blck=b]$.
\end{lemma}

\begin{lemma}
    $\canonical[time=t,blck={\varforvalattime[val=v,time=\slotstartslot{t}]{\bcand}}]$
\end{lemma}




\end{document}