\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=2.5cm]{geometry}
% \pagestyle{plain}
\include{preamble.tex}
\usepackage{amsmath, amssymb, amsthm}

\begin{document}

\section*{Confirmation Rule: Safety}

See:
% \begin{itemize}
%     \item \href{https://github.com/mkalinin/confirmation-rule}{https://github.com/mkalinin/confirmation-rule}
%     \item \href{https://arxiv.org/abs/2405.00549}{https://arxiv.org/abs/2405.00549}
% \end{itemize}

\begin{definition}[LMD-GHOST Safety condition for a single block]
    Given $C \in AU(b):$
    \[
    \isOneConfirmed_v(b, C, t) := Q^{\slot(t)-1,\ v,\ t,\ C}_{b} > \frac{1}{2}\left(1 + \frac{W^C_p}{W^{\slot(t)-1,\ C}_b}\right)
    \]
\end{definition}

Let $\viewattime[val=v,time=\slotstart(s)]$ be the view of a validator $v$ at the start of slot $s$ to which all the votes cast and observed by $v$ before $\slotstart(s)$ are applied.

\begin{algorithm}[H]
\caption{Highest LMD-GHOST confirmed descendant}
\SetAlgoNoLine
\Fn{\isOneConfirmed$_v(b, s)$}{
    \Return{$\isOneConfirmed_v(b, GJ(\viewattime[val=v, time=\slotstart(s-1)]), \slotstart(s))$}\;
}

\Fn{\highestLMDConfirmedDesc$_v(\bconfirmed, s)$}{
    $descs \gets \left\{b' \in \chain(\LMDGHOSTHFC(\viewattime[time=\slotstart(s),val=v])): b' \succ \bconfirmed\right\}$\\
    $confirmed\_descs \gets \left\{b' \in descs : \forall b'' \in descs, b'' \preceq b' \Rightarrow \isOneConfirmed_v(b'', s)\right\}$\\
    \uIf{$confirmed\_descs \ne \emptyset$}{
        \Return{$\argmax_{b' \in confirmed\_descs}\slot(b')$}\;
    }
    \uElse{
        \Return{$\bconfirmed$}\;
    }    
}
\end{algorithm}


\begin{lemma}
If $t$ and $t'$ are any two times, $b := \highestLMDConfirmedDesc_v(\banchor, t)$, $t \leq t'$ and the following holds:
\begin{enumerate}
    \item $\slotstart(\slot(t) - 1) \geq \GST,$
    \item $\banchor$ is canonical in the view of any honest validator $v'$ at time $t,$
    \item $\gjattime[time=t',val=v] \succeq \gjattime[time=\slotstart(\slot(t) - 1),val=v],$
    \item $b \in \filtered[time=t',val=v']$
\end{enumerate}

then $b$ is canonical in the view of any honest validator $v'$ at time $t'$.
\end{lemma}

\begin{proof}
    TBD..
\end{proof}

Let $\viewattime[val=v,time=\slotstart(s)]$ be the view of a validator $v$ at the start of slot $s$ to which all the votes cast and observed by $v$ before $\slotstart(s)$ are applied.

\begin{algorithm}[H]
\caption{Highest confirmed descendant}
% \SetAlgoLined
\SetAlgoNoLine
\Fn{willNotBeFilteredOut$_v(b, s)$}{
    $\head \gets \LMDGHOSTHFC(\viewattime[val=v,time=\slotstart(s)])$\;
    $\phead \gets \LMDGHOSTHFC(\viewattime[val=v,time=\slotstart(s-1)])$\;

    \uIf{epoch(s) = epoch(b)}{
        \Return{$b \preceq \head \wedge \epoch(\gu(head)) \geq \epoch(s)-1$}\;
    }
    \uElseIf{$s = \firstslot(\epoch(s))$}{
        \Return{$\votsource[blck=b, time=\epoch(s)] \geq \epoch(s)-2 \lor
                (b \preceq \phead \wedge \votsource[blck=\phead, time=\epoch(s)] \geq \epoch(s)-2)$}\;
    }
    \uElse {
        \uIf{$b \preceq \head \wedge \epoch(\gu(\head)) \geq \epoch(s) - 1$} {
            \Return{$\votsource[blck=b, time=\epoch(s)] \geq \epoch(s)-2 \lor
                (b \preceq \phead \wedge \votsource[blck=\phead, time=\epoch(s)] \geq \epoch(s)-2)$}\;
        }
        \uElse{
            \Return{$b \preceq \phead \wedge 
                    \epoch(\gu(\phead)) \geq \epoch(s) - 1 \wedge
                    \votsource[blck=\phead, time=\epoch(s)] \geq \epoch(s)-2$}\;
        }
    }
}
\Fn{highestConfirmedDesc$_v(\bconfirmed, s)$}{
    $\blmdconfirmed \gets \highestLMDConfirmedDesc_v(\bconfirmed, s)$\;

    \uIf{$\epoch(\blmdconfirmed) > \epoch(\bconfirmed)$ \textbf{and}
        $\neg \willChkpBeJustified_v(\chkp(\head), s)$} {
        $\mathit{candidates} \gets \{b' \in \chain(\blmdconfirmed), b' \succ \bconfirmed :
            \willNotBeFilteredOut_v(b', s) \wedge \epoch(b') = \epoch(s)-1\}$
    }
    \uElse {
        $\mathit{candidates} \gets \{b' \in \chain(\blmdconfirmed), b' \succ \bconfirmed :
            \willNotBeFilteredOut_v(b', s)\}$
    }

    \uIf{$\mathit{candidates} = \emptyset$}{
        \Return{$\bconfirmed$}\;
    }

    $\bcand \gets \argmax_{b' \in candidates}\slot(b')$\;
    \uIf{$\epoch(s) > \epoch(\bcand)$ \textbf{and}
        $s > \firstslot(epoch(s))$ \textbf{and}
        $\neg \willNoConflictingChkpBeJustified_v(\chkp(\head, \epoch(s), s))$} {
        \Return{$\bconfirmed$}\;
    }
    \uElse {
        \Return{$\bcand$}\;
    }
}
\end{algorithm}

\begin{lemma}
If $t$ and $t'$ are any two times such that $t' \geq t \wedge \epoch(t') = \epoch(t)$, $b := \text{highestConfirmedDesc}_v(\banchor, t)$, $\epoch(b) = \epoch(t) - 1$ and the following holds:

\begin{enumerate}
    \item $\slotstart(\epoch(t) - 1) \geq \GST,$
    \item $\banchor, \epoch(\banchor) = \epoch(t) - 1$ is canonical in the view of any validator $v'$ at time $\slotstart(\slot(t) - 1),$
    \item At the time $t'' \leq \slotstart(\lastslot(\epoch(t) - 1))$ in the view of validator $v$ exists block $b' \preceq b : \epoch(b') = \epoch(t) - 1$ such that $\willChkpBeJustified^{t''}_v(\chkp(b')) = \True,$
    \item At the time $\slotstart(\slot(t) - 1)$ $\exists b'' \succeq \banchor : \epoch(b'') = \epoch(t) - 1 \wedge \epoch(\gu(b'')) \geq \epoch(t) - 2,$
    \item $\gjattime[time=\slotstart(\lastslot(\epoch(t) - 1)),val=v] = \chkp(b, *)$
\end{enumerate}

then $b$ is canonical in the view of any honest validator $v'$ at time $t' < \slotstart(\epoch(b) + 2)$.
\end{lemma}

\begin{proof}
    TBD...
\end{proof}



\begin{lemma}
   If $t$ and $t'$ are any two times such that $t' \geq t$, $b := \text{highestConfirmedDesc}_v(\banchor, t)$, $\epoch(b) = \epoch(t)$ and the following holds:
    
    \begin{enumerate}
        \item $\slotstart(\epoch(t') - 1) \geq \GST,$
        \item $\banchor$ is canonical in the view of any validator $v'$ at time $t,$
        \item At the time $t'' \leq \slotstart(\lastslot(\epoch(t)))$ in the view of validator $v$ exists block $b' \preceq b : \epoch(b') = \epoch(t)$ such that:
        \begin{enumerate}
            \item $willChkpBeJustified^{t''}_v(\chkp(b')),$
            \item $\exists b'' \succeq b' : \epoch(b'') = \epoch(t) \wedge \epoch(\gu(b'')) \geq \epoch(t) - 1,$
        \end{enumerate}
        \item $\guattime[time=\slotstart(\lastslot(\epoch(t) - 1)),val=v] \succeq \chkp(b, \epoch(t) - 2),$
        \item $\gjattime[time=\slotstart(\lastslot(\epoch(t) - 1)),val=v] = \chkp(b, *),$
    \end{enumerate}
    
    then $b$ is canonical in the view of any honest validator $v'$ at time $t' < \slotstart(\epoch(b) + 2)$.
\end{lemma}

\begin{proof}
    TBD...
\end{proof}

% \section*{Algorithm 102}
% \textbf{(Highest confirmed)}

Let $\viewattime[val=v,time=\slotstart(s)]$ be the view of a validator $v$ at the start of slot $s$ to which all the votes cast and observed by $v$ before $\slotstart(s)$ are applied.

\begin{algorithm}[H]
\SetAlgoNoLine
\Fn{$\text{highestConfirmed}_v(s)$}{
    $\var[val=v]{\bconfirmed} \gets \text{highestConfirmed}_v(s-1)$\\
    \uIf{
        $\epoch(\var[val=v]{\bconfirmed}) \geq \epoch(s) - 1$ \textbf{and}\\
        $\var[val=v]{\bconfirmed} \preceq \LMDGHOSTHFC(\viewattime[val=v,time=\slotstart(s)])$}{
        \Return{$\text{highestConfirmedDesc}_v(\var[val=v]{\bconfirmed}, s)$}\;
    }
    \uElseIf{
        $s = \firstslot(\epoch(s))$ \textbf{and} \\
        $\epoch(\gu(\viewattime[val=v,time=\slotstart(s-1)])) = \epoch(s) - 1$
    }{
        \Return{$\text{highestConfirmedDesc}_v(\text{block}(\gu(\viewattime[val=v,time=\slotstart(s-1)]), s)$}\;
    }
    \uElse{
        \Return{$b_{\text{fin}}$}\;
    }
}
\caption{Highest Confirmed Block Selection}
\label{alg:highestconfirmed}
\end{algorithm}

\begin{lemma}
    If $t$ and $t'$ are any two times such that $t' \geq t$, $b := \text{highestConfirmed}(\viewatstslottime[val=v,time=t])$ and the following holds:
    
    \begin{enumerate}
        \item $\slotstart(\epoch(t) - 1) \geq \GST,$
    \end{enumerate}
    
    then $b$ is canonical in the view of any honest validator $v'$ at time $t'$.
\end{lemma}

\begin{proof}
    TBD...
\end{proof}


\begin{lemma}
    If $t$ and $t'$ are any two times such that $t' \geq t$ and the following holds:
    
    \begin{enumerate}
        \item $\slotstart(\epoch(t')) \geq \GST,$
        \item $\epoch(\guattime[time=t,val=v]) = \epoch(t),$
        \item $\epoch(\gjattime[time=\slotstart(\slot(t)-1),val=v]) = \epoch(t) - 1,$
        \item $\guattime[time=t,val=v] \succeq \gjattime[time=\slotstart(\slot(t)-1),val=v],$
    \end{enumerate}
    
then $\guattime[time=t,val=v]$ is canonical in the view of any honest validator $v'$ at any time $t'$.
\end{lemma}

\begin{proof}
    TBD...

    \begin{description}
        \item[Case 1: $\epoch(t') = \epoch(t)$.]
        \item[Case 2: $\epoch(t') > \epoch(t)$.]  
    \end{description}
\end{proof}

\subsection*{Roberto's suggested Lemmas}

\SetKw{KwStateK}{State}
\SetKwBlock{KwState}{State:}{}
\SetKwFor{While}{while}{}{}%
\SetKw{Break}{break}
\SetKw{Const}{const}

\begin{algorithm}[H]
\caption{Find latest confirmed descendant}
\label{alg:findlatestconf}
\SetAlgoNoLine
\Fn{$\var[val=v]{\mathit{next\_child}}(b,head)$}{
    $extension = \{ b' \in \viewattime[time={\var[val=v]{t}},val=v], b \prec b' \preceq head \}$\\
    \uIf{$|extension| > 0$}
    {
        \Return{$\argmin_{b' \in extension} \slot(b')$}
    }
    \uElse{
        \Return{$\bot$}
    }
}

\Fn{$\var[val=v]{\findlatestconfirmeddescendant}(b_c)$}
{
    $\bcand \gets b_c$\label{ln:bcand-set-beginning-of-find-latest}\\
    \Const $head \gets \LMDGHOSTHFC(\viewattime[time={\var[val=v]{t}},val=v])$\\
    \Const $phead \gets \LMDGHOSTHFC(\viewattime[time={\slotstart(\slot(\var[val=v]{t})-1)},val=v])$\\
    \uIf{$\slot(\var[val=v]{t}) = \firstslot(\epoch(\var[val=v]{t}))$} {
        $\chkp_{EBA} \gets \guattime[val=v,time={\slotstart(\slot(\var[val=v]{t})-1)}]$
    }
    \uElse {
        $\chkp_{EBA} \gets \gjattime[val=v,time={\slotstart(\slot(\var[val=v]{t})-1)}]$
    }
    


    \uIf{$\epoch(\bcand) = \epoch(\var[val=v]{t}) - 1$ {\bf and}
        $\votsource[blck=phead, time={\var[val=v]{t}}] \geq \epoch(\var[val=v]{t}) - 2$ {\bf and}
        $(\slot(\var[val=v]{t}) = \firstslot(\epoch(\var[val=v]{t}))$ {\bf or}
        $(\var[val=v]{\willNoConflictingChkpBeJustified}(\chkp(head, \epoch(\var[val=v]{t})))$ {\bf and}
        $(\gu(phead) \geq \epoch(\var[val=v]{t}) - 1$ {\bf or}
        $\gu(head) \geq \epoch(\var[val=v]{t}) - 1)))$\label{ln:if-prev-epoch}}
    {
        \While{$\var[val=v]{\mathit{next\_child}}(\bcand,head) \neq \bot$}
        {
            $\btemp \gets \var[val=v]{\mathit{next\_child}}(\bcand,head)$\\
            \uIf{$\epoch(\btemp) < \epoch(\var[val=v]{t})$ {\bf and}
                $\btemp \preceq phead$ {\bf and}
                $\isOneConfirmed_v(\btemp, \chkp_W)$}
            {
                $\bcand \gets \btemp$\label{ln:set-bcand-in-prev-epoch-loop}
            }
            \uElse { 
                \Break 
            }
        }
    }

    \uIf{$\slot(\var[val=v]{t}) = \firstslot(\epoch(\var[val=v]{t}))$ {\bf or}
        $\gu(head) \geq \epoch(\var[val=v]{t}) - 1$\nllabel{ln:second-if}}
    {
        $\btcand \gets \bcand$\;
        \While{$\var[val=v]{\mathit{next\_child}}(\btcand,head) \neq \bot$}
        {
            $\btemp \gets \var[val=v]{\mathit{next\_child}}(\btcand,head)$\\
            \uIf{$\epoch(\btemp) > \epoch(\btcand)$ {\bf and}
                $\neg \willChkpBeJustified_v(\chkp(\btemp))$\label{ln:check-will-chkp-be-justified}}
            {
                \Break
            }
            \uIf{$\isOneConfirmed_v(\btemp, \chkp_{EBA})$\label{ln:if-is-one-confirmed-second-loop}} {
                $\btcand \gets \btemp$\label{set-btcand-to-btemp}
            }
            \uElse { 
                \Break 
            }
        }

        \uIf{$\epoch(\btcand) = \epoch(\var[val=v]{t})$ {\bf or}
            $(\votsource[blck=\btcand, time={\var[val=v]{t}}] \geq \epoch(\var[val=v]{t}) - 2$ {\bf and}
            $(\slot(\var[val=v]{t}) = \firstslot(\epoch(\var[val=v]{t}))$ {\bf or}
            $\willNoConflictingChkpBeJustified_v(\chkp(head, \epoch(\var[val=v]{t})))))$\label{ln:if-to-set-bcand-to-btcand}}
        {
            $\bcand \gets \btcand$\label{ln:set-bcand-to-btcand}
        }
    }

    \Return{$\bcand$}
    \marklastline{lastline}
}
\end{algorithm}

% \setcounter{algocf}{10}
\addtocounter{algocf}{-1}

\begin{algorithm}[H]
\caption{Full Algo}
\label{alg:conffull}
\SetAlgoNoLine
\continuefrom{lastline}
% \DontPrintSemicolon
% \KwStateK{$x \in \mathbb{R}$\\ $y \in \mathbb{R}$}\\
\KwState{
    $\var[val=v]{\bconfirmed}$
}
\Upon{$\var[val=v]{t} = \var[val=v]{\tinit}$}{
    $\var[val=v]{\bconfirmed}   \gets \block(\gfattime[time={\var[val=v]{t}},val=v])$
}
\Upon{$\var[val=v]{t} = \slotstartslot{\var[val=v]{t}} \land \var[val=v]{t} \geq \var[val=v]{\tinit}$}{
    $\var[val=v]{\bconfirmed} \gets \var[val=v]{\getlatestconfirmed}(\var[val=v]{\bconfirmed})$
}
\Fn{$\var[val=v]{\mathit{is\_chain\_one\_confirmed}}(b_c, C)$}{
    $b \gets b_c$\\
    \While{$b \neq \block(C) \land \isOneConfirmed_v(b_c, C)$}{
        $b \gets \parent(b)$
    }

    \Return{$b = \block(C)$}
}
\Fn{$\var[val=v]{\willNoConflictingChkpBeJustified}(C)$}
{
    \Return{$\max(\ffgvalsettoslotweight[target={C},to={\slot(\var[val=v]{t})-1},time={\var[val=v]{t}},val=v,weight chkp={C}]
    - \beta \commweightfromslot[from=\firstslot(\epoch(t)),to=\slot(t)-1,chkp=C]{\allvals},
    0)
    + {(1-\beta)\commweightfromslot[from={\slot(\var[val=v]{t})},to=\lastslot(\epoch(C)),chkp={C},when={\var[val=v]{t}},val=v]{\allvals}}
    \geq
    \frac{1}{3}\totvalsetweight[chkp={C}] {\allvals}
    % +
    % \min\left(
    %     \ffgequivweight,
    %     \beta \commweightfromslot[from=\slotstart(\epoch(C)),to={\slot(\var[val=v]{t})}-1,chkp={C},when={\var[val=v]{t}},val=v]{\allvals}
    % \right)
    $}
}
\Proc{$\var[val=v]{\getlatestconfirmed}(b_c)$}{
    $\bcand \gets b_c$\label{ln:set-bcand-beginning-of-get-latest-confirmed}\\
    \Const $\head \gets \LMDGHOSTHFC(\viewattime[time={\var[val=v]{t}},val=v])$\\

    \uIf{$\epoch(\bcand) < \epoch(\var[val=v]{t}) - 1$ {\bf or}
        $\bcand \npreceq \head$ {\bf or}
        $(\slot(\var[val=v]{t}) = \firstslot(\epoch(\var[val=v]{t}))$ 
        % {\bf and}
        % $\epoch(\bcand) \geq \epoch(t)-1$  
        {\bf and}
        $\neg (\var[val=v]{\mathit{is\_chain\_one\_confirmed}}(b_c, \guattime[val=v,time=\slotstart(\slot(t)-1)]))$ {\bf and} $b_c \succeq \guattime[val=v,time=\slotstart(\slot(t)-1)]$\label{ln:if-bcand-npreceq-head}}{
        $\bcand \gets \block(\gfattime[val=v,time={\var[val=v]{t}}])$\label{ln:set-bcand-to-fin}
    }

    \uIf{$\slot(\var[val=v]{t}) = \firstslot(\epoch(\var[val=v]{t}))$ {\bf and}
        $\epoch(\guattime[val=v,time={\slotstart(\slot(\var[val=v]{t})-1)}]) = \epoch(\var[val=v]{t})-1$ {\bf and}
        $\gu(\LMDGHOSTHFC(\viewattime[time={\var[val=v]{t}},val=v])) = \guattime[val=v,time={\slotstart(\slot(\var[val=v]{t})-1)}]$ {\bf and}
        $\slot(\bcand) < \slot(\block(\guattime[val=v,time={\slotstart(\slot(\var[val=v]{t})-1)}]))$
        \label{ln:start-conf-chain}}
    {
        $\bcand \gets \block(\guattime[val=v,time={\slotstart(\slot(\var[val=v]{t})-1)}])$\label{ln:set-bcan-on-start-conf-chain}
    }

    \uIf{$\epoch(\bcand) \geq \epoch(\var[val=v]{t}) - 1$\label{ln:if-bcand-e-1}}
    {
        $\bcand \gets \var[val=v]{\findlatestconfirmeddescendant}(\bcand)$\label{ln:set-bcand-to-output-find-latest}
    }

    \Return{$\bcand$}
}
\end{algorithm}

\begin{definition}[Notation]\leavevmode\label{def:b-cand-is-b-conf}
    \begin{enumerate}
        \item Let $\var[time=t,val=v]{\bconfirmed}$ be the value of $\var[val=v]{\bconfirmed}$ after the execution of any code that should be executed at time $t$ as per \Cref{alg:conffull}.
        If $t < \var[val=v]{\tinit}$, then $\var[time=t,val=v]{\bconfirmed}$ corresponds to the value of $\var[val=v]{\bconfirmed}$ after executing any code that should be executed at time $\var[val=v]{\tinit}$.
        With this convention, we have the property that $\var[val=v,time=\slotstart(\slot(t))]{get\_latest\_confirmed}(b_c)$ implies that $b_c = \var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}$.
        \item Let $\var[val=v,time=\slotstartslot{t}]{\bcands}$ be the set of all the values assumed by $\bcand$ during the execution of \Cref{alg:conffull} by validator $v$ at time $\slotstartslot{t}$
        \item For any function\RSfn{Perhaps we should call these procedures as they read the state?} $f$ in \Cref{alg:conffull}, let $\var[val=v,time=t]{f}(\mathit{pars})$ be the result of honest validator $v$ executing $f(\mathit{pars})$ at time $t$.        
        \item $\canonical[time=t,blck=b,to=t_f]$ means that any time time $t'\in [t,t_f]$ block $b$ is canonical in the view of any honest validator.
        \item $\canonical[time=t,blck=b] := \canonical[time=t,blck=b,to=\infty]$.
    \end{enumerate}
\end{definition}

\begin{lemma}[This Lemma is used in the following proofs without explicitly calling it (this is not standard practice though!)]
    \leavevmode
    $\bconfirmed[val=v,time=\slotstart(\slot(t))] \in \var[val=v,time=\slotstart(\slot(t))]{\bcands}$
\end{lemma}
\begin{proof}
    Obvious.
\end{proof}

\begin{lemma}\label{lem:conf-current-epoch-then-gu-curr-epoch}
    Pick any $b_c \in  \var[val=v,time=\slotstart(\slot(t))]{\bcands}$.
    If
    \begin{enumerate}
        \item $\epoch(b_c) = \epoch(t)$
    \end{enumerate},
    then
    \begin{enumerate}
        \item $\exists b' \in \viewattime[val=v,time=\slotstartslot{t}], b' \succeq b_c \land \epoch(\gu(b')) \geq \epoch(t)-1$
        % \item $\banchor^{v,\slotstart(\slot(t))} \succeq GJ^{v,t}$
    \end{enumerate}
\end{lemma}

\begin{proof}
    % Assume we start executing the algorithm at time $t_0 = \slotstartslot{t_0}$.
    By induction on $\slot(t)$.
    Let $s := \slot(t)$.
    \begin{description}
        \item[Base Case: {$s = \slot(\var[val=v]{\tinit})$}.] The Lemma is vacuously true.
        \item[Inductive Case: {$s \geq \slot(\var[val=v]{\tinit})$}.] We assume that the Lemma holds for $s$ and prove that it also holds for $s+1$.
        Pick any $b_c \in  \var[val=v,time=\slotstart(s+1)]{\bcands}$ such that $\epoch(b_c) = \epoch(s+1)$.
        This implies that slot $s+1 \neq \firstslot(\epoch(s+1))$ as, if so, it could not be that  $\epoch(b_c) = \epoch(s+1)$.
        This then implies that  $\epoch(s+1) = \epoch(s)$.
        \begin{description}
            \item[Case 1: {$b_c = \var[val=v,time=\slotstart(s)]{\bconfirmed}$}.]
            Just apply the inductive hypothesis.
            \item[Case 2: {$b_c \neq \var[val=v,time=\slotstart(s)]{\bconfirmed}$}.]
            Given that we assume $\epoch(s+1) = \epoch(b_c)$, it must be that the \KwSty{if} condition at \Cref{ln:second-if} is true.
            Given that  $s+1 \neq \firstslot(\epoch(s+1))$, then $\gu(\head) \geq \epoch(s+1)-1$.
            The \KwSty{if} block at \Cref{ln:if-bcand-npreceq-head} ensures that $b_c \preceq \head$.
        \end{description}
    \end{description}
\end{proof}

% \begin{lemma}[Old. Now reaplced by \Cref{lem:conf-current-epoch-then-gu-curr-epoch}]
%     If
%     \begin{enumerate}
%         \item $\epoch(\bconfirmed[val=v,time=\slotstart(\slot(t))]) = \epoch(t)$
%     \end{enumerate},
%     then
%     \begin{enumerate}
%         \item $\exists b' \in \viewattime[val=v,time=\slotstartslot{t}], \epoch(\gu(b')) \geq \epoch(t)-1$
%         % \item $\banchor^{v,\slotstart(\slot(t))} \succeq GJ^{v,t}$
%     \end{enumerate}
% \end{lemma}

% \begin{proof}
%     % Assume we start executing the algorithm at time $t_0 = \slotstartslot{t_0}$.
%     By induction on $\slot(t)$.
%     Let $s := \slot(t)$.
%     \begin{description}
%         \item[Base Case: {$s = \slot(\var[val=v]{\tinit})$}.] The Lemma is vacuously true.
%         \item[Inductive Case: {$s \geq \slot(\var[val=v]{\tinit})$}.] We assume that the Lemma holds for $s$ and prove that it also holds for $s+1$.
%         We also assume that $\epoch(\var[val=v,time=\slotstart(s+1)]{\bconfirmed}) = \epoch(s+1)$ as the Lemma holds vacuously otherwise.
%         This implies that slot $s+1 \neq \firstslot(\epoch(s+1))$ as, if so, it could not be that  $\epoch(\var[val=v,time=\slotstart(s+1)]{\bconfirmed}) = \epoch(s+1)$.
%         This then implies that  $\epoch(s+1) = \epoch(s)$.
%         % This implies that $\epoch(s+1) = \epoch(s)$ as, otherwise, it would mean that we are the beginning of epoch $\epoch(s)+1$ and, therefore, it cannot be that $\epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed}) = \epoch(s+1)$ reaching a contradiction.
%         \begin{description}
%             \item[Case 1: {$\epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed}) = \epoch(s)$}.] Given that $\epoch(s+1) = \epoch(s)$, the proof for this case follows directly from the inductive hypothesis.
%             \item[Case 2: {$\epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed}) \neq \epoch(s)$}.] 
%             Given that $\epoch(\var[val=v,time=\slotstart(s+1)]{\bconfirmed}) = \epoch(s+1) = \epoch(s)$, it must be that condition at Line XXX is true which implies that the Lemma holds.
%         \end{description}
%     \end{description}
% \end{proof}

% \begin{lemma}\label{lem:current-epoch-then-gu-prev-epoch}
%     If
%     \begin{enumerate}
%         \item $\epoch(\var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}) = \epoch(t)$
%     \end{enumerate},
%     then
%     \begin{enumerate}
%         \item $\exists b' \in \viewattime[val=v,time=\slotstartslot{t}], b' \succeq \var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed} \land \epoch(\gu(b')) \geq \epoch(t)-1$
%         % \item $\banchor^{v,\slotstart(\slot(t))} \succeq GJ^{v,t}$
%     \end{enumerate}
% \end{lemma}

% \begin{proof}
%     % Assume we start executing the algorithm at time $t_0 = \slotstartslot{t_0}$.
%     By induction on $\slot(t)$.
%     Let $s := \slot(t)$.
%     \begin{description}
%         \item[Base Case: {$s = \slot(\var[val=v]{\tinit})$}.] The Lemma is vacuously true.
%         \item[Inductive Case: {$s \geq \slot(\var[val=v]{\tinit})$}.] We assume that the Lemma holds for $s$ and prove that it also holds for $s+1$.
%         We also assume that $\epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed}) = \epoch(s+1)$ as the Lemma holds vacuously otherwise.
%         This implies that $\epoch(s+1) = \epoch(s)$ as, otherwise, it would mean that we are the beginning of epoch $\epoch(s)+1$ and, therefore, it cannot be that $\epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed}) = \epoch(s+1)$ reaching a contradiction.
%         \begin{description}
%             \item[Case 1: {$\epoch(\var[val=v,time=\slotstart(s-1)]{\bconfirmed}) = \epoch(s)$}.] 
%             Given that $\epoch(s+1) = \epoch(s)$, the proof for this case follows directly from the inductive hypothesis.
%             \item[Case 2: {$\epoch(\var[val=v,time=\slotstart(s-1)]{\bconfirmed}) \neq \epoch(s)$}.] 
%             Given that $\epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed}) = \epoch(s+1) = \epoch(s)$, it must be that condition at Line XXX is true which implies that the Lemma holds.
%         \end{description}
%     \end{description}
% \end{proof}

\begin{lemma}\label{lem:output-find-latest-different-to-input}
    Let $b_o := \var[val=v,time=\slotstartslot{t}]{\findlatestconfirmeddescendant}(b_c)$.
    If 
    \begin{enumerate}
        \item $b_o \neq b_c$
        \item $\epoch(b_o) = \epoch(t) - 1$
    \end{enumerate},
    then, there exists an honest validator $v'$ such that 
    \begin{enumerate}
        \item $\exists b' \in \left(\viewattime[time=\votingtime(\slot({t})-1),val=v'] \cap \viewattime[time=\slotstart(\slot({t})),val=v]\right), b' \succeq b_o \land \epoch(\votsource[blck=b',time=\slotstartslot{{t}}])\geq \epoch({t})-2$
    \end{enumerate}    
\end{lemma}

\begin{proof}
    It must be that $\bcand \gets b_o$ at some point during the execution of   $\findlatestconfirmeddescendant$.
    Below by cases on the line  of $\findlatestconfirmeddescendant$ where this occurs.
    \begin{description}
        \item[\Cref{ln:bcand-set-beginning-of-find-latest}.]  Impossible as this lines sets $\bcand$ to $b_c \neq b_o$.
        \item[\Cref{ln:set-bcand-in-prev-epoch-loop}.] 
        If $\bcand$ is set to $b_o$ here, then it must be that $b_o \preceq phead$ which also implies $phead \in \viewattime[time=\slotstart(\slot(t)-1),val=v] \subseteq \viewattime[time=\votingtime(\slot(t)-1),val=v] \subseteq \viewattime[time=\slotstart(\slot(t)),val=v]$.
        Then, given \Cref{ln:if-prev-epoch} and the Lemma statement, $phead \succeq b_o \land \epoch(\votsource[blck=phead, time={\slotstartslot{t}}]) \geq \epoch({t}) - 2$.
        \item[\Cref{ln:set-bcand-to-btcand}] If $\bcand$ is set to $b_o$ here, then, due to \Cref{ln:if-to-set-bcand-to-btcand}, $\epoch(\votsource[blck=b_o, time={\slotstartslot{t}}]) \geq \epoch(t) - 2$.
        Due to \Cref{ln:if-is-one-confirmed-second-loop,set-btcand-to-btemp}, $\isOneConfirmed(b_o, \cdot)$ which implies\RSfn{We should probably have a Lemma proving such an implication} that there exists an honest validator $v'$ such that
        $b_o \in \left(\viewattime[time=\votingtime(\slot(t)-1),val=v']\cap \viewattime[time=\slotstart(\slot(t)),val=v]\right)$.
    \end{description}
\end{proof}

% \begin{lemma}\label{lem:output-find-latest-different-to-input}
%     Let $b_o := \var[val=v]{\findlatestconfirmeddescendant}(b_c)$.
%     If $b_o \neq b_c$, then
%     then, 
%     \begin{enumerate}
%         \item $\exists b' \in \viewattime[time=\slotstart(\slot({\var[val=v]{t}})),val=v'], b' \succeq b_o \land \epoch(\votsource[blck=b',time=\slotstartslot{{\var[val=v]{t}}}])\geq \epoch({\var[val=v]{t}})-2$
%     \end{enumerate}    
% \end{lemma}

% \begin{proof}
%     It must be that $\bcand \gets b_o$ at some point during the execution of   $\findlatestconfirmeddescendant$.
%     Below by cases on the line  of $\findlatestconfirmeddescendant$ where this occurs.
%     \begin{description}
%         \item[\Cref{ln:bcand-set-beginning-of-find-latest}.]  Impossible as this lines sets $\bcand$ to $b_c \neq b_o$.
%         \item[\Cref{ln:set-bcand-in-prev-epoch-loop}.] 
%         If $\bcand$ is set here, then it must be that $\bcand \preceq phead$ which also implies $\bcand \in \viewattime[time=\slotstart({\var[val=v]{t}}),val=v]$.
%         Then, given \Cref{ln:if-prev-epoch}, $\votsource[blck=phead, time=\slotstart({\var[val=v]{t}})] \geq \epoch({\var[val=v]{t}}) - 2$.
%         \item[\Cref{ln:set-bcand-to-btcand}] If $\bcand$ is set here, then, due to \Cref{ln:if-to-set-bcand-to-btcand}, $\votsource[blck=\bcand, time={\var[val=v]{t}}] \geq \epoch(\var[val=v]{t}) - 2$ and clearly $\bcand \in \viewattime[time=\slotstart({\var[val=v]{t}}),val=v]$.
%         % Due to \Cref{ln:if-is-one-confirmed-second-loop,set-btcand-to-btemp}, $\isOneConfirmed(\bcand, \cdot)$ which implies\RSfn{We should probably have a Lemma proving such an implication} that there exists an honest validator $v'$ such that
%         % $\bcand \in \viewattime[time=\slotstart({\var[val=v]{t}}-1),val=v']$.
%     \end{description}    
% \end{proof}

\begin{lemma}\label{lem:when-restarting-vs-from-prev-epoch}
    Pick any $b_c \in  \var[val=v,time=\slotstart(\slot(t))]{\bcands}$.
    If
    \begin{enumerate}
        \item $\epoch(\var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}) < \epoch(t)-1$
        \item $\epoch(b_c) \geq \epoch(t)-1$
    \end{enumerate},
    then, there exists an honest validator $v'$ such that 
    \begin{enumerate}
        \item $\exists b' \in \viewattime[time=\votingtime(\slot(t)-1),val=v'], b' \succeq b_c \land \epoch(\votsource[blck=b',time=\slotstartslot{t}])\geq \epoch(t)-2$
    \end{enumerate}
\end{lemma}
\begin{proof}
    Let $s:= \slot(t)$.
    It must be that we restart the ``confirmation chain'' at time $\slotstart(s)$ as there is no other way to satisfy the conditions in the Lemma's statement.
    This means that conditions at \Cref{ln:start-conf-chain} are true.

    Now, we prove the statement by induction on the lines, in order of execution, where $\bcand$ might be set.
    
    Given the above, we know that the first time it is set is at \Cref{ln:set-bcan-on-start-conf-chain}

    \begin{description}
        \item[\Cref{ln:set-bcan-on-start-conf-chain}.] Obvious. \RSfn{Perhaps explain a bit more why in the future.} 
        \item[\Cref{ln:set-bcand-to-output-find-latest}.] Given $\slot(t) = \firstslot(\epoch(t))$ and the assumption in the Lemma statement, we know that $\epoch(b_c) = \epoch(t) - 1$ and thus can apply \Cref{lem:output-find-latest-different-to-input} to conclude the proof.
    \end{description}
\end{proof}

% \begin{lemma}\label{lem:when-restarting-vs-from-prev-epoch}
%     Pick any $b_c \in  \var[val=v,time=\slotstart(\slot(t))]{\bcands}$..
%     If
%     \begin{enumerate}
%         \item $\epoch(\var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}) < \epoch(t)-1$
%         \item $\epoch(b_c) \geq \epoch(t)-1$
%     \end{enumerate},
%     then,
%     \begin{enumerate}
%         \item $\exists b' \in \viewattime[time=\slotstart(\slot(t)),val=v], b' \succeq b_c \land \epoch(\votsource[blck=b',time=\slotstartslot{t}])\geq \epoch(t)-2$
%     \end{enumerate}
% \end{lemma}
% \begin{proof}
%     Let $s:= \slot(t)$.
%     It must be that we restart the ``confirmation chain'' at time $\slotstart(s)$ as there is no other way to satisfy the conditions in the Lemma's statement.
%     This means that conditions at \Cref{ln:start-conf-chain} are true.

%     Now, we prove the statement by induction on the lines, in order of execution, where $\bcand$ might be set.
    
%     Given the above, we know that the first time it is set is at \Cref{ln:set-bcan-on-start-conf-chain}

%     \begin{description}
%         \item[\Cref{ln:set-bcan-on-start-conf-chain}.] Obvious. \RSfn{Perhaps explain a bit more why in the future.} 
%         \item[\Cref{ln:set-bcand-to-output-find-latest}.] Obvious from \Cref{lem:output-find-latest-different-to-input}.
%     \end{description}
% \end{proof}



% \begin{lemma}\label{lem:when-restarting-vs-from-prev-epoch}
%     Pick any $b_c \in  \var[val=v,time=\slotstart(\slot(t))]{\bcands}$..
%     If
%     \begin{enumerate}
%         \item $\epoch(\var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}) < \epoch(t)-1$
%         \item $\epoch(b_c) \geq \epoch(t)-1$
%     \end{enumerate},
%     then,
%     \begin{enumerate}
%         \item $\exists b' \in \viewattime[time=\slotstart(\slot(t)),val=v], b' \succeq b_c \land \epoch(\votsource[blck=b',time=\slotstartslot{t}])\geq \epoch(t)-2$
%     \end{enumerate}
% \end{lemma}
% \begin{proof}
%     Let $s:= \slot(t)$.
%     It must be that we restart the ``confirmation chain'' at time $\slotstart(s)$ as there is no other way to satisfy the conditions in the Lemma's statement.
%     This means that conditions at \Cref{ln:start-conf-chain} are true.

%     Now, we prove the statement by induction on the lines, in order of execution, where $\bcand$ might be set.
    
%     Given the above, we know that the first time it is set is at \Cref{ln:set-bcan-on-start-conf-chain}

%     \begin{description}
%         \item[\Cref{ln:set-bcan-on-start-conf-chain}.] Obvious. \RSfn{Perhaps explain a bit more why in the future.} 
%         \item[\Cref{ln:set-bcand-to-output-find-latest}.] Obvious from \Cref{lem:output-find-latest-different-to-input}.
%     \end{description}
% \end{proof}

% \begin{lemma}\label{lem:conf-prev-epoch-then-vs-two-epochs-ago-old}
%     If
%     \begin{enumerate}
%         \item $\epoch(\var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}) \geq \epoch(t)-1$
%     \end{enumerate},
%     then
%     \begin{enumerate}
%         \item $\exists b' \in \viewattime[time=\slotstart(\slot(t)-1),val=v], \epoch(\votsource[blck=b',time=\slotstartslot{t}])\geq \epoch(t)-2$
%         % \item $\banchor^{v,\slotstart(\slot(t))} \succeq GJ^{v,t}$
%     \end{enumerate}
% \end{lemma}

% \begin{lemma}%[Replacement for \Cref{lem:conf-prev-epoch-then-vs-two-epochs-ago-old}]
%     % \label{lem:conf-prev-epoch-then-vs-two-epochs-ago}
%     %  \label{lem:vs-at-least-e-2}
%     Pick any $b_c \in  \var[val=v,time=\slotstart(\slot(t))]{\bcands}$.
%     If
%     \begin{enumerate}
%         \item $\epoch(b_c) \geq \epoch(t)-1$
%         \item $\epoch(\var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}) \geq \epoch(t)-1$
%     \end{enumerate},
%     then, 
%     \begin{enumerate}
%         \item $\exists b' \in \viewattime[time=\slotstart(\slot(t)-1),val=v], b' \succeq  b_c \land \epoch(\votsource[blck=b',time=\slotstartslot{t}])\geq \epoch(t)-2$
%         % \item $\banchor^{v,\slotstart(\slot(t))} \succeq GJ^{v,t}$
%     \end{enumerate}
% \end{lemma}

% \begin{proof}
%     By induction on $\slot(t)$.
%     Let $s := \slot(t)$.
%     \begin{description}
%         \item[Base Case: {$s = \slot(\var[val=v]{\tinit})$}.] The Lemma is vacuously true.
%         \item[Inductive Case: {$s \geq \slot(\var[val=v]{\tinit})$}.] We assume that the Lemma holds for $s$ and prove that it also holds for $s+1$.
%         So let $b_c \in  \var[val=v,time=\slotstart(s+1)]{\bcands}$.
%         We also assume that $\epoch(b_c) \geq \epoch(s+1)-1$ and $\epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed}) \geq \epoch(s+1)-1$ as the Lemma holds vacuously otherwise.
%         Note that this implies that $\epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed}) \geq \epoch(s)-1$.
%         By case.
%         \begin{description}
%             \item[Case 1: {$b_c = \var[val=v,time=\slotstart(s)]{\bconfirmed}$}.] 
%             By sub cases again.
%             \begin{description}
%                 \item[Case 1.1: $\epoch(s+1) = \epoch(s).$] 
%                 Given that $\var[val=v,time=\slotstart(s)]{\bconfirmed} \in \var[val=v,time=\slotstart(s)]{\bcands}$,
%                 we can apply the inductive hypothesis to conclude that $\exists b' \in \viewattime[time=\slotstart(s-1),val=v], b' \succeq b_c \land \epoch(\votsource[blck=b',time=\slotstart(s)])\geq \epoch(s)-2 = \epoch(s+1)-2$.
%                 So, given that $\viewattime[time=\slotstart(s-1),val=v'] \subseteq \viewattime[time=\slotstart(s),val=v']$, the proof for this case is concluded.
%                 \item[Case 1.2: $\epoch(s+1) = \epoch(s) + 1.$]
%                 This Case implies that $\epoch(b_c) = \epoch(s)$ as 
%                 $\epoch(s) = \epoch(s+1) -1 \leq \epoch(b_c) < \epoch(s+1) = \epoch(s) + 1$.
%                 Note also that  $\epoch(s+1) = \epoch(s) + 1$ implies that $s+1 = \firstslot(\epoch(s+1))$.
%                 All of this together with  \Cref{lem:conf-current-epoch-then-gu-curr-epoch} implies that $\exists b' \in \viewattime[time=\slotstart(s),val=v], \epoch(\votsource[blck=b',time=\slotstart(s+1)])\geq \epoch(\gu(b')) \geq \epoch(s)-1\geq\epoch(s+1)-2$.
%             \end{description}
%             \item[Case 2.2: {$b_c \neq \var[val=v,time=\slotstart(s)]{\bconfirmed}$}.]
%             Now by cases on the first line, in order of execution of the Fast Confirmation Rule algorithm at time $\slotstart(s+1)$, where $\bcand = b_c$. 
%             \begin{description}
%                 \item[\Cref{ln:set-bcand-beginning-of-get-latest-confirmed}.] 
%                 Impossible, as at this line $\bcand = b_c$, but $b_c \neq \var[val=v,time=\slotstart(s)]{\bconfirmed}$.
%                 \item[\Cref{ln:set-bcand-to-fin}.] Impossible, as at this line $\epoch(\bcand) < \epoch(s+1)-1$, but we assume $\epoch(b_c) \geq \epoch(s+1)-1$.
%                 \item[\Cref{ln:set-bcan-on-start-conf-chain}.] Obvious. \RSfn{Perhaps explain a bit more why in the future.} 
%                 \item[\Cref{ln:set-bcand-to-output-find-latest}.] Obvious from \Cref{lem:output-find-latest-different-to-input}.
%             \end{description}
%         \end{description}
%     \end{description}
% \end{proof}

\begin{lemma}\label{lem:output-find-latest-different-to-input-then-output-older-than-current-slot}
    Let $b_o := \var[val=v,time=\slotstartslot{t}]{\findlatestconfirmeddescendant}(b_c)$.
    If 
    \begin{enumerate}
        \item $b_o \neq b_c$
    \end{enumerate},
    then, 
    \begin{enumerate}
        \item $\slot(b_o) < \slot(t)$
    \end{enumerate}    
\end{lemma}

\begin{proof}(Sketch)
    Every time that we set $\bcand$, we set it to a block that has received at least a vote from an honest node and honest nodes never vote for blocks in the future.
\end{proof}

\begin{lemma}\label{lem:bcand-less-than-current-slot}
    Pick any $b_c \in  \var[val=v,time=\slotstart(\slot(t))]{\bcands}$.
    Then, $\slot(b_c) < \slot(t)$
\end{lemma}

\begin{proof}
    By induction on $\slot(t)$.
    Let $s := \slot(t)$.
    \begin{description}
        \item[Base Case: {$s = \slot(\var[val=v]{\tinit})$}.] Obvious.
        \item[Inductive Case: {$s \geq \slot(\var[val=v]{\tinit})$}.]
            We assume that the Lemma holds for $s$ and prove that it also holds for $s+1$.
            Pick any $b_c \in \var[val=v,time=\slotstart(s+1)]{\bcands}$.
            By cases.
            \begin{description}
                \item[Case 1: {$b_c = \var[val=v,time=\slotstart(s)]{\bconfirmed}$}.] Then, we can apply the inductive hypothesis and conclude that $\slot(b_c) < s < s+1$.
                \item[Case 2: {$b_c \neq \var[val=v,time=\slotstart(s)]{\bconfirmed}$}.]
                Now by cases on the first line, in order of execution of the Fast Confirmation Rule algorithm at time $\slotstart(s+1)$, where $\bcand = b_c$. 
                \begin{description}
                    \item[\Cref{ln:set-bcand-beginning-of-get-latest-confirmed}.] 
                    Impossible, as at this line $\bcand = b_c$, but $b_c \neq \var[val=v,time=\slotstart(s)]{\bconfirmed}$.
                    \item[\Cref{ln:set-bcand-to-fin}.] $\epoch(\bcand) < \epoch(s+1)-1 < \epoch(s+1)$.
                    \item[\Cref{ln:set-bcan-on-start-conf-chain}.] $\epoch(\bcand) = \epoch(s+1)-1 < \epoch(s+1)$. 
                    \item[\Cref{ln:set-bcand-to-output-find-latest}.] Apply \Cref{lem:output-find-latest-different-to-input-then-output-older-than-current-slot}.
                \end{description}
            \end{description}
    \end{description}
\end{proof}

\begin{lemma}\label{lem:out-find-latest-conf-prec-head}
    Let $b_o := \var[val=v]{\findlatestconfirmeddescendant}(b_c)$.
    If 
    \begin{enumerate}
        \item $b_o \neq b_c$
    \end{enumerate},
    then, 
    \begin{enumerate}
        \item $b_o \preceq \LMDGHOSTHFC(\viewatstslottime[val=v,time=t])$
    \end{enumerate}
\end{lemma}
\begin{proof}
    Obvious.
\end{proof}

\begin{lemma}
    $\bconfirmed[val=v,time=\slotstart(\slot(t))] \preceq \LMDGHOSTHFC(\viewatstslottime[val=v,time=t])$\label{lem:bconf-always-canonical}
\end{lemma}
\begin{proof}\RSfn{I know that this looks like a very complicated proof to establish something obvious. It's because reasoningon program executions in a manual way is very pedantic in nature.}
    By contradiction, assume that $\bconfirmed[val=v,time=\slotstart(\slot(t))] \npreceq \LMDGHOSTHFC(\viewatstslottime[val=v,time=t])$.
    Note that must be that $\bcand \gets \bconfirmed[val=v,time=\slotstart(\slot(t))]$ at some point during the execution of  $\findlatestconfirmeddescendant$ and $\bcand$ is not set any other value (expect for potentially setting it to $\bconfirmed[val=v,time=\slotstart(\slot(t))]$ again) until the \KwSty{return} statement.
    Below by cases on the line  of $\findlatestconfirmeddescendant$ where this occurs.
    \begin{description}
        \item[\Cref{ln:set-bcand-beginning-of-get-latest-confirmed}.] 
        If $\bcand = \bconfirmed[val=v,time=\slotstart(\slot(t))] \npreceq \LMDGHOSTHFC(\viewatstslottime[val=v,time=t])$, then \Cref{ln:set-bcand-to-fin} is also executed.
        This line sets $\bcand$ to $\block(\gfattime[val=v,time={\var[val=v]{t}}]) \preceq \LMDGHOSTHFC(\viewatstslottime[val=v,time=t])$. 
        Given the above, this implies that \Cref{ln:set-bcand-to-fin} sets $\bcand$ to a value different from $\bconfirmed[val=v,time=\slotstart(\slot(t))]$.
        Therefore \Cref{ln:set-bcand-beginning-of-get-latest-confirmed} is not the last line where $\bcand$ is set $\bconfirmed[val=v,time=\slotstart(\slot(t))]$ and any successive line setting $\bcand$ sets it to $\bconfirmed[val=v,time=\slotstart(\slot(t))]$.\RSfn{Perhaps improve the English here :)}
        \item[\Cref{ln:set-bcand-to-fin}.] Obvious\RSfn{Pehaps explain a bit more why}.
        \item[\Cref{ln:set-bcan-on-start-conf-chain}.] In this case $\bcand = \gjattime[val=v,time=\slot(t)]$ which implies $\bconfirmed[val=v,time=\slotstart(\slot(t))] \preceq \LMDGHOSTHFC(\viewatstslottime[val=v,time=t])$ reaching a contradiction.
        \item[\Cref{ln:set-bcand-to-output-find-latest}.]  \Cref{lem:out-find-latest-conf-prec-head} implies that if this line is executed, then the value of $\bcand$ is not updated which means that there exists a previous line where $\bcand \gets \bconfirmed[val=v,time=\slotstart(\slot(t))]$ reaching a contradiction.
    \end{description}
\end{proof}


\begin{lemma}\label{lem:out-find-latest-conf-descendant-output}
    $\var[val=v]{\findlatestconfirmeddescendant}(b_c) \succeq b_c$
\end{lemma}
\begin{proof}
    Obvious.
\end{proof}

\begin{lemma}\label{lem:prev-conf-at-least-e-1}
    Pick any $b_c \in  \var[val=v,time=\slotstart(\slot(t))]{\bcands}$.
    If
    \begin{enumerate}
        \item $\slot(t) > \text{\firstslot}(\epoch(t))$
        \item $\epoch(b_c) \geq \epoch(t)-1$
    \end{enumerate},
    then
    \begin{enumerate}
        \item $\epoch(\var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}) \geq \epoch(t)-1$
        \item $\var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed} \preceq \LMDGHOSTHFC(\viewatstslottime[val=v,time=t])$
        \item $\var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed} \preceq b_c$
    \end{enumerate}
\end{lemma}

\begin{proof}\RSfn{I think that the structure of this proof should be improved}
By \Cref{def:b-cand-is-b-conf} algorithm execution at $\slotstartslot{t}$ starts with
$b_c = \var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}$.
Given Condition 1 of the Lemma's statement, condition at \Cref{ln:start-conf-chain}
does not hold making code at \Cref{ln:set-bcan-on-start-conf-chain} unreachable.
We also know that condition at \Cref{ln:if-bcand-npreceq-head} does not hold, otherwise,
$b_c = \gfattime[time=\slotstartslot{t},val=v]$
and $\epoch(b_c) \leq \epoch(t) - 2$
which contradicts Condition 2 of the Lemma's statement.

Let's now move to proving Conclusion 3.
By cases.
\begin{description}
    \item[Case 1: {$b_c = \var[val=v,time=\slotstart(\slot(t)-1)]{\bcands}$}.]  Obvious.
    \item[Case 2: {$b_c \neq \var[val=v,time=\slotstart(\slot(t)-1)]{\bcands}$}.]
    Now by cases on the first line, in order of execution of the Fast Confirmation Rule algorithm at time $\slotstart(s+1)$, where $\bcand = b_c$. 
    \begin{description}
        \item[\Cref{ln:set-bcand-beginning-of-get-latest-confirmed}.] 
        Impossible, as at this line $\bcand = b_c$, but $b_c \neq \var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}$.
        \item[\Cref{ln:set-bcand-to-fin}.] Impossible, as at this line $\epoch(\bcand) < \epoch(\slot(t)+1)-1$, but we assume $\epoch(b_c) \geq \epoch(\slot(t)+1) -1$.
        \item[\Cref{ln:set-bcan-on-start-conf-chain}.] Impossible, as at this line cannot be executed if $\slot(t) \neq \firstslot(\epoch(t))$.
        \item[\Cref{ln:set-bcand-to-output-find-latest}.] Given that this is the only line where $\bcand \gets b_c$, \Cref{lem:out-find-latest-conf-descendant-output} implies that $\var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed} \preceq b_c$.
    \end{description}
\end{description}

\end{proof}
\begin{lemma}\label{lem:bcand-prev-epoch-vs-at-least-e-2}
    Pick any $b_c \in  \var[val=v,time=\slotstart(\slot(t))]{\bcands}$.
    If
    \begin{enumerate}
        \item $\epoch(b_c) = \epoch(t)-1$
    \end{enumerate},
    then, there exists an honest validator $v'$ such that
    \begin{enumerate}
        \item $\exists b' \in \left(\viewattime[time=\votingtime(\slot(t)-1),val=v'] \cap \viewattime[time=\slotstart(\slot(t)),val=v']\right), b' \succeq b_c \land \epoch(\votsource[blck=b',time=\slotstartslot{t}])\geq \epoch(t)-2$
    \end{enumerate}
\end{lemma}

\begin{proof}
    By induction on $\slot(t)$.
    Let $s := \slot(t)$.
    \begin{description}
        \item[Base Case: {$s = \slot(\var[val=v]{\tinit})$}.] The Lemma is vacuously true.
        \item[Inductive Case: {$s \geq \slot(\var[val=v]{\tinit})$}.] We assume that the Lemma holds for $s$ and prove that it also holds for $s+1$.
        Pick any $b_c \in \var[val=v,time=\slotstart(s+1)]{\bcands}$ such that $\epoch(b_c) \geq \epoch(s+1)-1$.
        % We also assume that $\epoch(b_c) \geq \epoch(s+1)-1$ as the Lemma holds vacuously otherwise.
        \begin{description}
            \item[Case 1: {$\epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed}) < \epoch(s+1)-1$}.] Apply  \Cref{lem:when-restarting-vs-from-prev-epoch}.
            \item[Case 2: {$\epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed}) \geq \epoch(s+1)-1$}.]
            % To prove the Lemma is sufficient 
            By sub cases.
            \begin{description}
                \item[Case 2.1: {$b_c = \var[val=v,time=\slotstart(s)]{\bconfirmed}$}.] 
                By sub cases again.
                \begin{description}
                    \item[Case 2.1.1: $\epoch(s+1) = \epoch(s).$] 
                    Given that $\var[val=v,time=\slotstart(s)]{\bconfirmed} \in \var[val=v,time=\slotstart(s)]{\bcands}$,
                    we can apply the inductive hypothesis to conclude that there exists an honest validator $v'$ such that $\exists b' \in \left(\viewattime[time=\slotstart(s-1),val=v'] \cap \viewattime[time=\slotstart(s),val=v]\right), b' \succeq b_c \land \epoch(\votsource[blck=b',time=\slotstart(s)])\geq \epoch(s)-2 = \epoch(s+1)-2$.
                    So, given that $\viewattime[time=\slotstart(s-1),val=v'] \subseteq \viewattime[time=\slotstart(s),val=v']$ and $\viewattime[time=\slotstart(s),val=v] \subseteq \viewattime[time=\slotstart(s+1),val=v]$, the proof for this case is concluded.
                    \item[Case 2.1.2: $\epoch(s+1) = \epoch(s) + 1.$]
                    This Case implies that $\epoch(b_c) = \epoch(s)$ as 
                    $\epoch(s) = \epoch(s+1) -1 \leq \epoch(b_c) < \epoch(s+1) = \epoch(s) + 1$.
                    Note also that  $\epoch(s+1) = \epoch(s) + 1$ implies that $s+1 = \firstslot(\epoch(s+1))$.
                    All of this together with  \Cref{lem:conf-current-epoch-then-gu-curr-epoch} implies that $\exists b' \in \viewattime[time=\slotstart(s),val=v] \subseteq \viewattime[time=\slotstart(s+1),val=v], b' \succeq b_c \land \epoch(\votsource[blck=b',time=\slotstart(s+1)])\geq \epoch(\gu(b')) \geq \epoch(s)-1\geq\epoch(s+1)-2$.
                \end{description}
                \item[Case 2.2: {$b_c \neq \var[val=v,time=\slotstart(s)]{\bconfirmed}$}.]
                Now by cases on the first line, in order of execution of the Fast Confirmation Rule algorithm at time $\slotstart(s+1)$, where $\bcand = b_c$. 
                \begin{description}
                    \item[\Cref{ln:set-bcand-beginning-of-get-latest-confirmed}.] 
                    Impossible, as at this line $\bcand = b_c$, but $b_c \neq \var[val=v,time=\slotstart(s)]{\bconfirmed}$.
                    \item[\Cref{ln:set-bcand-to-fin}.] Impossible, as at this line $\epoch(\bcand) < \epoch(s+1)-1$, but we assume $\epoch(b_c) \geq \epoch(s+1)-1$.
                    \item[\Cref{ln:set-bcan-on-start-conf-chain}.] Obvious. \RSfn{Perhaps explain a bit more why in the future.} 
                    \item[\Cref{ln:set-bcand-to-output-find-latest}.]
                    The Lemma's statement implies $\epoch(b_c) = \epoch(s+1) - 1$. Then apply \Cref{lem:output-find-latest-different-to-input}.
                \end{description}
            \end{description}
        \end{description}
    \end{description}
\end{proof}

\begin{lemma}\label{lem:bconfirmed-at-first-slot-is-from-e-1}
    Pick any $b_c \in \var[val=v,time=\slotstart(\slot(t))]{\bcands}$.
    If
    \begin{enumerate}
        \item $\epoch(b_c) \geq \epoch(t)-1$
    \end{enumerate},
    then,
    \begin{enumerate}
        \item $\epoch(\var[val=v,time=\slotstart(\epoch(t))]{\bconfirmed}) = \epoch(t)-1$.
    \end{enumerate}
\end{lemma}

\begin{proof}
    Let $s := \slot(t)$.
    We know that honest validators do not vote for blocks from the future slots which implies an impossibility of $\epoch(b_c) > \epoch(t)-1$ for any $b_c \in \var[val=v,time=\slotstart(s)]{\bcands}$ if $s=\firstslot(\epoch(t))$.
    By cases.
    \begin{description}
        \item[Case 1: {$s = \firstslot(\epoch(t))$}.]
        From the Lemma's condition and the above impossibility we know that $\epoch(b_c) = \epoch(t)-1$ in this case.
        Then the fact that $\var[val=v,time=\slotstartslot{t})]{\bconfirmed} \in \var[val=v,time=\slotstartslot{t})]{\bcands}$ concludes the proof.
        \item[Case 2: {$s \neq \firstslot(\epoch(t))$}.] Implies $s > \firstslot(\epoch(t))$.
        By contradiction.
        Suppose $\epoch(\var[val=v,time=\slotstart(\epoch(t))]{\bconfirmed}) < \epoch(t)-1$.
        Then consider a slot $s' \geq s$ to be the lowest slot in $\epoch(t)$ for which $\epoch(b') \geq \epoch(t)-1$ for any $b' \in \var[val=v,time=\slotstart(s')]{\bcands}$.
        Now by cases on the first line, in order of execution of the Fast Confirmation Rule algorithm at time $\slotstart(s')$, where $\epoch(\bcand) \geq \epoch(t)-1$. 
        \begin{description}
            \item[\Cref{ln:set-bcand-beginning-of-get-latest-confirmed}.] 
            Impossible, as at this line $\bcand = \var[val=v,time=\slotstart(s'-1)]{\bconfirmed}$ but $s'$ is the lowest slot for which $\epoch(b_c) \geq \epoch(t)-1$.
            \item[\Cref{ln:set-bcand-to-fin}.] Impossible, as at this line $\epoch(\bcand) = \epoch(\block(\gfattime[val=v,time=\slotstart(s')])) < \epoch(t)-1$.
            \item[\Cref{ln:set-bcan-on-start-conf-chain}.] Impossible, as $s' \geq s > \firstslot(\epoch(t))$.
            \item[\Cref{ln:set-bcand-to-output-find-latest}.] Impossible, as this line can only be executed if a previous line set $\bcand$ to a value such that $\epoch(\bcand) \geq \epoch(t)-1$. However, this  is impossible as we assume that this is the first line where this happens.
        \end{description}
        Due to the fact that we have reached impossiblity in any of the above cases the proof is concluded.
    \end{description}
\end{proof}

\begin{lemma}\label{lem:exists-b-vs-at-least-e-2}
    Pick any $b_c \in \var[val=v,time=\slotstart(\slot(t))]{\bcands}$.
    If
    \begin{enumerate}
        \item $\lastslot(\epoch(t)-1) \geq \GST$
        \item $\epoch(b_c) \geq \epoch(t)-1$
    \end{enumerate},
    then for any honest validator $v'$,
    \begin{enumerate}
        \item $\exists b' \in \viewattime[val=v',time=\slotstart(\epoch(t))]$ such that $\votsource[blck=b',time=\epoch(t)] \geq \epoch(t)-2$.
    \end{enumerate}
\end{lemma}

\begin{proof}
    Due to \Cref{lem:bconfirmed-at-first-slot-is-from-e-1} we know that $\exists b_c \in \var[val=v,time=\slotstart(\epoch(t))]{\bcands}$ such that $\epoch(b_c) = \epoch(t)-1$.
    Then by \Cref{lem:bcand-prev-epoch-vs-at-least-e-2} we know that there exists an honest validator $v^h$ for which $\exists b' \in \viewattime[time=\votingtime(\lastslot(\epoch(t)-1)),val=v^h]$ such that $\epoch(\votsource[blck=b',time=\epoch(t)]) \geq \epoch(t)-2$.
    This together with the synchrony assumption concludes the proof.
\end{proof}

\begin{lemma}\label{lem:gj-at-least-e-2-alt}
    Pick any $b_c \in  \var[val=v,time=\slotstart(\slot(t))]{\bcands}$, any time $t' \geq \slotstart(\epoch(t))$ and any honest validator $v'$.
    If
    \begin{enumerate}
        \item $\slotstart(\lastslot(\epoch(t)-1)) \geq \GST$
        \item $\epoch(b_c) \geq \epoch(t)-1$
    \end{enumerate},
    then,
    \begin{enumerate}
        \item $\epoch(\gjattime[val=v',time=t']) \geq \epoch(t)-2$.
    \end{enumerate}
\end{lemma}

\begin{proof}
    Due to \Cref{lem:exists-b-vs-at-least-e-2}, Definition 3 of the Paper and the monotonicity property of the greatest justified checkpoint.
\end{proof}

\begin{lemma}%[Replacement for \Cref{lem:conf-prev-epoch-then-vs-two-epochs-ago-old}]
    \label{lem:conf-prev-epoch-then-vs-two-epochs-ago}
     \label{lem:vs-at-least-e-2}
    Pick any $b_c \in  \var[val=v,time=\slotstart(\slot(t))]{\bcands}$.
    If
    \begin{enumerate}
        \item $\slotstart(\lastslot(\epoch(t)-1)) \geq \GST$
        \item $\epoch(b_c) \geq \epoch(t)-1$
    \end{enumerate},
    then, there exists an honest validator $v'$ such that
    \begin{enumerate}
        \item $\exists b' \in \left(\viewattime[time=\votingtime(\slot(t)-1),val=v'] \cap \viewattime[time=\slotstart(\slot(t)),val=v]\right), b' \succeq b_c \land \epoch(\votsource[blck=b',time=\slotstartslot{t}])\geq \epoch(t)-2$
        % \item $\banchor^{v,\slotstart(\slot(t))} \succeq GJ^{v,t}$
    \end{enumerate}
\end{lemma}

\begin{proof}
    Let $s := \slot(t)$.
    \begin{description}
        \item[Case 1: {$\epoch(b_c) = \epoch(s)-1$}.] Apply \Cref{lem:bcand-prev-epoch-vs-at-least-e-2}.
        \item[Case 2: {$\epoch(b_c) \neq \epoch(s)-1$}.] The Lemma's statement implies $\epoch(b_c) = \epoch(s)$ for this case.
        Due to \Cref{ln:if-is-one-confirmed-second-loop,set-btcand-to-btemp}, $\isOneConfirmed(b_c, \cdot)$ which implies\MKfn{We probably should have a Lemma proving such an implication} that there exists an honest validator $v^h$ such that
        $b_c \preceq \LMDGHOSTHFC(\viewattime[val=v^h,time=\votingtime(s')])$ for $s'<s$ which implies $b_c \in \filtered[val=v^h,time=\votingtime(s')]$ . Given that $\epoch(b_c) = \epoch(s)$ and the fact that honest validators never vote for blocks from the future slots, we conclude that $\epoch(s') = \epoch(s)$.
        Then due to \Cref{lem:gj-at-least-e-2-alt} we know that $\epoch(\gjattime[val=v^h,time=\votingtime(s')]) \geq \epoch(s)-2$.
        Given that $b_c \in \filtered[val=v^h,time=\votingtime(s')]$, it must be true that $\exists b' \in \viewattime[val=v^h,time=\votingtime(s')]$ such that $b' \succeq b_c$ and one of the following conditions hold:
        \begin{enumerate}
            \item $\epoch(\votsource[blck=b',time=\slotstart(s)]) = \epoch(\gjattime[val=v^h,time=\votingtime(s')]) \geq \epoch(s)-2$
            \item $\epoch(\votsource[blck=b',time=\slotstart(s)]) \geq \epoch(s)-2$
        \end{enumerate}
        In either case $\epoch(\votsource[blck=b',time=\slotstart(s)]) \geq \epoch(s)-2$.
        Then the fact that $\viewattime[val=v^h,time=\votingtime(s')] \subseteq \viewattime[val=v^h,time=\votingtime(s-1)] \subseteq \viewattime[val=v^h, time=\slotstart(s)]$ concludes the proof.
    \end{description}
\end{proof}

% \begin{lemma}%[Replacement for \Cref{lem:conf-prev-epoch-then-vs-two-epochs-ago-old}]
%     \label{lem:conf-prev-epoch-then-vs-two-epochs-ago}
%      \label{lem:vs-at-least-e-2}
%     Pick any $b_c \in  \var[val=v,time=\slotstart(\slot(t))]{\bcands}$.
%     If
%     \begin{enumerate}
%         \item $\epoch(b_c) \geq \epoch(t)-1$
%         % \item $\var[val=v,time=\slotstart()]{}
%     \end{enumerate},
%     then, 
%     \begin{enumerate}
%         \item $\exists b' \in \viewattime[time=\slotstart(\slot(t)),val=v], b' \succeq  b_c \land \epoch(\votsource[blck=b',time=\slotstartslot{t}])\geq \epoch(t)-2$
%         % \item $\banchor^{v,\slotstart(\slot(t))} \succeq GJ^{v,t}$
%     \end{enumerate}
% \end{lemma}

% \begin{proof}
%     By induction on $\slot(t)$.
%     Let $s := \slot(t)$.
%     \begin{description}
%         \item[Base Case: {$s = \slot(\var[val=v]{\tinit})$}.] The Lemma is vacuously true.
%         \item[Inductive Case: {$s \geq \slot(\var[val=v]{\tinit})$}.] We assume that the Lemma holds for $s$ and prove that it also holds for $s+1$.
%         We also assume that $\epoch(b_c) \geq \epoch(s+1)-1$ as the Lemma holds vacuously otherwise.
%         \begin{description}
%             \item[Case 1: {$\epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed}) < \epoch(s+1)-1$}.] Apply  \Cref{lem:when-restarting-vs-from-prev-epoch}.
%             \item[Case 2: {$\epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed}) \geq \epoch(s+1)-1$}.]
%             % To prove the Lemma is sufficient 
%             By sub cases.
%             \begin{description}
%                 \item[Case 2.1: {$b_c = \var[val=v,time=\slotstart(s)]{\bconfirmed}$}.] 
%                 By sub cases again.
%                 \begin{description}
%                     \item[Case 2.1.1: $\epoch(s+1) = \epoch(s).$] 
%                     Given that $\var[val=v,time=\slotstart(s)]{\bconfirmed} \in \var[val=v,time=\slotstart(s)]{\bcands}$,
%                     we can apply the inductive hypothesis to conclude that  $\exists b' \in \viewattime[time=\slotstart(s),val=v], b' \succeq b_c \land \epoch(\votsource[blck=b',time=\slotstart(s)])\geq \epoch(s)-2 = \epoch(s+1)-2$.
%                     So, given that $\viewattime[time=\slotstart(s),val=v'] \subseteq \viewattime[time=\slotstart(s+1),val=v']$, the proof for this case is concluded.
%                     \item[Case 2.1.2: $\epoch(s+1) = \epoch(s) + 1.$]
%                     This Case implies that $\epoch(b_c) = \epoch(s)$ as 
%                     $\epoch(s) = \epoch(s+1) -1 \leq \epoch(b_c) < \epoch(s+1) = \epoch(s) + 1$.
%                     Note also that  $\epoch(s+1) = \epoch(s) + 1$ implies that $s+1 = \firstslot(\epoch(s+1))$.
%                     All of this together with  \Cref{lem:conf-current-epoch-then-gu-curr-epoch} implies that $\exists b' \in \viewattime[time=\slotstart(s),val=v] \subseteq \viewattime[time=\slotstart(s+1),val=v], \epoch(\votsource[blck=b',time=\slotstart(s+1)])\geq \epoch(\gu(b')) \geq \epoch(s)-1\geq\epoch(s+1)-2$.
%                 \end{description}
%                 \item[Case 2.2: {$b_c \neq \var[val=v,time=\slotstart(s)]{\bconfirmed}$}.]
%                 Now by cases on the first line, in order of execution of the Fast Confirmation Rule algorithm at time $\slotstart(s+1)$, where $\bcand = b_c$. 
%                 \begin{description}
%                     \item[\Cref{ln:set-bcand-beginning-of-get-latest-confirmed}.] 
%                     Impossible, as at this line $\bcand = b_c$, but $b_c \neq \var[val=v,time=\slotstart(s)]{\bconfirmed}$.
%                     \item[\Cref{ln:set-bcand-to-fin}.] Impossible, as at this line $\epoch(\bcand) < \epoch(s+1)-1$, but we assume $\epoch(b_c) \geq \epoch(s+1)-1$.
%                     \item[\Cref{ln:set-bcan-on-start-conf-chain}.] Obvious. \RSfn{Perhaps explain a bit more why in the future.} 
%                     \item[\Cref{ln:set-bcand-to-output-find-latest}.] Obvious from \Cref{lem:output-find-latest-different-to-input}.
%                 \end{description}
%             \end{description}
%         \end{description}
%     \end{description}
% \end{proof}


% \begin{lemma}%[Replacement for \Cref{lem:conf-prev-epoch-then-vs-two-epochs-ago-old}]
%     %\label{lem:conf-prev-epoch-then-vs-two-epochs-ago}
%     If
%     \begin{enumerate}
%         \item $\epoch(\var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}) \geq \epoch(t)-1$
%     \end{enumerate},
%     then, there exists an honest validator $v'$ such taht
%     \begin{enumerate}
%         \item $\exists b' \in \viewattime[time=\slotstart(\slot(t)-1),val=v'], b' \succeq  \bconfirmed[val=v,time=\slotstart(\slot(t))] \land \epoch(\votsource[blck=b',time=\slotstartslot{t}])\geq \epoch(t)-2$
%         % \item $\banchor^{v,\slotstart(\slot(t))} \succeq GJ^{v,t}$
%     \end{enumerate}
% \end{lemma}

% \begin{proof}
%     By induction on $\slot(t)$.
%     Let $s := \slot(t)$.
%     \begin{description}
%         \item[Base Case: {$s = \slot(\var[val=v]{\tinit})$}.] The Lemma is vacuously true.
%         \item[Inductive Case: {$s \geq \slot(\var[val=v]{\tinit})$}.] We assume that the Lemma holds for $s$ and prove that it also holds for $s+1$.
%         We also assume that $\epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed}) \geq \epoch(s+1)-1$ as the Lemma holds vacuously otherwise.
%         % This implies that $\epoch(s+1) = \epoch(s)$ as, otherwise, it would mean that we are the beginning of epoch $\epoch(s)+1$ and, therefore, it cannot be that $\epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed}) = \epoch(s+1)$ reaching a contradiction.
%         \begin{description}
%             \item[{Case 1: $\epoch(\var[val=v,time=\slotstart(s-1)]{\bconfirmed}) < \epoch(s)-1$}.] Follows from \Cref{lem:when-restarting-vs-from-prev-epoch}.
%             \item[{Case 2: $\epoch(\var[val=v,time=\slotstart(s-1)]{\bconfirmed}) \geq \epoch(s)-1$}] 
%             By the inductive hypothesis, we know that there exists an honest validator $v'$ such that $\exists b' \in \viewattime[time=\slotstart(s-1),val=v'], b' \succeq \var[val=v,time=\slotstart(s)]{\bconfirmed} \land \epoch(\votsource[blck=b',time=\slotstart(s)])\geq \epoch(s)-2$.
%             Clearly $b' \in \viewattime[time=\slotstart(s),val=v']$.
%             By cases again
%             \begin{description}
%                 \item[Case 2.1: $\epoch(s+1) = \epoch(s)$.]  Then $\epoch(\votsource[blck=b',time=\slotstart(s+1)])\geq\epoch(\votsource[blck=b',time=\slotstart(s)])\geq \epoch(s)-2 = \epoch(s+1)-2$.
%                 \item[Case 2.2: $\epoch(s+1) = \epoch(s) + 1$.] From our assumption above, $\epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed}) \geq \epoch(s+1)-1 = \epoch(s)$.
%                 Given that $\epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed}) \leq \epoch(s)$, we can conclude that $\epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed})= \epoch(s)$.
%                 Note also that  $\epoch(s+1) = \epoch(s) + 1$ implies that $s+1 = \firstslot(\epoch(s+1))$.
%                 All of this together with  \Cref{lem:conf-current-epoch-then-gu-curr-epoch} implies that $\exists b' \in \viewattime[time=\slotstart(s-1),val=v], \epoch(\votsource[blck=b',time=\slotstart(s)])\geq \epoch(s)-1\geq\epoch(s+1)-2$.
%             \end{description}
%         \end{description}
%     \end{description}
% \end{proof}

% \begin{proof}
%     By induction on $\slot(t)$.
%     Let $s := \slot(t)$.
%     \begin{description}
%         \item[Base Case: {$s = \slot(\var[val=v]{\tinit})$}.] The Lemma is vacuously true.
%         \item[Inductive Case: {$s \geq \slot(\var[val=v]{\tinit})$}.] We assume that the Lemma holds for $s$ and prove that it also holds for $s+1$.
%         We also assume that $\epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed}) \geq \epoch(s+1)-1$ as the Lemma holds vacuously otherwise.
%         % This implies that $\epoch(s+1) = \epoch(s)$ as, otherwise, it would mean that we are the beginning of epoch $\epoch(s)+1$ and, therefore, it cannot be that $\epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed}) = \epoch(s+1)$ reaching a contradiction.
%         \begin{description}
%             \item[{Case 1: $\epoch(\var[val=v,time=\slotstart(s-1)]{\bconfirmed}) < \epoch(s)-1$}.] Follows from \Cref{lem:when-restarting-vs-from-prev-epoch}.
%             \item[{Case 2: $\epoch(\var[val=v,time=\slotstart(s-1)]{\bconfirmed}) \geq \epoch(s)-1$}] 
%             By the inductive hypothesis, we know that $\exists b' \in \viewattime[time=\slotstart(s-1),val=v], \epoch(\votsource[blck=b',time=\slotstart(s)])\geq \epoch(s)-2$.
%             By cases again
%             \begin{description}
%                 \item[Case 2.1: $\epoch(s+1) = \epoch(s)$.]  Then $\epoch(\votsource[blck=b',time=\slotstart(s+1)])\geq\epoch(\votsource[blck=b',time=\slotstart(s)])\geq \epoch(s)-2 = \epoch(s+1)-2$.
%                 \item[Case 2.2: $\epoch(s+1) = \epoch(s) + 1$.] From our assumption above, $\epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed}) \geq \epoch(s+1)-1 = \epoch(s)$.
%                 Given that $\epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed}) \leq \epoch(s)$, we can conclude that $\epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed})= \epoch(s)$.
%                 Note also that  $\epoch(s+1) = \epoch(s) + 1$ implies that $s+1 = \firstslot(\epoch(s+1))$.
%                 All of this together with  \Cref{lem:conf-current-epoch-then-gu-curr-epoch} implies that $\exists b' \in \viewattime[time=\slotstart(s-1),val=v], \epoch(\votsource[blck=b',time=\slotstart(s)])\geq \epoch(s)-1\geq\epoch(s+1)-2$.
%             \end{description}
%         \end{description}
%     \end{description}
% \end{proof}

% \begin{lemma}\label{lem:conf-prev-epoch-then-gj-two-epochs-ago}
%     If
%     \begin{enumerate}
%         \item $\epoch(\var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}) \geq \epoch(t)-1$
%     \end{enumerate},
%     then
%     \begin{enumerate}
%         \item $\epoch(\gjattime[val=v,time=\slotstart(\slot(t))]) \geq \epoch(t)-2$
%         % \item $\banchor^{v,\slotstart(\slot(t))} \succeq GJ^{v,t}$
%     \end{enumerate}
% \end{lemma}

% \begin{proof}
%     By induction on $\slot(t)$.
%     Let $s := \slot(t)$.
%     \begin{description}
%         \item[Base Case: {$s = \slot(\var[val=v]{\tinit})$}.] The Lemma is vacuously true.
%         \item[Inductive Case: {$s \geq \slot(\var[val=v]{\tinit})$}.] We assume that the Lemma holds for $s$ and prove that it also holds for $s+1$.
%         We also assume that $\epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed}) \geq \epoch(s+1)-1$ as the Lemma holds vacuously otherwise.
%         % This implies that $\epoch(s+1) = \epoch(s)$ as, otherwise, it would mean that we are the beginning of epoch $\epoch(s)+1$ and, therefore, it cannot be that $\epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed}) = \epoch(s+1)$ reaching a contradiction.
%         \begin{description}
%             \item[{Case 1: $\epoch(\var[val=v,time=\slotstart(s-1)]{\bconfirmed}) < \epoch(s)-1$}.] Given that we assume that $\epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed} ) \geq \epoch(s)-1$, it must be that we restart ``confirmation chain'' at time $\slotstart(s)$. 
%             Therefore $s = \firstslot(\epoch(s))$ and we know that $\epoch(\gjattime[time=\slotstart(s),val=v])=\epoch(s)-1$.
%             This means that we know $\epoch(\gjattime[time=\slotstart(s+1),val=v])\geq\epoch(\gjattime[time=\slotstart(s),val=v])\geq\epoch(s)-1=\epoch(s+1)-1$.
%             \item[{Case 2: $\epoch(\var[val=v,time=\slotstart(s-1)]{\bconfirmed}) \geq \epoch(s)-1$}] 
%             By the induction hypothesis, we know that $\epoch(\gjattime[time=\slotstart(s),val=v]) \geq \epoch(s)-2$.
%             By cases again
%             \begin{description}
%                 \item[Case 2.1: $\epoch(s+1) = \epoch(s)$.]  Then $\epoch(\gjattime[time=\slotstart(s+1),val=v])\geq\epoch(\gjattime[time=\slotstart(s),val=v])\geq \epoch(s)-2 = \epoch(s+1)-2$.
%                 \item[Case 2.2: $\epoch(s+1) = \epoch(s) + 1$.] From our assumption above, $\epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed}) \geq \epoch(s+1)-1 = \epoch(s)$.
%                 Given that $\epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed}) \leq \epoch(s)$, we can conclude that $\epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed})= \epoch(s)$.
%                 Note also that  $\epoch(s+1) = \epoch(s) + 1$ implies that $s+1 = \firstslot(\epoch(s+1))$.
%                 All of this together with  \Cref{lem:current-epoch-then-gu-curr-epoch} implies that $\epoch(\gjattime[val=v,time=\slotstart(s+1)]) \geq \epoch(s)-1 = \epoch(s+1)-2$.
%             \end{description}
%         \end{description}
%     \end{description}
% \end{proof}

% \begin{proof}(Sketch)
%     By induction on $\slot(t)$.
%     Let $s := \slot(t)$.
%     \begin{description}
%         \item[{Base Case: $\var[val=v,time=\slotstart(s-1)]{\bconfirmed} = \block(\gfattime[time=\slotstart(s-1),val=v])$.}] Clearly, $\epoch(\var[val=v,time=\slotstart(s-1)]{\bconfirmed} ) < \epoch(t) -1$. Assume then that $\epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed} ) \geq \epoch(t)-1$.
%         This means that we restart the confirmation chain, which means that we know that $\epoch(\gjattime[time=\slotstart(s+1),val=v])=\epoch(t)=\epoch(s+1)-1$.
%         \item[Inductive Case.] 
%         We assume the Lemma holds for slot $s$ and prove that it also holds for slot $s+1$.
%         We also assume $\epoch(\var[val=v,time=\slotstart(s+1)]{\bconfirmed}) \geq \epoch(s+1)-1$  as the Lemma holds vacuously otherwise. 
%         Now, by cases.
%         \begin{description}
%             \item[{Case 1: $\epoch(\var[val=v,time=\slotstart(s-1)]{\bconfirmed}) < \epoch(s)-1$}] Same reasoning as for the base case.
%             \item[{Case 2: $\epoch(\var[val=v,time=\slotstart(s-1)]{\bconfirmed}) \geq \epoch(s)-1$}] 
%             By the induction hypothesis, we know that $\epoch(\gjattime[time=\slotstart(s),val=v]) \geq \epoch(s)-2$.
%             By cases again
%             \begin{description}
%                 \item[Case 2.1: $\epoch(s+1) = \epoch(s)$.]  Then $\epoch(\gjattime[time=\slotstart(s+1),val=v])\geq\epoch(\gjattime[time=\slotstart(s),val=v])\geq \epoch(s)-2 = \epoch(s+1)-2$.
%                 \item[Case 2.2: $\epoch(s+1) = \epoch(s) + 1$.] This implies that  $\epoch(\var[val=v,time=\slotstart(s+1)]{\bconfirmed}) = \epoch(s)$ as we are at the beginning of epoch $\epoch(s+1)$ so we cannot confirm any block from epoch $\epoch(s+1)$.
%             \end{description}
%         \end{description}
%     \end{description}
%     We prove the following equivalent statement inductively.
%     If $\epoch(\var[val=v,time=\slotstartslot{t}]{\isOneConfirmed}) \geq \epoch(s+1)-1$,
%     then $\epoch(\gjattime[val=v,time=\slotstart(s+1)]) \geq \epoch(s+1)-2$.

% \end{proof}

% \begin{lemma}\label{lem:vs-at-least-e-2-old}
%     If
%     \begin{enumerate}
%         \item $\epoch(\var[val=v,time=\slotstartslot{t}]{\bcand}) \geq \epoch(t)-1$
%     \end{enumerate},
%     then
%     \begin{enumerate}
%         \item $\exists b' \in \viewattime[time=\slotstart(\slot(t)-1),val=v], \epoch(\votsource[blck=b',time=\slotstartslot{t}])\geq \epoch(t)-2$
%         % \item $\banchor^{v,\slotstart(\slot(t))} \succeq GJ^{v,t}$
%     \end{enumerate}
% \end{lemma}


% \begin{lemma}%[Replacement of \Cref{lem:vs-at-least-e-2-old}]
%     \label{lem:vs-at-least-e-2}
%     If
%     \begin{enumerate}
%         \item $\epoch(\var[val=v,time=\slotstartslot{t}]{\bcand}) \geq \epoch(t)-1$
%     \end{enumerate},
%     then
%     \begin{enumerate}
%         \item $\exists b' \in \viewattime[time=\slotstart(\slot(t)-1),val=v], b' \succeq \var[val=v,time=\slotstartslot{t}]{\bcand} \land \epoch(\votsource[blck=b',time=\slotstartslot{t}])\geq \epoch(t)-2$
%         % \item $\banchor^{v,\slotstart(\slot(t))} \succeq GJ^{v,t}$
%     \end{enumerate}
% \end{lemma}

% \begin{proof}
%     TBD
% \end{proof}


% \begin{proof}
% By cases.
% \begin{description}
%     \item[Case 1: {$\epoch(\var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}) \geq \epoch(s)-1$}.] Follows from \Cref{lem:conf-prev-epoch-then-vs-two-epochs-ago}.
%     \item[Case 2: {$\epoch(\var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}) < \epoch(s)-1$}.] 
%     From $\epoch(\var[val=v,time=\slotstartslot{t}]{\bcand}) \geq \epoch(t)-1$, we can conclude that  $\epoch(\var[val=v,time=\slotstartslot{t}]{\bconfirmed}) \geq \epoch(t)-1$.
%     Then, apply \Cref{lem:when-restarting-vs-from-prev-epoch}.
% \end{description}
% \end{proof}

% \begin{lemma}
%     Let $\var[val=v,time=\slotstartslot{t}]{\bcand}$ be any of the possible values assumed by $\bcand$ during the execution of \Cref{alg:conffull} by validator $v$ at time $\slotstartslot{t}$
%     If
%     \begin{enumerate}
%         \item $\epoch(\var[val=v,time=\slotstartslot{t}]{\bcand}) \geq \epoch(t)-1$
%     \end{enumerate},
%     then
%     \begin{enumerate}
%         \item $\epoch(\gjattime[val=v,time=\slotstart(\slot(t))]) \geq \epoch(t)-2$
%         % \item $\banchor^{v,\slotstart(\slot(t))} \succeq GJ^{v,t}$
%     \end{enumerate}
% \end{lemma}

% \begin{proof}(Sketch)
% \begin{description}
%     \item[Case 1: {$\epoch(\var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}) \geq \epoch(s)-1$}.] Follows from \Cref{lem:conf-prev-epoch-then-gj-two-epochs-ago}.
%     \item[Case 2: {$\epoch(\var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}) < \epoch(s)-1$}.] 
%     Assume that  $\epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed} ) \geq \epoch(s)-1$ as, otherwise, the Lemma holds vacuously.
%     Then, it must be that we restart ``confirmation chain'' at time $\slotstart(s)$. 
%     Therefore $s = \firstslot(\epoch(s))$ and we know that $\epoch(\gjattime[time=\slotstart(s),val=v])=\epoch(s)-1$.
% \end{description}
% \end{proof}

% \begin{lemma}\label{lem:no-conflict-chkp-is-justified}
%     % Take an honest validator $v$ and a time $t$.
%     Pick any $b_c \in  \var[val=v,time=\slotstart(\slot(t))]{\bcands}$.
%     If
%     \begin{enumerate}
%         % \item $\slotstart(\epoch(t)-1) \geq \GST$
%         \item $\epoch(b_c) \geq \epoch(t) - 1$
%     \end{enumerate},
%     then at least one of the following statements hold:
%     \begin{enumerate}
%         \item $\gjattime[time=\slotstartslot{t},val=v] = \chkp(b_c)$
%         \item there exists a time $t' \leq t$ such that
%         \begin{enumerate}
%             \item $t' = \slotstartslot{t'}$
%             \item $\epoch(t') = \epoch(b_c)$
%             \item $\var[val=v,time=t']{\willChkpBeJustified}(\chkp(b_c))$
%         \end{enumerate}
%     \end{enumerate}
% \end{lemma}

% \begin{proof}(by Roberto)
%     By induction on $\slot(t)$.
%     Let $s := \slot(t)$.
%     \begin{description}
%         \item[Base Case: {$s = \slot(\var[val=v]{\tinit})$}.] The Lemma is vacuously true.
%         \item[Inductive Case: {$s \geq \slot(\var[val=v]{\tinit})$}.]
%             We assume that the Lemma holds for $s$ and prove that it also holds for $s+1$.
%         \begin{description}
%             \item[{Case 1: $\epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed}) < \epoch(s+1) - 1$}.]
%                 We assume condition at \Cref{ln:start-conf-chain} holds, otherwise,
%                 $\var[val=v,time=\slotstartslot{s+1}]{\bcand} < \epoch(s+1) - 1$ and the Lemma is vacuously true.
%                 That condition implies $\gjattime[val=v,time=\slotstart(s+1)] = \guattime[val=v,time=\slotstart(s)]$,
%                 $\var[val=v,time=\slotstart(s+1)]{\bcand} \succeq \block(\guattime[val=v,time=\slotstart(s)]) = \block(\gjattime[val=v,time=\slotstart(s+1)])$,
%                 $\epoch(\var[val=v,time=\slotstart(s+1)]{\bcand}) = \epoch(s+1)-1$.
%                 Thus, $\gjattime[val=v,time=\slotstart(s+1)] = \chkp(\var[val=v,time=\slotstart(s+1)]{\bcand},\epoch(s+1)-1)$
%                 concluding Statement 1 of the Lemma.
%             \item[Case 2: {$\epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed}) \geq \epoch(s+1) - 1$}.]
%             Clearly $\epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed}) \geq \epoch(s) - 1$, so the inductive hypothesis holds non-vacuously for $s$.
%             By sub-cases.
%             \begin{description} 
%                 \item[Case 2.1: {$\epoch(\var[val=v,time=\slotstart(s+1)]{\bcand}) = \epoch(\var[val=v,time=\slotstart(s)]{\bcand})$}.] 
%                 This implies that $\chkp(\var[val=v,time=\slotstart(s+1)]{\bcand}) = \chkp(\var[val=v,time=\slotstart(s)]{\bcand})$.
%                 \sloppy{Note that if $\gjattime[time=\slotstartslot{t},val=v] = \chkp(\var[val=v,time=\slotstartslot{t}]{\bcand})$, then $\var[val=v,time=\slotstartslot{t}]{\willChkpBeJustified}(\chkp(\var[val=v,time=\slotstartslot{t}]{\bcand}))$.}
%                 Then, the rest follows from the inductive hypothesis.
%                 \item[Case 2.2: {$\epoch(\var[val=v,time=\slotstart(s+1)]{\bcand}) = \epoch(\var[val=v,time=\slotstart(s)]{\bcand}) + 1$}.] 
%                 Given that $\epoch(\var[val=v,time=\slotstart(s+1)]{\bcand}) \leq \epoch(s+1)$, this implies that $\epoch(\var[val=v,time=\slotstart(s+1)]{\bcand}) = \epoch(s+1)$.
%                 Then, it must be that the \KwSty{if} blocks at line 23 is executed proving the lemma.
%             \end{description}
%         \end{description}
%     \end{description}
% \end{proof}

% \begin{lemma}\label{lem:no-conflict-chkp-is-justified}
%     Take an honest validator $v$ and a time $t$.
%     If
%     \begin{enumerate}
%         % \item $\slotstart(\epoch(t)-1) \geq \GST$
%         \item $\epoch(\var[val=v,time=\slotstartslot{t}]{\bcand}) \geq \epoch(t) - 1$
%     \end{enumerate},
%     then at least one of the following statements hold:
%     \begin{enumerate}
%         \item $\gjattime[time=\slotstartslot{t},val=v] = \chkp(\var[val=v,time=\slotstartslot{t}]{\bcand})$
%         \item there exists a time $t' \leq t$ such that
%         \begin{enumerate}
%             \item $t' = \slotstartslot{t'}$
%             \item $\epoch(t') = \epoch(\var[val=v,time=\slotstartslot{t}]{\bcand})$
%             \item $\var[val=v,time=t']{\willChkpBeJustified}(\chkp(\var[val=v,time=\slotstartslot{t}]{\bcand}))$
%         \end{enumerate}
%     \end{enumerate}
% \end{lemma}

% \begin{proof}(by Roberto)
%     By induction on $\slot(t)$.
%     Let $s := \slot(t)$.
%     \begin{description}
%         \item[Base Case: {$s = \slot(\var[val=v]{\tinit})$}.] The Lemma is vacuously true.
%         \item[Inductive Case: {$s \geq \slot(\var[val=v]{\tinit})$}.]
%             We assume that the Lemma holds for $s$ and prove that it also holds for $s+1$.
%         \begin{description}
%             \item[{Case 1: $\epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed}) < \epoch(s+1) - 1$}.]
%                 We assume condition in line 14 of \Cref{alg:conffull} holds, otherwise,
%                 $\var[val=v,time=\slotstartslot{s+1}]{\bcand} < \epoch(s+1) - 1$ and the Lemma is vacuously true.
%                 That condition implies $\gjattime[val=v,time=\slotstart(s+1)] = \guattime[val=v,time=\slotstart(s)]$,
%                 $\var[val=v,time=\slotstart(s+1)]{\bcand} \succeq \block(\guattime[val=v,time=\slotstart(s)]) = \block(\gjattime[val=v,time=\slotstart(s+1)])$,
%                 $\epoch(\var[val=v,time=\slotstart(s+1)]{\bcand}) = \epoch(s+1)-1$.
%                 Thus, $\gjattime[val=v,time=\slotstart(s+1)] = \chkp(\var[val=v,time=\slotstart(s+1)]{\bcand},\epoch(s+1)-1)$
%                 concluding Statement 1 of the Lemma.
%             \item[Case 2: {$\epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed}) \geq \epoch(s+1) - 1$}.]
%             Clearly $\epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed}) \geq \epoch(s) - 1$, so the inductive hypothesis holds non-vacuously for $s$.
%             By sub-cases.
%             \begin{description} 
%                 \item[Case 2.1: {$\epoch(\var[val=v,time=\slotstart(s+1)]{\bcand}) = \epoch(\var[val=v,time=\slotstart(s)]{\bcand})$}.] 
%                 This implies that $\chkp(\var[val=v,time=\slotstart(s+1)]{\bcand}) = \chkp(\var[val=v,time=\slotstart(s)]{\bcand})$.
%                 \sloppy{Note that if $\gjattime[time=\slotstartslot{t},val=v] = \chkp(\var[val=v,time=\slotstartslot{t}]{\bcand})$, then $\var[val=v,time=\slotstartslot{t}]{\willChkpBeJustified}(\chkp(\var[val=v,time=\slotstartslot{t}]{\bcand}))$.}
%                 Then, the rest follows from the inductive hypothesis.
%                 \item[Case 2.2: {$\epoch(\var[val=v,time=\slotstart(s+1)]{\bcand}) = \epoch(\var[val=v,time=\slotstart(s)]{\bcand}) + 1$}.] 
%                 Given that $\epoch(\var[val=v,time=\slotstart(s+1)]{\bcand}) \leq \epoch(s+1)$, this implies that $\epoch(\var[val=v,time=\slotstart(s+1)]{\bcand}) = \epoch(s+1)$.
%                 Then, it must be that the \KwSty{if} blocks at line 23 is executed proving the lemma.
%             \end{description}
%         \end{description}
%     \end{description}
% \end{proof}







\begin{lemma}\label{lem:no-curr-epochconflict-chkp-is-justified}
    Pick any $b_c \in  \var[val=v,time=\slotstart(\slot(t))]{\bcands}$.
    % Take an honest validator $v$ and a time $t$.
    If
    \begin{enumerate}
        % \item $\slotstart(\epoch(t)-1) \geq \GST$
        \item $\epoch(b_c) = \epoch(t)$
    \end{enumerate},
    then,\
    \begin{enumerate}
        % \item $\gjattime[time=\slotstartslot{t},val=v] = \chkp(b_c,\epoch(t) - 1)$
        \item there exists a time $t' \leq t$ such that
        \begin{enumerate}
            \item $t' = \slotstartslot{t'}$
            \item $\epoch(t') = \epoch(t)$
            \item $\var[val=v,time=t']{\willChkpBeJustified}(\chkp(b_c))$
        \end{enumerate}
    \end{enumerate}
\end{lemma}

\begin{proof}
    By induction on $\slot(t)$.
    Let $s := \slot(t)$.
    \begin{description}
        \item[Base Case: {$s = \slot(\var[val=v]{\tinit})$}.] The Lemma is vacuously true.
        \item[Inductive Case: {$s \geq \slot(\var[val=v]{\tinit})$}.]
            We assume that the Lemma holds for $s$ and prove that it also holds for $s+1$.
            Pick any $b_c \in \var[val=v,time=\slotstart(s+1)]{\bcands}$ such that $\epoch(b_c) = \epoch(s+1)$.
            This implies $s+1 \neq \firstslot(\epoch(s+1))$ and therfore $\epoch(s) = \epoch(s+1)$.
            By cases.
            \begin{description}
                \item[Case 1: {$\epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed}) = \epoch(s)$}.] 
                % This implies that $s \neq \firstslot(\epoch(s))$.
                \Cref{lem:prev-conf-at-least-e-1} implies that $\var[val=v,time=\slotstart(s)]{\bconfirmed} \preceq \LMDGHOSTHFC(\viewattime[val=v,time=\slotstart(s+1)])$.
                This implies that $b_c \succeq \var[val=v,time=\slotstart(s)]{\bconfirmed}$.
                Given that $\epoch(b_c) = \epoch(s) = \epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed})$, $\chkp(b_c) = \chkp(\var[val=v,time=\slotstart(s)]{\bconfirmed})$.
                Then apply the inductive hypothesis.
                \item[Case 2: {$\epoch(\var[val=v,time=\slotstart(s)]{\bconfirmed}) < \epoch(s)$}.] 
                Given that $\epoch(b_c) = \epoch(s+1)$, condition at line \Cref{ln:check-will-chkp-be-justified} must be true for a $\btemp = b'$ such that $b' \preceq b_c \land \epoch(b') = \epoch(b_c)$.
                Hence, $\chkp(b') = \chkp(b_c)$.
                This implies that $\var[val=v,time=\slotstart(s+1)]{\willChkpBeJustified}(\chkp(b_c))$.
            \end{description}
    \end{description}
\end{proof}


\begin{definition}[\LMDGHOST safety condition]
    The \LMDGHOST safety condition for block $b$ according to checkpoint $C$ and the view of validator $v$ at time $t\geq\GGST$ starting from block $b_mathsf{s}$, corresponds to the following condition, formally named $\var[val=v]{\mathrm{isLMDGHOSTSafe}}(b,C,t)$.
    $$
\begin{aligned}
        \var[val=v]{\mathrm{isLMDGHOSTSafeFrom}}(b,C,t,b_\mathsf{s}) := &b \succeq b_\mathsf{s} \land \\
        &\forall b',\; b_\mathsf{s} \preceq b' \preceq b \implies
                \indicatorfromblock[from=b',to=\slot(t)-1,val=v,when=t,chkp=C]{\indQ}
                >
                    \frac{1}{2}
                        \left( 1+
                            \frac
                            {\boostweight[chkp=C]}
                            {\commweightfromblock[from=b',to=\slot(t)-1,chkp=C,when=t,val=v]{\allvals}}
                        \right)
                    + \beta  
\end{aligned}   
                $$
\end{definition}

\begin{definition}[\safetyinductionrequirement{s}  for blocks $b$ and $b_\mathsf{s}$, time $t$ and checkpoint $C$ ]\label{def:induction-conditions}
    $\sir(b,t,C,b_\mathsf{s})$ is difined as the conjuction of $\sirone(b,t,C,b_\mathsf{s})$, $\sirtwo(b,t,\slotstart(\epoch(b)+2))$, $\sirthree(C,t,\slotstart(\epoch(b)+2))$, $\sirfour(b)$ and $\sirfive(b, \epoch(b),\epoch(b)+1)$ as defined below.
    \begin{enumerate}[label=SIR.\arabic*.,leftmargin=20ex,ref=SIR.\arabic*]
        \siritem{$(b,t,C,b_\mathsf{s})$}
        \label{def:induction-conditions:is-lmd-confirmed}  $\var[val=v]{\mathit{isLMDGHOSTSafeFrom}}(b,C,t,b_\mathsf{s})  \land C \preceq b  \land \slotstart(\slot(t)-1)\geq \GGST$
        % \item\label{def:induction-conditions:gst}  $$
        % \item\label{def:induction-conditions:all-validators} for any honest validator $v'$ and time $t'$ such that $t \leq t' \leq \slotstart(\epoch(b)+2)$,
        % \begin{enumerate}[label=\theenumi.\arabic*.,leftmargin=10ex,ref=\theenumi.\arabic*]
            \siritem{$(b,t,t_\ell)$}
            \label{def:induction-conditions:all-validators:not-filtered-out} for any honest validator $v'$ and time $t' \in [t,t_\ell]$, $b$ is not filtered out by validator $v'$ at time $t'$, \ie, $b \in \filtered[time=t',val=v']$
            \siritem{$(C,t,t_\ell)$}
            \label{def:induction-conditions:all-validators:gj-succ} for any honest validator $v'$ and time $t' \in [t,t_\ell]$, $\gjattime[time=t',val=v']\succeq C$
            % \item\label{def:induction-conditions:all-validators:gj-succ-cs} $\gjattime[time=t',val=v'] \succeq C_\mathsf{s}$
            % \item\label{def:induction-conditions:all-validators:gj-succ-cs} $b_\mathsf{s} \preceq  \LMDGHOSTHFC(\viewattime[val=v',time=t'])$
        % \end{enumerate}
        % \item\label{def:induction-conditions:ub} by time $\slotstart(\firstslot(\epoch(b)+2))$, in the view of any honest node there exists a block $b' \succeq b$  such that $\chkp(b) \in \allU(b') \land \epoch(b') < \epoch(b)+2$.
        \siritem{$(b)$}
        \label{def:induction-conditions:ub} by time $\slotstart(\firstslot(\epoch(b)+2))$, in the view of any honest node there exists a block $b' \succeq b$ and checkpoint $C \succeq b$ such that $C \in \allU(b') \land \epoch(b') < \epoch(b)+2$.
        \siritem{$(b,e_1,e_2)$}
        \label{def:induction-conditions:no-conflicting} no checkpoint $C$ with $\epoch(C) \in [e_1,e_2]$ which conflicts with $b$ can ever be justified.
    \end{enumerate}
    We also write $\sir(b,t,C,b_\mathsf{s}).\sir n$ to mean the $\sir n(\mathit{args})$ conjunct of $\sir(b,t,C,b_\mathsf{s})$ where the arguments $\mathit{args}$ as per the definition of $\sir(b,t,C,b_\mathsf{s})$.

    For example, $\sir(b,t,C,b_\mathsf{s}).\sirtwo := \sirtwo(b,t,\slotstart(\epoch(b)+1))$.

    When $\sir(b,t,C,b_\mathsf{s})$ is clear from the context, we simply wirite $\sir n$ to mean $\sir(b,t,C,b_\mathsf{s}).\sir n$.

    We also write $\sir(b,t,C,b_\mathsf{s}).\{\sir_1,\ldots,\sir_k\}$ where $\sir_i \in {\sir n: n \in [1,5]}$ to mean  $\bigwedge_{i=1}^k \sir(b,t,C,b_\mathsf{s}).sir_i$.
\end{definition}

\begin{lemma}\label{lem:ffg-condition-on-q-implies-safety}
    Given Assumptions 1 and 2 from the paper,
    %~\ref{assum:beta}, \ref{assum:sync}, \ref{assum:ffg-assumptions:beta} and \ref{assum:oracle-access-to-committee-selection},
    let $v$ be any honest validator,
    $t$ and $t'$ be any two times,
    $b$ be any block and
    $C$ be any checkpoint.
    If
    \begin{enumerate}
        \item $\slotstart(\slot(t)-1)\geq\GGST$,
        % \item $slot(b) < slot(t)$
        \item $\var[val=v]{\mathit{isLMDGHOSTSafeFrom}}(b,C,t,b_\mathsf{s})$,
        \item $t' \geq \slotstart(\slot(t))$ and
        \item for any validator $v'' \in \commfromslot[from=\slot(t),to=\slot(t')]{\honvals}$ and time $t''$ such that $t \leq t'' \leq t'$, 
        \begin{enumerate}[label*=\arabic*.]
            \item $\gjattime[time=t'',val=v''] \succeq C$,
            % \item $\gjattime[time=t'',val=v''] \succeq C_\mathsf{s}$ and
            \item $b \in \filtered[time=t'',val=v'']$,
            \item $b_\mathsf{s} \preceq  \LMDGHOSTHFC(\viewattime[val=v',time=t'])$
        \end{enumerate}
        % \item\label{itm:thm:lmd-confirmed-changing-balances:cond-on-justified-next-epoch} by the end of epoch $\epoch(t) + 1$, any honest validator has in their view a block $b''$ such that $\epoch(U(b'')) = \epoch(t) \land U(b'') \succeq \gjblock(b)$
    \end{enumerate}
    % then, for any time $t' \geq \slotstart(\slot(t))$ such that
    % \begin{enumerate}[resume]
    %     % \item $t' \geq t$, and

    % \end{enumerate}
    % we have that,
    then $\canonical[blck=b,time=\slotstart(\slot(t)),to=t']$
    
    % $b$ is canonical in the view of any honest validator at time $t'$.
    % \begin{enumerate}
    %     \item at time $t'$, $b$ is canonical in the view of any honest validator, and
    %     \item any honest validator voting at time $t'$ LMD votes for a descendant of block $b$ in slot $\slotattime{t'}$.
    % \end{enumerate}
\end{lemma}

\begin{proof}
    Frolows from the proof of Lemma 10 of the paper.
\end{proof}


\begin{lemma}\label{lem:ffg-safety-from-sir}
    If $\sir(b,t,C,b_\mathsf{s})$ holds, then $\canonical[blck=b,time=\slotstart(\slot(t))]$.
\end{lemma}

\begin{proof}
    % We proceed by induction on $t' \geq \slotstart(\slot(t))$
    % proving that $b$ is canonical in the view of any honest validator at time $t'$
    % % % Let $e_0 := \max(\epoch(b)+2, \epoch(t))$.
    % % We proceed by induction on epochs %$\epoch(t')$
    % % starting from $\epoch(b)+2$
    % % % For each $e' \geq e$, we want to show that $b$ does not get filtered out during epoch $e$, and also that, for any $t \geq s$ such that $\epoch(t) = e'$, $P^{N'}_{b'} > \frac{1}{2(1 - \beta)}(1 + \frac{W^{t+1}_p}{W_{b'}^{t}})$ holds throughout epoch $e'$. Moreover,
    % and add the following inductive hypothesis to the proof goal for any time $t'\geq \slotstart(\slot(t))$:

    First, we proceed by induction on $t' \geq \slotstart(\slot(t))$ to show that all of the following inductive conditions hold
    \begin{enumerate}[label=\roman*)]
        %\item by the end of epoch $\epoch(t)+1$, in the view of any honest node there exists a block $b' \succeq b$ such that $U(b') = \chkp(b)$; \label{def:safety-cond-1}
        \item there exists no checkpoint $C'$ with $\epoch(C') \in [\epoch(b), \epoch(t')]$ which conflicts with $b$. \label{lem:ffg-safety-from-sir:safety-cond-1}
        \item\label{lem:ffg-safety-from-sir:safety-cond-2} for any honest validator $v''$ and time $t''$ such that $\slotstart(\slot(t)) \leq t'' < \slotstart(\epoch(t')+1)$
        \begin{enumerate}[label=\roman{enumi}.\roman*)]
            \item $b \in \filtered[val=v'',time=t'']$\label{lem:ffg-safety-from-sir:safety-cond-2.1}
            \item $\gjattime[time=t'',val=v''] \succeq C$\label{lem:ffg-safety-from-sir:safety-cond-2.2}
            \item $b_\mathsf{s} \preceq  \LMDGHOSTHFC(\viewattime[val=v'',time=t''])$ \label{lem:ffg-safety-from-sir:safety-cond-2.3}
        \end{enumerate}

        % \item $b$ is always canonical in the view of all honest validators at any time $t' \geq t$ such that $\slotattime{t'} > \slot(t) \land \epoch(t') \in \{e, e+1\}$
        % \item $P_b^{t} > \frac{1}{2(1-\beta)}(1 + \frac{W^{t+1}_p}{W_b^{t}})$ for all slots $t$ such that $\epoch(t) = e+1$.
    \end{enumerate}


    \begin{description}
        \item[Base Case: $\epoch(t') < \epoch(b)+2$.]
        % Due to \sirone and \sirtwo and \sirthree we can apply Lemma~\ref{lem:ffg-condition-on-q-implies-safety} to conclude that $b$ is canonical for any honest validator at time $t'$.
        All inductive hypothesis are trivially implied by \sirtwo, \sirthree and \sirfive.


        \item[Inductive Step: $\epoch(t') \geq \epoch(b)+2$.]
        Assume that all the inductive hypotheses hold at any time $t_i$ up to %such that $\slotattime{t_i} < \slotattime{t'}$
        $\epoch(t_i) \leq \epoch(t')-1$ and prove that they hold at time $t'$ as well.
        Let $v'$ be any honest validator.
        % We let $v'$ be any hoenst validator so that, to prove \ref{def:safety-cond-2}, it will be sufficient to show that $b$ is canonical for $v'$ at time $t'$.

        % Let $v''$ be any honest validator and $t''$ be any time such that $\slotstart(\slot(t))\leq t'' < \slotstart(\epoch(t)+1)$.

        Induction hypothesis~\ref{lem:ffg-safety-from-sir:safety-cond-1} and \ref{def:induction-conditions:ub} allow us to apply Lemma 11 of the Paper to conclude that $b \in \filtered[time=t',val=v']$, \ie, $b$ does not get filtered out by any honest validator in epoch $\epoch(t')$.
        This proves induction hypothesis~\ref{lem:ffg-safety-from-sir:safety-cond-2.1} holds at time $t'$ as well.

        % First, Lemma~\ref{lem:block-in-the-view-of-all-honests} implies that $b$ is in the view of validator $v'$ at time $t'$.
        Also, induction hypothesis~\ref{lem:ffg-safety-from-sir:safety-cond-1},
        % \ref{lem:ffg-safety-from-sir:safety-cond-2.2},
        % \sirone,
        \ref{def:induction-conditions:ub},
        Property~1.7 of the Paper
        and the definition of $\gjattime[time=t',val=v']$ (Definition~\ref{def:gjview})
        imply that
        $\gjattime[time=t',val=v'] \succeq \chkp(b)$.
        Then,
        \sirone,
        proves inductive conditions \ref{lem:ffg-safety-from-sir:safety-cond-2.2} and $\gjattime[time=t',val=v']  \succeq b_\mathsf{s}$.
        Given that $\LMDGHOSTHFC(\viewattime[val=v',time=t']) \succeq \gjattime[time=t',val=v']$, this proves \ref{lem:ffg-safety-from-sir:safety-cond-2.3} for $t'$.
        % This, together with  and \ref{def:induction-conditions:all-validators:gj-succ}, implies that $\gjattime[time=t'',val=v''] \succeq C$.


        % Consider some epoch $e' \geq e+1$, for which all inductive %assumptions
        % hypotheses are satisfied.
        % This implies that there is no justified checkpoint in epochs $[e-1, e']$ which conflicts with $b$.
        % Together with condition~\ref{def:safety-cond-1}, this
        Given that $t'\geq\slotstart(\slot(t))$ and that above we have proved that inductive condition \ref{lem:ffg-safety-from-sir:safety-cond-2} is satisfied for time $t'$, thanks to \sirone, we can apply Lemma~\ref{lem:ffg-condition-on-q-implies-safety} to conclude that $b$ is always canonical in the view of all honest validators at any time during epoch $\epoch(t')$.
        % and that all honest validators in epoch $\epoch(t')$ \GHOST vote for a descendant of $b$ proving the Lemma's statement.

        % We can now use this and inductive hypothesis iv) to apply Lemma~\ref{lem:slot-induction-within-epoch} to epoch $e'+1$, and conclude that $P_b^{t'} > \frac{1}{2(1-\beta)}(1 + \frac{W^{t'+1}_p}{W_b^{t'}})$ for all slots $t'$ in epoch $e'+1$ proving condition iii).
        % This also implies that $b$ is canonical in all honest views in epoch $e'+1$, and thus that the subtree of $b$ receives all honest votes proving the Lemma's statement.
        % Then we are just left to show that the inductive hypothesis~\ref{def:safety-cond-2}
        By Properties~1.3 and 1.6 of the Paper, this immediately implies that no checkpoint conflicting with $b$ can be justified in epoch $\epoch(t') $, which concludes the proof for the inductive hypothesis~\ref{lem:ffg-safety-from-sir:safety-cond-1}.
        % Condition i) is trivially true as the view of an honest node is monotonic.
    \end{description}
    Given that we have just established that the inductive condition \ref{lem:ffg-safety-from-sir:safety-cond-2} hold for any time $t' \geq \slotstart(\slot(t))$, thanks to \sirone, we can apply Lemma~\ref{lem:ffg-condition-on-q-implies-safety} to complete the proof.
\end{proof}

\begin{lemma}\label{lem:epoch-gu-less-than-two-epoch-ago-start-epoch}
    If
    \begin{enumerate}
        \item $\slotstart(\prevfirstslotepoch{t})\geq \GST$
        % \item $t = \slotstart(\epoch(t))$
        \item $\epoch(\var[val=v,time=\slotstart(\prevfirstslotepoch{t})]{\bconfirmed}) \geq \epoch(t) - 1$
    \end{enumerate},
    then
    \begin{enumerate}
        \item $\epoch(\guattime[time=\slotstart(\prevfirstslotepoch{t}),val=v]) \geq \epoch(t)-2$
    \end{enumerate}
\end{lemma}

\begin{proof}
    Let $s:= \slot(t)$.
    The Lemma's condition imply that $\epoch(\var[val=v,time=\slotstart(s-1)]{\bconfirmed}) = \epoch(s-1)$ as $\epoch(s-1) = \epoch(s)-1 \leq \epoch(\var[val=v,time=\slotstart(s-1)]{\bconfirmed}) < \epoch(t)$.
    \Cref{lem:conf-current-epoch-then-gu-curr-epoch} implies that $\exists b' \in \viewattime[val=v,time=\slotstart(s-1)], b' \succeq \var[val=v,time=\slotstart(s-1)]{\bconfirmed} \land \epoch(\gu(b')) \geq \epoch(s-1) = \epoch(s)-2$.
\end{proof}

\begin{proof}
    From \Cref{lem:epoch-gu-less-than-two-epoch-ago-start-epoch} and the synchrony assumption.
\end{proof}

\begin{lemma}\label{lem:gj-prec-prev-confirmed-at-start-of-epoch}
    % Pick any $b_c \in  \var[val=v,time=\slotstart(\slot(t))]{\bcands}$, any time $t' \geq \slotstartslot{t}$ and any honest validator $v'$.
    If
    \begin{enumerate}
        \item $\slotstart(\prevfirstslotepoch{t})\geq \GST$
        % \item  $t = \firstslot(\epoch(t))$
        \item \sloppy{the \KwSty{if} condition at line \Cref{ln:if-bcand-npreceq-head} during the execution of $\var[val=v,time=\slotstart(\epoch(t))]{\getlatestconfirmed}(\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})])$ is false}
        % \item \ref{def:induction-conditions:ub} holds for $\var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}$
        \item  \label{itm:lem:gj-prec-prev-confirmed-at-start-of-epoch:4} no checkpoint $C$ s.t. $\epoch(C) = \epoch(t)-1$ and $\block(C)$ conflicts with  $\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$ can ever be justified
        % \item \ref{def:induction-conditions:ub} holds for $\var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}$
        % \item $\slotstart(\lastslot(\epoch(t)-1)) \geq \GST$
        % \item $\epoch(b_c) \geq \epoch(t)-1$
        % \item $b_c \in \filtered[val=v',time=t']$
    \end{enumerate},
    then,  %honest validators $v'$ and any time $t' \geq \slotstart(\epoch(t))$% s.t. $\epoch(t') = \epoch(t)$
    \begin{enumerate}
        % \item $\epoch(\gjattime[time=t',val=v']) \leq \epoch(t)-1 \implies \gjattime[time=t',val=v']  \preceq \var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}$
        % \item $\epoch(\gjattime[time=t',val=v']) \in [\epoch(t)-2,\epoch(t)-1] \implies \gjattime[time=t',val=v']  \preceq \var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}$
        \item for any justified checkpoint $C$, $\epoch(C) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)-1] \implies C  \preceq \var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}$
    \end{enumerate}
\end{lemma}

\begin{proof}
    The Lemma's conditions imply that $\epoch(\var[val=v,time=\slotstart(\prevfirstslotepoch{t})]{\bconfirmed}) = \epoch(t)-1$.
    From \Cref{lem:epoch-gu-less-than-two-epoch-ago-start-epoch} and syncrony, we have the following two cases.
    % By cases.
    \begin{description}
        \item[Case 1: {$\epoch(C)=\epoch(t)-1$}.] 
        Given assumption~\ref{itm:lem:gj-prec-prev-confirmed-at-start-of-epoch:4} of the Lemma and $\epoch(\var[val=v,time=\slotstart(\prevfirstslotepoch{t})]{\bconfirmed}) = \epoch(t)-1$, we know that $C  = \chkp(\var[val=v,time=\slotstart(\prevfirstslotepoch{t})]{\bconfirmed}) \preceq \var[val=v,time=\slotstart(\prevfirstslotepoch{t})]{\bconfirmed}$
        \item[Case 2: {$\epoch(C)=\epoch(\guattime[val=v,time=\slotstart(\prevfirstslotepoch{t})] )=\epoch(t)-2$}.]
        This implies $C = \guattime[val=v,time=\slotstart(\prevfirstslotepoch{t})] \preceq \var[val=v,time=\slotstart(\prevfirstslotepoch{t})]{\bconfirmed}$.
        The last $\preceq$ relation comes from the \KwSty{if} condition at line \Cref{ln:if-bcand-npreceq-head} being false.
    \end{description}
\end{proof}

% \begin{lemma}\label{lem:gj-prec-prev-confirmed-at-start-of-epoch}
%     % Pick any $b_c \in  \var[val=v,time=\slotstart(\slot(t))]{\bcands}$, any time $t' \geq \slotstartslot{t}$ and any honest validator $v'$.
%     If
%     \begin{enumerate}
%         \item $\slotstart(\prevfirstslotepoch{t})\geq \GST$
%         \item  $t = \firstslot(\epoch(t))$
%         \item the \KwSty{if} condition at line \Cref{ln:if-bcand-npreceq-head} is false
%         % \item \ref{def:induction-conditions:ub} holds for $\var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}$
%         % \item $\slotstart(\lastslot(\epoch(t)-1)) \geq \GST$
%         % \item $\epoch(b_c) \geq \epoch(t)-1$
%         % \item $b_c \in \filtered[val=v',time=t']$
%     \end{enumerate},
%     then, for any honest validators $v'$ and time $t'$ s.t. $\epoch(t') = \epoch(t)$
%     \begin{enumerate}
%         \item $\gjattime[time=t',val=v']  \preceq \var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}$
%     \end{enumerate}
% \end{lemma}

% \begin{proof}
%     The Lemma's conditions imply that $\epoch(\var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}) = \epoch(t)-1$.
%     From \Cref{lem:epoch-gu-less-than-two-epoch-ago-start-epoch} and syncrony, by cases.
%     \begin{description}
%         \item[Case 1: {$\epoch(\gjattime[time=t',val=v'])=\epoch(t)-1$}.] 
%         Given that $\willNoConflictingChkpBeJustified(\var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed})$, and $\epoch(\var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}) = \epoch(t)-1$, we know that $\gjattime[time=t',val=v']  \preceq \var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}$
%         \item[Case 2: {$\epoch(\gjattime[time=t',val=v'])=\epoch(t)-2$}.]
%         This implies $\gjattime[time=t',val=v'] = \guattime[val=v,time=\slotstart(\slot(t)-1)] \preceq \var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}$ 
%     \end{description}
% \end{proof}

\begin{lemma}\label{lem:prev-confirmed-not-filtered-out-start-of-epoch}
    % Pick any $b_c \in  \var[val=v,time=\slotstart(\slot(t))]{\bcands}$, any time $t' \geq \slotstartslot{t}$ and any honest validator $v'$.
    If
    \begin{enumerate}
        \item $\slotstart(\prevfirstslotepoch{t})\geq \GST$
        % \item  $t = \slotstart(\epoch(t))$
        \item \sloppy{the \KwSty{if} condition at line \Cref{ln:if-bcand-npreceq-head} during the execution of $\var[val=v,time=\slotstart(\epoch(t))]{\getlatestconfirmed}(\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})])$ is false}
        \item no checkpoint $C$ s.t. $\epoch(C) = \epoch(t)-1$ and $\block(C)$ conflicts with  $\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$ can ever be justified
        % \item \ref{def:induction-conditions:ub} holds for $\var[val=v,time=\slotstart(\prevfirstslotepoch{t})]{\bconfirmed}$
        % \item \ref{def:induction-conditions:ub} holds for $\var[val=v,time=\slotstart(\prevfirstslotepoch{t})]{\bconfirmed}$
        % \item $\slotstart(\lastslot(\epoch(t)-1)) \geq \GST$
        % \item $\epoch(b_c) \geq \epoch(t)-1$
        % \item $b_c \in \filtered[val=v',time=t']$
    \end{enumerate},
    then, for any honest validators $v'$ and time $t'$ s.t. $\epoch(t') = \epoch(t)$
    \begin{enumerate}
        \item $\var[val=v,time=\slotstart(\prevfirstslotepoch{t})]{\bconfirmed} \in \filtered[val=v',time=t']$
    \end{enumerate}
\end{lemma}

\begin{proof}
    The Lemma's conditions imply that $\epoch(\var[val=v,time=\slotstart(\prevfirstslotepoch{t})]{\bconfirmed}) = \epoch(t)-1$.
    Then, the proof follows from \Cref{lem:gj-prec-prev-confirmed-at-start-of-epoch,lem:conf-prev-epoch-then-vs-two-epochs-ago}\RSfn{and some property on max GJ  epoch}.
\end{proof}

\begin{lemma}\label{lem:conf-prev-slot-canonical-at-the-start-of-an-epoch}
    % Pick any $b_c \in  \var[val=v,time=\slotstart(\slot(t))]{\bcands}$, any time $t' \geq \slotstartslot{t}$ and any honest validator $v'$.
    If
    \begin{enumerate}
        \item $\slotstart(\prevfirstslotepoch{t})\geq \GST$
        % \item  $t = \slotstart(\epoch(t))$
        \item \label{itm:lem:conf-prev-slot-canonical-at-the-start-of-an-epoch:3} \sloppy{the \KwSty{if} condition at line \Cref{ln:if-bcand-npreceq-head} during the execution of $\var[val=v,time=\slotstart(\epoch(t))]{\getlatestconfirmed}(\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})])$ is false}
        \item\label{itm:lem:conf-prev-slot-canonical-at-the-start-of-an-epoch:4}  no checkpoint $C$ s.t. $\epoch(C) = \epoch(t)-1$ and $\block(C)$ conflicts with  $\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$ can ever be justified
        % \item $\slotstart(\lastslot(\epoch(t)-1)) \geq \GST$
        % \item $\epoch(b_c) \geq \epoch(t)-1$
        % \item $b_c \in \filtered[val=v',time=t']$
    \end{enumerate},
    then
    \begin{enumerate}
        \item $\sir(\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})],t,\guattime[val=v,time={\slotstart(\prevfirstslotepoch{t})}],\block(\guattime[val=v,time={\slotstart(\firstslot(\epoch(\var[val=v]{t}))-1)}])).\{ \sirone, \sirtwo, \sirthree\}$ holds.
        % \item for any honest validators $v'$ and time $t'$ s.t. $\epoch(t') = \epoch(t)$, $\gjattime[time=t',val=v']  \preceq \bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$
        \item for any justified checkpiont $C$, $\epoch(C) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)-1] \implies C  \succeq \guattime[time=\slotstart(\prevfirstslotepoch{t}),val=v]$
        \item for any justified checkpiont $C$, $\epoch(C) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)-1] \implies C  \preceq \bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$
        \item $\canonical[blck={\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]},time=t,to=\slotstart(\epoch(t)+1)]$
    \end{enumerate}
\end{lemma}

\begin{proof}
    Lemma's assumption~\ref{itm:lem:conf-prev-slot-canonical-at-the-start-of-an-epoch:3}
    implies that $\epoch(\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]) = \epoch(t)-1$ and $\var[val=v]{\mathit{is\_chain\_one\_confirmed}}(\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})],\guattime[val=v,time={\slotstart(\firstslot(\epoch(\var[val=v]{t}))-1)}])$.
    
    Note that this implies that $\slotstart(epoch(\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]) +2) = \slotstart(\epoch(t)+1)$.


    % Now, we prove tha $\sir(\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})],t,\guattime[val=v,time={\slotstart(\firstslot(\epoch(\var[val=v]{t}))-1)}],\block(\guattime[val=v,time={\slotstart(\firstslot(\epoch(\var[val=v]{t}))-1)}]))$ holds.

    $\var[val=v]{\mathit{is\_chain\_one\_confirmed}}(\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})],\guattime[val=v,time={\slotstart(\firstslot(\epoch(\var[val=v]{t}))-1)}])$ implies that $\block(\guattime[val=v,time={\slotstart(\firstslot(\epoch(\var[val=v]{t}))-1)}]) \preceq \bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$.
    Given that $\epoch(\guattime[val=v,time={\slotstart(\firstslot(\epoch(\var[val=v]{t}))-1)}])\leq \epoch(t)-1 = \epoch(\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})])$, we have that $\guattime[val=v,time={\slotstart(\firstslot(\epoch(\var[val=v]{t}))-1)}] \preceq \bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$.
    % $\var[val=v]{\mathit{is\_chain\_one\_confirmed}}(\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})],\guattime[val=v,time={\slotstart(\firstslot(\epoch(\var[val=v]{t}))-1)}])$ then also implies \sirone.
    This further implies that \sirone holds.

    \Cref{lem:prev-confirmed-not-filtered-out-start-of-epoch}  proves \ref{def:induction-conditions:all-validators:not-filtered-out}.

    Let $C$ be a justified checkpoint such that $\epoch(C) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)-1]$.
    \Cref{lem:gj-prec-prev-confirmed-at-start-of-epoch} implies $C  \preceq \bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$.
    Given that, as proven above, $\guattime[val=v,time={\slotstart(\firstslot(\epoch(\var[val=v]{t}))-1)}] \preceq \bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$, this implies that $\guattime[val=v,time={\slotstart(\firstslot(\epoch(\var[val=v]{t}))-1)}]$ does not conflict with $C$.
    Then, given that we assume $\epoch(C)\geq \epoch(\guattime[val=v,time={\slotstart(\firstslot(\epoch(\var[val=v]{t}))-1)}])$, we have that $C\succeq \guattime[val=v,time={\slotstart(\firstslot(\epoch(\var[val=v]{t}))-1)}]$.

    Given that $\epoch(\gjattime[time=t',val=v']) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)-1]$ for any honest validator $v'$ and time $t' \in [\slotstart(\epoch(t)),\slotstart(\epoch(t)+1)]$, \ref{def:induction-conditions:all-validators:gj-succ} holds.


    % Let $v'$ be any honest validator and $t' \geq \epoch(t)$ such that $\epoch(\gjattime[time=t',val=v']\leq\epoch(t)-1$.
    % \Cref{lem:gj-prec-prev-confirmed-at-start-of-epoch} implies $\gjattime[time=t',val=v']  \preceq \bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$.
    % Given that, as proven above, $\guattime[val=v,time={\slotstart(\firstslot(\epoch(\var[val=v]{t}))-1)}] \preceq \bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$, this implies that $\guattime[val=v,time={\slotstart(\firstslot(\epoch(\var[val=v]{t}))-1)}]$ does not conflict with $\gjattime[time=t',val=v']$.
    % Then, given that due to synchorny, $\epoch(\gjattime[time=t',val=v'])\geq \epoch(\guattime[val=v,time={\slotstart(\firstslot(\epoch(\var[val=v]{t}))-1)}])$, we have that $\gjattime[time=t',val=v']\succeq \guattime[val=v,time={\slotstart(\firstslot(\epoch(\var[val=v]{t}))-1)}]$.
    % This also implies that \ref{def:induction-conditions:all-validators:gj-succ} holds.

    % This, \Cref{lem:gj-at-least-e-2-curr-slot,lem:gj-does-not-conflict} we can conclude that $\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$ does not conflict with $\gjattime[time=t',val=v']$.



    % $\epoch(t) > \epoch(\gjattime[time=t',val=v']) \geq \epoch(\guattime[val=v,time={\slotstart(\prevfirstslotepoch{t})}]) \geq \epoch(t)-2$b


    % Assumption \ref{itm:lem:conf-prev-slot-canonical-at-the-start-of-an-epoch:4} of the Lemma implies that no justified checkpoint for epoch $\epoch(t)-1$ conflicting with $\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$ can exist.





    % Then, this, \Cref{lem:gu-prec-gj-start-epoch-when-prec-conf-from-at-least-prev-epoch,lem:epoch-gu-less-than-two-epoch-ago-start-epoch}, $\epoch(\gjattime[time=t',val=v']) \geq \epoch(\guattime[val=v,time={\slotstart(\firstslot(\epoch(\var[val=v]{t}))-1)}])$ imply \ref{def:induction-conditions:all-validators:gj-succ} and \ref{def:induction-conditions:all-validators:gj-succ-cs}.

    \sirone, \sirtwo and \sirthree and \Cref{lem:ffg-condition-on-q-implies-safety} imply that $\canonical[time=t,blck={\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]},to=\slotstart(\epoch(t)+1)]$. 

    % This then implies that no checkpoint for epoch $\epoch(t)$ conflicting with $\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$ can ever be justified which concldes the proof for \sirfive.

    % \ref{def:induction-conditions:ub} holds by assumption.
\end{proof}


\begin{lemma}\label{lem:output-find-latest-canonical-canonical-at-the-start-of-an-epoch}
    % Let $b_o := \var[val=v]{\findlatestconfirmeddescendant}(b_c)$.
    Let $b_c$ be anya block.
    If
    \begin{enumerate}
        \item $\bconfirmed[val=v,time=\slotstart(\slot(t))] =  \var[val=v,time=\slotstartslot{t}]{\findlatestconfirmeddescendant}(b_c)$
        \item $\slotstart(\prevfirstslotepoch{t})\geq \GST$
        % \item $\sir(b_c,t,\guattime[val=v,time={\slotstart(\slot({t})-1)}],\cdot)$ holds
        \item $\canonical[blck=b_c,time={\slotstartslot{t}},to=\slotstart(\epoch(t)+1)]$
        \item \label{itm:lem:output-find-latest-canonical-canonical-at-the-start-of-an-epoch:4}for any justified checkpiont $C$, $\epoch(C) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)-1] \implies C  \preceq b_c$
        \item  \label{itm:lem:output-find-latest-canonical-canonical-at-the-start-of-an-epoch:5} for any justified checkpiont $C$, $\epoch(C) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)-1] \implies C  \succeq \guattime[time=\slotstart(\prevfirstslotepoch{t}),val=v]$
        % \item \ref{def:induction-conditions:ub} holds for a block $b_0$ s.t. $b_0 \preceq b_c$ and $\epoch(b_0) = \epoch(t)-1$ %\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]
        % \item $\epoch(b_c) \geq \epoch(\var[val=v]{t})-1$
        % \item $t = \slotstart(\slot(t))$

        % \item $\var[val=v]{t} = \slotstart(\epoch(\var[val=v]{t}))$
    \end{enumerate},
    then
    \begin{enumerate}
        % \item for any honest validators $v'$ and time $t'$ s.t. $\epoch(t') = \epoch(t)$, $\gjattime[time=t',val=v']  \preceq \bconfirmed[val=v,time=\slotstart(\slot(t))]$
        \item for any justified checkpiont $C$, $\epoch(C) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)-1] \implies C  \preceq \bconfirmed[val=v,time=\slotstart(\slot(t))]$\RSfn{Not sure this conclusion is ever used. This might be true for conclusions in other Lemmas though. Perhaps le't leave it just in case as these proofs are not that polished anyway.}
        \item for any justified checkpiont $C$, $\epoch(C) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)-1] \implies C  \succeq \ceba[val=v,time=\slotstartslot{t}]$
        \item $\sir(\bconfirmed[val=v,time=\slotstart(\slot(t))],t,\ceba[val=v,time=\slotstartslot{t}],b_c).\{ \sirone, \sirtwo, \sirthree\}$ holds.
        % \item $\sir(b_o,t,\guattime[val=v,time={\s\lotstart(\slot(\var[val=v]{t})-1)}],b_c)$, with the exception of  \ref{def:induction-conditions:ub}, holds
        \item $\canonical[blck=b_o,time={\slotstartslot{t}},to=\slotstart(\epoch(t)+1)]$
    \end{enumerate}
\end{lemma}

\begin{proof}
        We prove first that $\sir(\bconfirmed[val=v,time=\slotstart(\slot(t))],t,\ceba[val=v,time=\slotstartslot{t}],b_c).\{ \sirone, \sirtwo, \sirthree\}$ holds.
        Let $v'$ be any honest validator and $t' \in [t, \slotstart(\epoch(t)+1)]$.



        % If $b_c= b_o$ by the inductive hypothesis above.

        % From \Cref{lem:if-new-bc-then-output-find-latest} we know that\\ $b_o=\findlatestconfirmeddescendant(b_c)$.

        We know that $\bconfirmed[val=v,time=\slotstart(\slot(t))] \succeq b_c$.

        Due to synchrony, we know that $\epoch(\ceba[val=v,time=t]) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)-1]$ and $\epoch(\gjattime[val=v',time=t']) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)-1]$.
        Then, Lemma's condition \ref{itm:lem:output-find-latest-canonical-canonical-at-the-start-of-an-epoch:4} implies $\ceba[val=v',time=t'] \preceq b_o$ and $\gjattime[val=v',time=t'] \preceq b_o$.

        % Assumption \ref{itm:lem:output-find-latest-canonical-canonical-at-the-start-of-an-epoch:4} of the Lemma's statement then implies that $\gjattime[time=t',val=v'] \preceq \bconfirmed[val=v,time=\slotstart(\slot(t))]$ for any time $t' \in [\slotstart(\epoch(t)),\slotstart(\epoch(t)+1)]$ and an honest validator $v'$.

        % We can prove that there exists a time $t'' \in [\slotstart(\epoch(t)),\slotstart(\epoch(t)+1)]$ and an honest validator $v''$ such that $\ceba[val=v,time=\slotstartslot{t}] = \gjattime[time=t'',val=v'']$. (If we are in the first slot then $t''$ is any time and $v''$ is any validator, otherwise, $t''= \slotstart(\slot(t)-1)$ and $v'' = v$.)

        % Then, from the above we can conclude that $\ceba[val=v,time=\slotstartslot{t}]  \preceq b_o$.

        We also know that $\findlatestconfirmeddescendant$ ensures that\\
            $\mathit{isLMDGHOSTSafeFrom}(b_o,t,\ceba[val=v,time=\slotstartslot{t}],b_c)$. 
        Hence, \sirone holds.


        Also, $\gjattime[time=t',val=v'] \preceq b_o$ and
        \Cref{lem:conf-prev-epoch-then-vs-two-epochs-ago} imply \ref{def:induction-conditions:all-validators:not-filtered-out}.

        % We know that $\epoch(t)-2\leq\epoch(\guattime[val=v,time={\slotstart(\prevfirstslotepoch{t})}])\leq\epoch(\ceba[val=v,time=\slotstartslot{t}])\leq\epoch(\gjattime[time=t',val=v'])\leq\epoch(t)-1$.

        Then, if $\epoch(\ceba[val=v,time=\slotstartslot{t}])=\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))])$, 
        $\ceba[val=v,time=\slotstartslot{t}]= \guattime[val=v,time={\slotstart(\slot({t})-1)}]$ and Lemma's condition~\ref{itm:lem:output-find-latest-canonical-canonical-at-the-start-of-an-epoch:5} implies $\gjattime[time=t',val=v']\succeq \ceba[val=v,time=\slotstartslot{t}]$.
        Otherwise, \Cref{lem:epoch-gu-less-than-two-epoch-ago-start-epoch} implies that 
        $\epoch(\ceba[val=v,time=\slotstartslot{t}])=\epoch(t)-1$. 
        Then,  $\gjattime[time=t',val=v'] = \ceba[val=v,time=\slotstartslot{t}]$.
        Hence, \ref{def:induction-conditions:all-validators:gj-succ} holds.

        Finally, \sirone, \sirtwo and \sirthree,   $\canonical[blck={b_c},time=t, to=\slotstart(\epoch(t)+1)]$, and \Cref{lem:ffg-condition-on-q-implies-safety} imply that $\canonical[time=t,blck={\var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}},to=\slotstart(\epoch(t)+1)]$. 


        % $\sir(b_c,t,\guattime[val=v,time={\slotstart(\slot({t})-1)}],\cdot)$ clearly implies \ref{def:induction-conditions:all-validators:gj-succ}$(b_o,t,\guattime[val=v,time={\slotstart(\slot(\var[val=v]{t})-1)}],b_c)$.

        % \ref{def:induction-conditions:all-validators:gj-succ-cs} is clearly implied by the Lemma's assumptions.

        % % \ref{def:induction-conditions:ub} is cleraly implied by the Lemma's assumptions.

        % \sirfive can be proven as in the proof of \Cref{lem:conf-prev-slot-canonical-at-the-start-of-an-epoch}: from the proof of the previous conditions, we can conclude that $\canonical[time=t,blck={b_o},to=\slotstart(\epoch(t)+1)]$ from which we can prove that  no checkpoint for epoch $\epoch(t) = \epoch(b_o)+1$ conflicting with ${b_o}$ can ever be justified.
        % \ref{def:induction-conditions:ub} holding for ${b_o}$ implies \sirfive  for epoch $\epoch(b) = \epoch(t)-1$, 
\end{proof}

% \begin{proof}
    
%     % We need to prove that $\sir(b_o,t,\guattime[val=v,time={\slotstart(\slot(\var[val=v]{t})-1)}],b_c)$ holds.  
    
%     We know that 
%     \begin{enumerate}
%         \item $\findlatestconfirmeddescendant$ ensures that\\ $\mathit{isLMDGHOSTSafeFrom}(b_o,t,\guattime[val=v,time={\slotstart(\slot(\var[val=v]{t})-1)}],b_c)$ 
%         \item  $\sir(b_c,t,\guattime[val=v,time={\slotstart(\slot({t})-1)}],\cdot)$ implies  $\guattime[val=v,time={\slotstart(\slot(\var[val=v]{t})-1)}] \preceq b_c$.
%         $b_o = \var[val=v]{\findlatestconfirmeddescendant}(b_c)$ then implies $\guattime[val=v,time={\slotstart(\slot(\var[val=v]{t})-1)}] \preceq b_c \preceq b_o$.
%         % \item Given the above, $\block(\guattime[val=v,time={\slotstart(\slot(\var[val=v]{t})-1)}])  \preceq b_o$
%     \end{enumerate}
%     Hence, \sirone holds.

%     Given that $b_o \succeq b_c$,
%     assumption \ref{itm:lem:output-find-latest-canonical-canonical-at-the-start-of-an-epoch:4} implies that $\gjattime[time=t',val=v'] \preceq b_c  \preceq b_o$.
%     \Cref{lem:conf-prev-epoch-then-vs-two-epochs-ago} then implies \ref{def:induction-conditions:all-validators:not-filtered-out}.

%     $\sir(b_c,t,\guattime[val=v,time={\slotstart(\slot({t})-1)}],\cdot)$ clearly implies \ref{def:induction-conditions:all-validators:gj-succ}$(b_o,t,\guattime[val=v,time={\slotstart(\slot(\var[val=v]{t})-1)}],b_c)$.

%     % \ref{def:induction-conditions:all-validators:gj-succ-cs} is clearly implied by the Lemma's assumptions.

%     % \ref{def:induction-conditions:ub} is cleraly implied by the Lemma's assumptions.

%     \sirfive can be proven as in the proof of \Cref{lem:conf-prev-slot-canonical-at-the-start-of-an-epoch}: from the proof of the previous conditions, we can conclude that $\canonical[time=t,blck=b_o,to=\slotstart(\epoch(t)+1)]$ from which we can prove that  no checkpoint for epoch $\epoch(t) = \epoch(b_o)+1$ conflicting with $b_o$ can ever be justified.
%     \ref{def:induction-conditions:ub} holding for $b_o$ implies \sirfive  for epoch $\epoch(b) = \epoch(t)-1$, 
% \end{proof}

\begin{lemma}\label{lem:code-implications-of-confirmed-block-from-prev-epoch-at-the-beginning-of-epoch}
        If
    \begin{enumerate}
        % \item $\slotstart(\prevfirstslotepoch{t})\geq \GST$
        % \item  $t = \slotstart(\epoch(t))$
        \item $\epoch(\bconfirmed[val=v,time=\slotstart(\epoch(t))])=\epoch(t)-1$
        % \item if $\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})] \preceq \bconfirmed[val=v,time=\slotstart(\epoch(t))]$,
        % then no checkpoint $C$ s.t. $\epoch(C) = \epoch(\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})])$ and $C \neq \chkp(\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})])$ can ever be justified
        % \item \ref{def:induction-conditions:ub} holds for $\var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}$
        % \item \ref{def:induction-conditions:ub} holds for $\var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}$
        % \item $\slotstart(\lastslot(\epoch(t)-1)) \geq \GST$
        % \item $\epoch(b_c) \geq \epoch(t)-1$
        % \item $b_c \in \filtered[val=v',time=t']$
    \end{enumerate},
    then, one of the following conditions hold
    \begin{enumerate}
        % \item $\bconfirmed[val=v,time=\slotstart(\epoch(t))] = \block(\gfattime[val=v,time={\var[val=v]{t}}])$
        \item \sloppy{the \KwSty{if} condition at line \Cref{ln:if-bcand-npreceq-head} during the execution of $\var[val=v,time=\slotstart(\epoch(t))]{\getlatestconfirmed}(\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})])$ is false 
        and $\bconfirmed[val=v,time=\slotstart(\epoch(t))] = \var[val=v]{\findlatestconfirmeddescendant}(\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})])$.}
        \item $\guattime[val=v,time=\slotstart(\prevfirstslotepoch{t})]=\chkp(\bconfirmed[val=v,time=\slotstart(\epoch(t))])$ and\\ 
        $\bconfirmed[val=v,time=\slotstart(\epoch(t))] = \var[val=v]{\findlatestconfirmeddescendant}(\block(\guattime[val=v,time=\slotstart(\prevfirstslotepoch{t})]))$
        and $\exists b' \succeq \bconfirmed[val=v,time=\slotstart(\epoch(t))], \gu(b')=\chkp(\bconfirmed[val=v,time=\slotstart(\epoch(t))])$
        % \item $\bconfirmed[val=v,time=\slotstart(\epoch(t))] \succeq \block(\guattime[val=v,time=\slotstart(\prevfirstslotepoch{t})])$ and $\epoch(\guattime[val=v,time=\slotstart(\prevfirstslotepoch{t})])= \epoch(t)-1$
    \end{enumerate}
\end{lemma}

\begin{proof}
    TBD
\end{proof}

\begin{lemma}\label{lem:gu-e-1-canonical}
    If
    \begin{enumerate}
        \item $\slotstart(\prevfirstslotepoch{t})\geq \GST$
        % \item $t = \slotstart(\epoch(t))$
        \item $\epoch(\guattime[val=v,time=\slotstart(\prevfirstslotepoch{t})]) = \epoch(t)-1$
    \end{enumerate},
    then,
    \begin{enumerate}
        \item $\canonical[blck={\block(\guattime[val=v,time=\slotstart(\prevfirstslotepoch{t})])},time=\slotstartslot{t}]$.
        \item for any justified checkpiont $C$, $\epoch(C) = \epoch(t)-1 \implies C  \preceq \block(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))])$
        \item   for any justified checkpiont $C$, $\epoch(C) =\epoch(t)-1 \implies C  \succeq \guattime[time=\slotstart(\prevfirstslotepoch{t}),val=v]$
    \end{enumerate}
\end{lemma}

\begin{proof}
    By induction on $t' \geq \slotstartslot{t}$.
    Let $b := \block(\guattime[val=v,time=\slotstart(\prevfirstslotepoch{t})])$.
    We will show that $b \preceq \LMDGHOSTHFC(\viewattime[val=v',time=t'])$.
    \begin{description}
        \item[Base case: {$\epoch(t') = \epoch(t)$}.] Because of the synchrony assumption and the fact that $\epoch(\guattime[val=v,time=\slotstart(\prevfirstslotepoch{t})]) = \epoch(t)-1$,
        we know that $\gjattime[val=v',time=t'] = \guattime[val=v,time=\slotstart(\prevfirstslotepoch{t})]$ for any honest validator $v'$ and time $t'$ such that $\epoch(t') = \epoch(t)$.
        Clearly, $b \preceq \LMDGHOSTHFC(\viewattime[val=v',time=t'])$.
        \item[Inductive case: {$\epoch(t') > \epoch(t)$}.] We assume that the Lemma holds for any $t'' \geq t$ such that $\epoch(t'') < \epoch(t')$ and prove that it also holds for $t'$.        
        We will show that $b \preceq \gjattime[val=v',time=t']$. Then, clearly, $b \preceq \LMDGHOSTHFC(\viewattime[val=v',time=t'])$.
        By cases.
        \begin{description}
            \item[Case 1: {$\epoch(\gjattime[val=v',time=t']) = \epoch(\guattime[val=v,time=\slotstart(\prevfirstslotepoch{t})])$}.] Clearly, $\gjattime[val=v',time=t'] = \guattime[val=v,time=\slotstart(\prevfirstslotepoch{t})]$ in this case, thus $b = \block(\gjattime[val=v',time=t'])$.
            \item[Case 2: {$\epoch(\gjattime[val=v',time=t']) \neq \epoch(\guattime[val=v,time=\slotstart(\prevfirstslotepoch{t})])$}.]
            By the definition of the greatest justified checkpoint, $\epoch(\gjattime[val=v',time=t']) \leq \epoch(t')-1$ which implies $\epoch(t) \leq \epoch(\gjattime[val=v',time=t']) \leq \epoch(t'')$ for this case.
            From the inductive hypothesis we know that $b \preceq \LMDGHOSTHFC(\viewattime[val=v',time=t''])$ which implies that during each epoch $e \in \left[\epoch(t), \epoch(t'')\right]$ all honest validators cast their FFG votes in the support of $\chkp(b',e)$ such that $b' \succeq b$.
            Thus, given the synchrony assumption no checkpoint $\chkp'$ conflicting with $b$ such that $\epoch(\chkp') \in \left[\epoch(t), \epoch(t'')\right]$ can ever be justified.
            Given that, we conclude $b \prec \gjattime[val=v',time=t']$.
        \end{description}
        We have show that $b \preceq \gjattime[val=v',time=t']$ which proves that $\canonical[blck={\block(\guattime[val=v,time=\slotstart(\prevfirstslotepoch{t})])},time=\slotstartslot{t}]$.

        The other two conclusions follow from the fact that if $C$ is a justified checkpoint such that $\epoch(C) = \epoch(t)-1$, then $C = \guattime[val=v,time=\slotstart(\prevfirstslotepoch{t})]$.
    \end{description}
\end{proof}

\begin{lemma}\label{lem:confirmed-end-first-slot-canonical}
    If
    \begin{enumerate}
        \item $\slotstart(\prevfirstslotepoch{t})\geq \GST$
        % \item  $t = \slotstart(\epoch(t))$
        \item $\epoch(\bconfirmed[val=v,time=\slotstart(\epoch(t))])\geq\epoch(t)-1$
        \item if $\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})] \preceq \bconfirmed[val=v,time=\slotstart(\epoch(t))]$,
        then  no checkpoint $C$ s.t. $\epoch(C) = \epoch(t)-1$ and $\block(C)$ conflicts with  $\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$ can ever be justified
        % \item \ref{def:induction-conditions:ub} holds for $\var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}$
        % \item \ref{def:induction-conditions:ub} holds for $\var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}$
        % \item $\slotstart(\lastslot(\epoch(t)-1)) \geq \GST$
        % \item $\epoch(b_c) \geq \epoch(t)-1$
        % \item $b_c \in \filtered[val=v',time=t']$
    \end{enumerate},
    then, 
    \begin{enumerate}
        \item  $\sir(\bconfirmed[val=v,time=\slotstart(\epoch(t))],t,\guattime[val=v,time={\slotstart(\slot(\var[val=v]{t})-1)}],\cdot).\{\sirone,\sirtwo,\sirthree\}$ holds.
        \item $\canonical[blck={\bconfirmed[val=v,time=\slotstart(\epoch(t))]},time=t,to=\slotstart(\epoch(t)+1)]$
        \item for any justified checkpiont $C$, $\epoch(C) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)-1] \implies C  \preceq \bconfirmed[val=v,time=\slotstart(\epoch(t))]$
        \item   for any justified checkpiont $C$, $\epoch(C) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)-1] \implies C  \succeq \guattime[time=\slotstart(\prevfirstslotepoch{t}),val=v]$
    \end{enumerate}
\end{lemma}

\begin{proof}
    Follows from \Cref{lem:code-implications-of-confirmed-block-from-prev-epoch-at-the-beginning-of-epoch,lem:conf-prev-slot-canonical-at-the-start-of-an-epoch,lem:output-find-latest-canonical-canonical-at-the-start-of-an-epoch,lem:gu-e-1-canonical}.
    \RSfn{We might want to explain this a bit more}


    % If $\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})] \preceq \bconfirmed[val=v,time=\slotstart(\slot(t))]$, then apply \Cref{lem:conf-prev-slot-canonical-at-the-start-of-an-epoch,lem:output-find-latest-canonical-canonical-at-the-start-of-an-epoch} to conclude the proof.

    % Otherwise, 
    % It should be easy to conclude from \Cref{lem:conf-prev-slot-canonical-at-the-start-of-an-epoch,lem:output-find-latest-canonical-canonical-at-the-start-of-an-epoch,lem:gu-e-1-canonical}.
\end{proof}

\begin{lemma}\label{lem:if-new-bc-then-output-find-latest}
    Pick any $b_c \in  \var[val=v,time=\slotstart(\slot(t))]{\bcands}$.
    If
    \begin{enumerate}
        \item $\slot(t) > \firstslot(\epoch(t))$
        \item $\epoch(b_c) \geq \epoch(t)-1$
    \end{enumerate}
    ,then
    \begin{enumerate}
        \item $b_c \neq \var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}  \implies b_c = \var[val=v]{\findlatestconfirmeddescendant}(\var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed})$
        % \item $\var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed} \preceq b_c$
    \end{enumerate}
\end{lemma}


\begin{lemma}\label{lem:conf-beginning-epoch-prec-bcand}
    Pick any $b_c \in  \var[val=v,time=\slotstart(\slot(t))]{\bcands}$.
    If
    \begin{enumerate}
        \item $\slot(t) > \firstslot(\epoch(t))$
        \item $\epoch(b_c) \geq \epoch(t)-1$
    \end{enumerate}
    ,then, for every  $s' \in [\firstslot(\epoch(t)),\slot(t)]$,
    \begin{enumerate}
        \item $\var[val=v,time=\slotstart(s')]{\bconfirmed} \preceq b_c$
        \item $\epoch(\var[val=v,time=\slotstart(s')]{\bconfirmed}) \geq \epoch(t)-1$
    \end{enumerate}
\end{lemma}

\begin{lemma}\label{lem:canonical-for-current-epoch-with-extra-assum}
    If
    \begin{enumerate}
        \item $\slotstart(\prevfirstslotepoch{t})\geq \GST$
        % \item  $t = \slotstart(\slot(t))$
        \item $\epoch(\bconfirmed[val=v,time=\slotstart(\slot(t))])\geq\epoch(t)-1$
        \item if $\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})] \preceq \bconfirmed[val=v,time=\slotstart(\epoch(t))]$,
        then  no checkpoint $C$ s.t. $\epoch(C) = \epoch(t)-1$ and $\block(C)$ conflicts with  $\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$ can ever be justified
        % \item \ref{def:induction-conditions:ub} holds for $\var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}$
        % \item $\slotstart(\lastslot(\epoch(t)-1)) \geq \GST$
        % \item $\epoch(b_c) \geq \epoch(t)-1$
        % \item $b_c \in \filtered[val=v',time=t']$
    \end{enumerate},
    then,
    \begin{enumerate}
        \item $\canonical[blck={\bconfirmed[val=v,time=\slotstart(\slot(t))]},time=t, to=\slotstart(\epoch(t)+1)]$
    \end{enumerate}
\end{lemma}

\begin{proof}
    % First note that \Cref{lem:conf-beginning-epoch-prec-bcand, lem:output-find-latest-canonical-canonical-at-the-start-of-an-epoch} imp
    By induction on slot $\sind$.
    
    % Also, add the following inductive hypothesis.
    % \begin{enumerate}
    %     \item for any justified checkpiont $C$, $\epoch(C) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)-1] \implies C  \preceq \bconfirmed[val=v,time=\slotstart(\sind)]$
    %     \item   for any justified checkpiont $C$, $\epoch(C) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)-1] \implies C  \succeq \guattime[time=\slotstart(\prevfirstslotepoch{t}),val=v]$\RSfn{Even though $\sind$ does not appear here, I list this as an inductive hypothesis here for convenience.}    
    %     % \item $\var[val=v,time=\slotstart(\slot(\tind))]{\bconfirmed} \succeq \bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$
    %     % \item for any honest validators $v'$ and time $t'$ s.t. $\epoch(t') = \epoch(t)$, $\gjattime[time=t',val=v']  \preceq \var[val=v,time=\slotstart(\slot(\tind))]{\bconfirmed}$
    %     % \item  for any honest validators $v'$ and time $t'$ s.t. $\epoch(t') = \epoch(t)$, $\gjattime[time=t',val=v']  \succeq \guattime[time=\slotstart(\prevfirstslotepoch{t}),val=v]$
    % \end{enumerate}
    \begin{description}
        \item[Base Case: $\sind = \firstslot(\epoch(t))$.]  \Cref{lem:confirmed-end-first-slot-canonical} proves the base case.
        \item[Inductive Step: $\sind > \firstslot(\epoch(t))$.] 
        From \Cref{lem:conf-beginning-epoch-prec-bcand}, we know that $\bconfirmed[val=v,time=\slotstart(\sind)] \succeq \var[val=v,time=\slotstart(\sind-1)]{\bconfirmed}$.


        If $\var[val=v,time=\slotstart(\sind-1)]{\bconfirmed} = \bconfirmed[val=v,time=\slotstart(\sind)]$, then $\canonical[blck={\var[val=v,time=\slotstart(\sind)]{\bconfirmed}},time=t, to=\slotstart(\epoch(t)+1)]$ follows by the inductive hypothesis.

        Now, assume $\var[val=v,time=\slotstart(\sind-1)]{\bconfirmed} \neq \bconfirmed[val=v,time=\slotstart(\sind)]$.
        From \Cref{lem:if-new-bc-then-output-find-latest,lem:conf-beginning-epoch-prec-bcand}, we know that\\ $\bconfirmed[val=v,time=\slotstart(\sind)]=\findlatestconfirmeddescendant(\var[val=v,time=\slotstart(\sind-1)]{\bconfirmed})$ and $\bconfirmed[val=v,time=\slotstart(\sind)] \succeq \var[val=v,time=\slotstart(\firstslot(\epoch(\sind)))]{\bconfirmed}$.

        Then, \Cref{lem:confirmed-end-first-slot-canonical} implies that
        \begin{enumerate}
            \item for any justified checkpiont $C$, $\epoch(C) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)-1] \implies C  \preceq \bconfirmed[val=v,time=\slotstart(\sind)]$
            \item   for any justified checkpiont $C$, $\epoch(C) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)-1] \implies C  \succeq \guattime[time=\slotstart(\prevfirstslotepoch{t}),val=v]$
        \end{enumerate}

        Given that, by the inductive hypothesis, $\canonical[blck={\var[val=v,time=\slotstart(\sind-1)]{\bconfirmed}},time=t, to=\slotstart(\epoch(t)+1)]$,
        we can apply \Cref{lem:output-find-latest-canonical-canonical-at-the-start-of-an-epoch} and conclude the proof.



        % \sep

        % From \Cref{lem:conf-beginning-epoch-prec-bcand} and the extra inductive hypothesis, we know that $\bconfirmed[val=v,time=\slotstart(\sind)] \succeq \var[val=v,time=\slotstart(\sind-1)]{\bconfirmed}\succeq C$.

        % If $\var[val=v,time=\slotstart(\sind-1)]{\bconfirmed} = \bconfirmed[val=v,time=\slotstart(\sind)]$, then $\canonical[blck={\var[val=v,time=\slotstart(\sind-1)]{\bconfirmed}},time=t, to=\slotstart(\epoch(t)+1)]$ follows by the inductive hypotheses above.

        % Then, assume $\var[val=v,time=\slotstart(\sind-1)]{\bconfirmed} \neq \bconfirmed[val=v,time=\slotstart(\sind)]$.
        % From \Cref{lem:if-new-bc-then-output-find-latest}, we know that\\ $\bconfirmed[val=v,time=\slotstart(\sind)]=\findlatestconfirmeddescendant(\var[val=v,time=\slotstart(\sind-1)]{\bconfirmed})$.
        % By the inductive hypothses, we also know that $\canonical[blck={\var[val=v,time=\slotstart(\sind-1)]{\bconfirmed}},time=t, to=\slotstart(\epoch(t)+1)]$.

        % This, together with the addditional inducive hypotheses allows us to apply \Cref{lem:output-find-latest-canonical-canonical-at-the-start-of-an-epoch} and conclude the proof.
        % \Cref{lem:gj-prec-prev-confirmed-at-start-of-epoch} then implies that $\gjattime[time=t',val=v'] \preceq \var[val=v,time=\slotstart(\slot(\tind))]{\bconfirmed}$.


        % We know that 
        % \begin{enumerate}
        %     \item $\findlatestconfirmeddescendant$ ensures that\\
        %     $\mathit{isLMDGHOSTSafeFrom}(\var[val=v,time=\slotstart(\slot(\tind))]{\bconfirmed},t,\gjattime[val=v,time={\slotstart(\slot(\var[val=v]{t})-1)}],\var[val=v,time=\slotstart(\slot(t')-1)]{\bconfirmed})$ 
        %     \item  $\gjattime[time=t',val=v'] \preceq \var[val=v,time=\slotstart(\slot(\tind))]{\bconfirmed}$ implies that $\gjattime[val=v,time={\slotstart(\slot(\var[val=v]{t})-1)}] \preceq \var[val=v,time=\slotstart(\slot(\tind))]{\bconfirmed}$.
        %     % \item Given the above, $\block(\guattime[val=v,time={\slotstart(\slot(\var[val=v]{t})-1)}])  \preceq b_o$
        % \end{enumerate}
        % Hence, \sirone holds.

        % $\gjattime[time=t',val=v'] \preceq \var[val=v,time=\slotstart(\slot(\tind))]{\bconfirmed}$ and
        % \Cref{lem:conf-prev-epoch-then-vs-two-epochs-ago} then imply \ref{def:induction-conditions:all-validators:not-filtered-out}.

        % We know that $\epoch(t)-2\leq\epoch(\guattime[val=v,time={\slotstart(\prevfirstslotepoch{t})}])\leq\epoch(\gjattime[val=v,time={\slotstart(\slot(\var[val=v]{t})-1)}])\leq\epoch(\gjattime[time=t',val=v'])\leq\epoch(t)-1$.

        % If $\epoch(\gjattime[val=v,time={\slotstart(\slot(\var[val=v]{t})-1)}])=\epoch(t)-2$, 
        % then  $\gjattime[val=v,time={\slotstart(\slot(\var[val=v]{t})-1)}]= \guattime[val=v,time={\slotstart(\slot({t})-1)}]$.
        % $\sir(b_c,t,\guattime[val=v,time={\slotstart(\slot({t})-1)}],\cdot)$ then implies $\gjattime[time=t',val=v']\succeq \gjattime[val=v,time={\slotstart(\slot(\var[val=v]{t})-1)}]$.

        % If $\epoch(\gjattime[val=v,time={\slotstart(\slot(\var[val=v]{t})-1)}])=\epoch(t)-1$, 
        % then  $\gjattime[time=t',val=v'] = \gjattime[val=v,time={\slotstart(\slot(\var[val=v]{t})-1)}]$.
        % Hence, \ref{def:induction-conditions:all-validators:gj-succ} holds.


        % % $\sir(b_c,t,\guattime[val=v,time={\slotstart(\slot({t})-1)}],\cdot)$ clearly implies \ref{def:induction-conditions:all-validators:gj-succ}$(b_o,t,\guattime[val=v,time={\slotstart(\slot(\var[val=v]{t})-1)}],b_c)$.

        % % \ref{def:induction-conditions:all-validators:gj-succ-cs} is clearly implied by the Lemma's assumptions.

        % % % \ref{def:induction-conditions:ub} is cleraly implied by the Lemma's assumptions.

        % \sirfive can be proven as in the proof of \Cref{lem:conf-prev-slot-canonical-at-the-start-of-an-epoch}: from the proof of the previous conditions, we can conclude that $\canonical[time=t,blck={\var[val=v,time=\slotstart(\slot(\tind))]{\bconfirmed}},to=\slotstart(\epoch(t)+1)]$ from which we can prove that  no checkpoint for epoch $\epoch(t) = \epoch(b_o)+1$ conflicting with ${\var[val=v,time=\slotstart(\slot(\tind))]{\bconfirmed}}$ can ever be justified.
        % \ref{def:induction-conditions:ub} holding for ${\var[val=v,time=\slotstart(\slot(\tind))]{\bconfirmed}}$ implies \sirfive  for epoch $\epoch(b) = \epoch(t)-1$, 
    \end{description}
\end{proof}

\begin{lemma}\label{lem:no-conflicting-to-c-b-at-the-start-of-an-epoch}
    % Pick any $b_c \in  \var[val=v,time=\slotstart(\slot(t))]{\bcands}$, any time $t' \geq \slotstartslot{t}$ and any honest validator $v'$.
    If
    \begin{enumerate}
        \item $\slotstart(\firstslot(\epoch(t)-1)-1)\geq \GST$
        % \item  $t = \slotstart(\epoch(t))$
        \item\label{itm:lem:no-conflicting-to-c-b-at-the-start-of-an-epoch:3} \sloppy{the \KwSty{if} condition at line \Cref{ln:if-bcand-npreceq-head} during the execution of $\var[val=v,time=\slotstart(\epoch(t))]{\getlatestconfirmed}(\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})])$ is false}
        % \item\label{itm:lem:conf-prev-slot-canonical-at-the-start-of-an-epoch:4} \ref{def:induction-conditions:ub} holds for $\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$
        % \item $\slotstart(\lastslot(\epoch(t)-1)) \geq \GST$
        % \item $\epoch(b_c) \geq \epoch(t)-1$
        % \item $b_c \in \filtered[val=v',time=t']$
    \end{enumerate},
    then
    \begin{enumerate}
        \item\label{itm:lem:no-conflicting-to-c-b-at-the-start-of-an-epoch:conc1}  for any block $b' \succeq \chkp(\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})])$ and time $t' \geq \slotstart(\epoch(t))$,$\weightofset[chkp=b']{\ffgvalsetallsentraw[source=,target={\chkp(\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})])},time=t'] \setminus \slashedset[chkp=b']} \geq \frac{2}{3}\totvalsetweight[chkp=b'] {\allvals}$
        \item\label{itm:lem:no-conflicting-to-c-b-at-the-start-of-an-epoch:conc2} no checkpoint $C$ s.t. $\epoch(C) = \epoch(t)-1$ and $\block(C)$ conflicts with $\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$ can ever be justified
        % \item  if $\epoch(\guattime[time=\slotstart(\prevfirstslotepoch{t}),val=v]) \neq \epoch(t)-1$, then there exists a time $t' \in \{\slotstart(s): s \in [\firstslot(\epoch(t)-1),\lastslot(\epoch(t)-1)]\}$ such that
        % \begin{enumerate}
        %     \item  $\var[val=v,time=t']{\willChkpBeJustified}(\bconfirmed[val=v,time=t'])$.
        %     \item $\canonical[blck={\bconfirmed[val=v,time=t']},time=t',to=\slotstart(\epoch(t))]$
        %     \item $\bconfirmed[val=v,time=t'] \preceq \bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$
        %     \item $\epoch(\bconfirmed[val=v,time=t']) = \epoch(t)-1$
        % \end{enumerate}
    \end{enumerate}
\end{lemma}

\begin{proof}
    Conclusion~\ref{itm:lem:no-conflicting-to-c-b-at-the-start-of-an-epoch:conc2} is implied by conclusion~\ref{itm:lem:no-conflicting-to-c-b-at-the-start-of-an-epoch:conc1}.
    So, we just prove the latter.
    Because of condition~\ref{itm:lem:no-conflicting-to-c-b-at-the-start-of-an-epoch:3},
    we know that $\epoch(\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})])\geq\epoch(t)-1$. 
    From \Cref{lem:no-curr-epochconflict-chkp-is-justified}, we know that there exists a time $t' \in \{\slotstart(s): s \in [\firstslot(\epoch(t)-1),\lastslot(\epoch(t)-1)]\}$ such that $\var[val=v,time=t']{\willChkpBeJustified}(\bconfirmed[val=v,time=t'])$ and $\epoch(\bconfirmed[val=v,time=t'] ) = \epoch(t)-1$.
    \Cref{lem:conf-beginning-epoch-prec-bcand} then implies that $\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})] \preceq \bconfirmed[val=v,time=t'] \preceq \bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$ and $\epoch(\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})] ) \geq \epoch(t)-2$.

    Then, given Lemma 13 of the paper, to conclude the proof it is sufficient to prove that  $\canonical[blck={\bconfirmed[val=v,time=t']},time=t',to=\slotstart(\epoch(t))]$.

    Now, if  $\var[val=v,time=\slotstart(\firstslot(\epoch(t)-1)-1)]{\bconfirmed} \npreceq \bconfirmed[val=v,time=t']$, then we can apply \Cref{lem:canonical-for-current-epoch-with-extra-assum} to conclude that $\canonical[blck={\bconfirmed[val=v,time=t']},time=t',to=\slotstart(\epoch(t))]$.

    Then, assume that $\var[val=v,time=\slotstart(\firstslot(\epoch(t)-1)-1)]{\bconfirmed} \preceq \bconfirmed[val=v,time=t']$.
    In this case, to apply \Cref{lem:canonical-for-current-epoch-with-extra-assum} we need to show that no checkpoint $C$ s.t. $\epoch(C) = \epoch(t)-2$ and $\block(C)$ conflicts with  $\bconfirmed[val=v,time=\slotstart(\firstslot(\epoch(t)-1)-1)]$ can ever be justified.
    Then, let $C$ be a justified checkpoint such that $\epoch(C)=\epoch(t)-2$.
    This implies that $C = \guattime[time=\slotstart(\prevfirstslotepoch{t}),val=v]$.
    From condition~\ref{itm:lem:no-conflicting-to-c-b-at-the-start-of-an-epoch:3},
    we know that $\bconfirmed[val=v,time=\slotstart(\firstslot(\epoch(t)-1))] \succeq \guattime[time=\slotstart(\prevfirstslotepoch{t}),val=v]$.
    Given that $\var[val=v,time=\slotstart(\firstslot(\epoch(t)-1)-1)]{\bconfirmed} \preceq \bconfirmed[val=v,time=t'] \preceq \bconfirmed[val=v,time=\slotstart(\firstslot(\epoch(t)-1))]$, we can conclude that $\block(C)$ does not conflict with 
    $\bconfirmed[val=v,time=\slotstart(\firstslot(\epoch(t)-1)-1)]$    
    
    
    % Then, from \Cref{lem:epoch-gu-less-than-two-epoch-ago-start-epoch} we know that $\epoch(\guattime[time=\slotstart(\prevfirstslotepoch{t}),val=v]) \in \{\epoch(t)-2,\epoch(t)-1\}$.

    % Let $C$ be a justified checkpoint such that $\epoch(C) = \epoch(t)-1$.
    % If $\epoch(\guattime[time=\slotstart(\prevfirstslotepoch{t}),val=v]) = \epoch(t)-1$, then we are done as $\guattime[time=\slotstart(\prevfirstslotepoch{t}),val=v] = C$ and, from condition~\ref{itm:lem:no-conflicting-to-c-b-at-the-start-of-an-epoch:3}, we know that $\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})] \succeq \guattime[time=\slotstart(\prevfirstslotepoch{t}),val=v] = C$.

    % Now, assume $\epoch(\guattime[time=\slotstart(\prevfirstslotepoch{t}),val=v]) = \epoch(t)-2$.
\end{proof}

\begin{lemma}\label{lem:helper-hard-to-name}
    If
    \begin{enumerate}
        \item $\slotstart(\firstslot(\epoch(t)-1)-1)\geq \GST$
        % \item  $t = \slotstart(\epoch(t))$
        \item $\epoch(b_c) = \epoch(t)-1$
        \item either
        \begin{enumerate}[label*=\arabic*.]
            \item\label{itm:lem:helper-hard-to-name:a}  \sloppy{the \KwSty{if} condition at line \Cref{ln:if-bcand-npreceq-head} during the execution of $\var[val=v,time=\slotstart(\epoch(t))]{\getlatestconfirmed}(\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})])$ is false and $b_c \succeq \bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$.}
            \item\label{itm:lem:helper-hard-to-name:b}  $\exists b'  \in \viewattime[val=v,time=\slotstart(\prevfirstslotepoch{t})], b' \succeq b_c \land \gu(b') = \chkp(b_c)$
            % \item $b_c \succeq \block(\guattime[time=\slotstart(\prevfirstslotepoch{t}),val=v])$ and $\epoch(\guattime[time=\slotstart(\prevfirstslotepoch{t}),val=v]) = \epoch(t)-1$
        \end{enumerate}
        \item \label{itm:lem:helper-hard-to-name:cond6} $\canonical[blck={b_c},time=\slotstart(\epoch(t)),to=\slotstart(\epoch(t)+1)]$
        \item $\sir(b_c,\slotstart(\epoch(t)),\guattime[val=v,time={\slotstart(\prevfirstslotepoch{t})}],\block(\guattime[val=v,time={\slotstart(\slot(\var[val=v]{t})-1)}])).\{\sirone,\sirtwo,\sirthree\}$ holds
        % \item for any justified checkpiont $C$, $\epoch(C) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)-1] \implies C  \succeq \guattime[time=\slotstart(\prevfirstslotepoch{t}),val=v]$,


    \end{enumerate},
    then
    \begin{enumerate}
        \item $\sir(b_c,\slotstart(\epoch(t)),\guattime[val=v,time={\slotstart(\prevfirstslotepoch{t})}],\block(\guattime[val=v,time={\slotstart(\prevfirstslotepoch{t})}]))$ holds
        % \item no checkpoint $C$ s.t. $\epoch(C) = \epoch(t)-1$ and $\block(C)$ conflicts with $\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$ can ever be justified
        % \item for any honest validators $v'$ and time $t'$ s.t. $\epoch(t') = \epoch(t)$, $\gjattime[time=t',val=v']  \preceq \bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$
        % \item for any justified checkpiont $C$, $\epoch(C) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)-1] \implies C  \succeq \guattime[time=\slotstart(\prevfirstslotepoch{t}),val=v]$
        \item $\canonical[blck={b_c},time=\slotstart(\epoch(t))]$
    \end{enumerate}
\end{lemma}

\begin{proof}
    By cases.
    \begin{description}[style=nextline]
        % \item[{\parbox[t]{\linewidth}{Case 1: the \KwSty{if} condition at line \Cref{ln:if-bcand-npreceq-head} is false and $b_c \succeq {{\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]}}$ and $\epoch({\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]}) = \epoch(t)-1$.}}] \hfill\\
        \item[Case 1: condition \ref{itm:lem:helper-hard-to-name:a} holds.] 
        This case implies that $\chkp(b_c) = \chkp(\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})])$.
        % \leavevmode
        This, Lemma's conditions~\ref{itm:lem:helper-hard-to-name:cond6} and \Cref{lem:no-conflicting-to-c-b-at-the-start-of-an-epoch} allows us to to apply \Cref{assm:bcand-chkp-in-allu} to conclude \ref{def:induction-conditions:ub}.

        Given that $\epoch(b_c) = \epoch(\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]) = \epoch(t)-1$,
        \Cref{lem:no-conflicting-to-c-b-at-the-start-of-an-epoch} also implies that no justified checkpoint $C$ with $\epoch(C)=\epoch(t)-1$ and $\block(C)$ conflicting with $b_c$ can exists.



        
        \item[Case 2: condition \ref{itm:lem:helper-hard-to-name:b} holds.] 
        Given that $\epoch(b_c) = \epoch(t)-1$, \sirfour clearly holds in this case.
        Also, clearly no justified checkpoint $C$ with $\epoch(C)=\epoch(t)-1$ and $\block(C)$ conflicting with $b_c$ can exists.
    \end{description}

    Given the above, \Cref{lem:no-conflicting-to-c-b-at-the-start-of-an-epoch} and $\canonical[blck={b_c},time=\slotstart(\epoch(t)),to=\slotstart(\epoch(t)+1)]$ also imply \sirfive.

    Now, \Cref{lem:ffg-safety-from-sir} imply  $\canonical[blck={b_c},time=\slotstart(\epoch(t))]$.

    % Finally, \Cref{lem:no-conflicting-to-c-b-at-the-start-of-an-epoch} also implies that no checkpoint $C$ s.t. $\epoch(C) = \epoch(t)-1$ and $\block(C)$ conflicts with $\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$ can ever be justified

    % \sep

    % \Cref{lem:no-conflicting-to-c-b-at-the-start-of-an-epoch} also implies that there exists a time $t' \in \{\slotstart(s): s \in [\firstslot(\epoch(t)-1),\lastslot(\epoch(t)-1)]\}$ such that
    %     \begin{enumerate}
    %         \item  $\var[val=v,time=t']{\willChkpBeJustified}(\bconfirmed[val=v,time=t'])$.
    %         \item $\canonical[blck={\bconfirmed[val=v,time=t']},time=t',to=\slotstart(\epoch(t))]$
    %         \item $\bconfirmed[val=v,time=t'] \preceq \bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$
    %         \item $\epoch(\bconfirmed[val=v,time=t']) = \epoch(t)-1$
    %     \end{enumerate}

    % The above implies that $\chkp(\bconfirmed[val=v,time=t']) = \chkp(\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})])$.
    % All of this together with $\canonical[blck={\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]},time=t,to=\slotstart(\epoch(t)+1)]$ allows us to apply \Cref{assm:bcand-chkp-in-allu} to conclude \ref{def:induction-conditions:ub}.

    %  \Cref{lem:no-conflicting-to-c-b-at-the-start-of-an-epoch} and $\canonical[blck={\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]},time=t,to=\slotstart(\epoch(t)+1)]$ also imply \sirfive.

    % Now, \Cref{lem:ffg-safety-from-sir} imply  $\canonical[blck={\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]},time=t]$    
\end{proof}

\begin{lemma}\label{lem:conf-prev-slot-canonical-at-the-start-of-an-epoch-no-extra-assum}
    % Pick any $b_c \in  \var[val=v,time=\slotstart(\epoch(t))]{\bcands}$, any time $t' \geq \slotstartslot{t}$ and any honest validator $v'$.
    If
    \begin{enumerate}
        \item $\slotstart(\firstslot(\epoch(t)-1)-1)\geq \GST$
        % \item  $t = \slotstart(\epoch(t))$
        \item\label{itm:lem:conf-at-the-start-of-an-epoch-no-extra-assum:cond3} \sloppy{the \KwSty{if} condition at line \Cref{ln:if-bcand-npreceq-head} during the execution of $\var[val=v,time=\slotstart(\epoch(t))]{\getlatestconfirmed}(\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})])$ is false}
        % \item\label{itm:lem:conf-prev-slot-canonical-at-the-start-of-an-epoch:4} \ref{def:induction-conditions:ub} holds for $\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$
        % \item $\slotstart(\lastslot(\epoch(t)-1)) \geq \GST$
        % \item $\epoch(b_c) \geq \epoch(t)-1$
        % \item $b_c \in \filtered[val=v',time=t']$
    \end{enumerate},
    then
    \begin{enumerate}
        \item $\sir(\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})],\slotstart(\epoch(t)),\guattime[val=v,time={\slotstart(\prevfirstslotepoch{t})}],\block(\guattime[val=v,time={\slotstart(\prevfirstslotepoch{t})}]))$ holds
        \item no checkpoint $C$ s.t. $\epoch(C) = \epoch(t)-1$ and $C$ conflicts with $\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$ can ever be justified
        % \item for any honest validators $v'$ and time $t'$ s.t. $\epoch(t') = \epoch(t)$, $\gjattime[time=t',val=v']  \preceq \bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$
        \item for any justified checkpiont $C$, $\epoch(C) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)-1] \implies C  \preceq \bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$
        \item for any justified checkpiont $C$, $\epoch(C) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)-1] \implies C  \succeq \guattime[time=\slotstart(\prevfirstslotepoch{t}),val=v]$
        \item $\canonical[blck={\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]},time=\slotstart(\epoch(t))]$
    \end{enumerate}
\end{lemma}

\begin{proof}
    \Cref{lem:no-conflicting-to-c-b-at-the-start-of-an-epoch} proves that no checkpoint $C$ s.t. $\epoch(C) = \epoch(t)-1$ and $\block(C)$ conflicts with $\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$ can ever be justified,
    which
    allows us to apply
    \Cref{lem:conf-prev-slot-canonical-at-the-start-of-an-epoch} which implies that
    \begin{enumerate}
        \item $\sir(\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})],t,\guattime[val=v,time={\slotstart(\prevfirstslotepoch{t})}],\block(\guattime[val=v,time={\slotstart(\slot(\var[val=v]{t})-1)}])).\{\sirone,\sirtwo,\sirthree\}$ holds,  
        \item for any justified checkpiont $C$, $\epoch(C) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)-1] \implies C  \succeq \guattime[time=\slotstart(\prevfirstslotepoch{t}),val=v]$,
        \item for any justified checkpiont $C$, $\epoch(C) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)-1] \implies C  \preceq \bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$
        \item $\canonical[blck={\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]},time=t,to=\slotstart(\epoch(t)+1)]$
    \end{enumerate}

    % \Cref{lem:no-conflicting-to-c-b-at-the-start-of-an-epoch} also implies that there exists a time $t' \in \{\slotstart(s): s \in [\firstslot(\epoch(t)-1),\lastslot(\epoch(t)-1)]\}$ such that
    %     \begin{enumerate}
    %         \item  $\var[val=v,time=t']{\willChkpBeJustified}(\bconfirmed[val=v,time=t'])$.
    %         \item $\canonical[blck={\bconfirmed[val=v,time=t']},time=t',to=\slotstart(\epoch(t))]$
    %         \item $\bconfirmed[val=v,time=t'] \preceq \bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$
    %         \item $\epoch(\bconfirmed[val=v,time=t']) = \epoch(t)-1$
    %     \end{enumerate}
    Condition~\ref{itm:lem:conf-at-the-start-of-an-epoch-no-extra-assum:cond3} implies that $\bconfirmed[val=v,time=\slotstart(\epoch(t))] \succeq \bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$.\RSfn{Perhaps we can have a Lemma for this. Perhaps this Lemma then can be used in the proof of \Cref{lem:code-implications-of-confirmed-block-from-prev-epoch-at-the-beginning-of-epoch}.}
    Then, we can apply \Cref{lem:helper-hard-to-name} to conclude the proof.
    % The above implies that $\chkp(\bconfirmed[val=v,time=t']) = \chkp(\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})])$.
    % All of this together with $\canonical[blck={\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]},time=t,to=\slotstart(\epoch(t)+1)]$ allows us to apply \Cref{assm:bcand-chkp-in-allu} to conclude \ref{def:induction-conditions:ub}.

    %  \Cref{lem:no-conflicting-to-c-b-at-the-start-of-an-epoch} and $\canonical[blck={\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]},time=t,to=\slotstart(\epoch(t)+1)]$ also imply \sirfive.

    % Now, \Cref{lem:ffg-safety-from-sir} imply  $\canonical[blck={\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]},time=t]$
    % Then, given $\bconfirmed[val=v,time=t'] \preceq \bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$ and  $\canonical[blck={\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]},time=t,to=\slotstart(\epoch(t)+1)]$, $\canonical[blck={\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]},time=t,to=\slotstart(\epoch(t)+1)]$.
\end{proof}

% \begin{lemma}\label{lem:conf-prev-slot-canonical-at-the-start-of-an-epoch-no-extra-assum}
%     % Pick any $b_c \in  \var[val=v,time=\slotstart(\epoch(t))]{\bcands}$, any time $t' \geq \slotstartslot{t}$ and any honest validator $v'$.
%     If
%     \begin{enumerate}
%         \item $\slotstart(\firstslot(\epoch(t)-1)-1)\geq \GST$
%         \item  $t = \slotstart(\epoch(t))$
%         \item the \KwSty{if} condition at line \Cref{ln:if-bcand-npreceq-head} is false
%         % \item\label{itm:lem:conf-prev-slot-canonical-at-the-start-of-an-epoch:4} \ref{def:induction-conditions:ub} holds for $\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$
%         % \item $\slotstart(\lastslot(\epoch(t)-1)) \geq \GST$
%         % \item $\epoch(b_c) \geq \epoch(t)-1$
%         % \item $b_c \in \filtered[val=v',time=t']$
%     \end{enumerate},
%     then
%     \begin{enumerate}
%         \item $\sir(\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})],t,\guattime[val=v,time={\slotstart(\prevfirstslotepoch{t})}],\block(\guattime[val=v,time={\slotstart(\slot(\var[val=v]{t})-1)}]))$ holds
%         \item no checkpoint $C$ s.t. $\epoch(C) = \epoch(t)-1$ and $C$ conflicts with $\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$ can ever be justified
%         % \item for any honest validators $v'$ and time $t'$ s.t. $\epoch(t') = \epoch(t)$, $\gjattime[time=t',val=v']  \preceq \bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$
%         \item for any justified checkpiont $C$, $\epoch(C) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)-1] \implies C  \succeq \guattime[time=\slotstart(\prevfirstslotepoch{t}),val=v]$
%         \item $\canonical[blck={\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]},time=t]$
%         \item  there exists a time $t' \in \{\slotstart(s): s \in [\firstslot(\epoch(t)-1),\lastslot(\epoch(t)-1)]\}$ such that
%         \begin{enumerate}
%             \item  $\var[val=v,time=t']{\willChkpBeJustified}(\bconfirmed[val=v,time=t'])$.
%             \item $\canonical[blck={\bconfirmed[val=v,time=t']},time=t',to=\slotstart(\epoch(t)+1)]$
%             \item $\bconfirmed[val=v,time=t'] \preceq \bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$
%             \item $\epoch(\bconfirmed[val=v,time=t']) = \epoch(t)-1$
%         \end{enumerate}
%     \end{enumerate}
% \end{lemma}

% \begin{proof}
%     \Cref{lem:no-conflicting-to-c-b-at-the-start-of-an-epoch} allows us to apply
%     \Cref{lem:conf-prev-slot-canonical-at-the-start-of-an-epoch} which implies that (i) \sirone, \sirtwo and \sirthree for $\sir(\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})],t,\guattime[val=v,time={\slotstart(\prevfirstslotepoch{t})}],\block(\guattime[val=v,time={\slotstart(\slot(\var[val=v]{t})-1)}]))$ hold,  
%     (ii) for any justified checkpiont $C$, $\epoch(C) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)-1] \implies C  \succeq \guattime[time=\slotstart(\prevfirstslotepoch{t}),val=v]$,
%     and (iii) $\canonical[blck={\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]},time=t,to=\slotstart(\epoch(t)+1)]$

%     \Cref{lem:no-conflicting-to-c-b-at-the-start-of-an-epoch} also implies that there exists a time $t' \in \{\slotstart(s): s \in [\firstslot(\epoch(t)-1),\lastslot(\epoch(t)-1)]\}$ such that
%         \begin{enumerate}
%             \item  $\var[val=v,time=t']{\willChkpBeJustified}(\bconfirmed[val=v,time=t'])$.
%             \item $\canonical[blck={\bconfirmed[val=v,time=t']},time=t',to=\slotstart(\epoch(t))]$
%             \item $\bconfirmed[val=v,time=t'] \preceq \bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$
%             \item $\epoch(\bconfirmed[val=v,time=t']) = \epoch(t)-1$
%         \end{enumerate}

%     The above implies that $\chkp(\bconfirmed[val=v,time=t']) = \chkp(\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})])$.
%     All of this together with $\canonical[blck={\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]},time=t,to=\slotstart(\epoch(t)+1)]$ allows us to apply \Cref{assm:bcand-chkp-in-allu} to conclude \ref{def:induction-conditions:ub}.

%      \Cref{lem:no-conflicting-to-c-b-at-the-start-of-an-epoch} and $\canonical[blck={\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]},time=t,to=\slotstart(\epoch(t)+1)]$ also imply \sirfive.

%     Now, \Cref{lem:ffg-safety-from-sir} imply  $\canonical[blck={\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]},time=t]$
%     % Then, given $\bconfirmed[val=v,time=t'] \preceq \bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$ and  $\canonical[blck={\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]},time=t,to=\slotstart(\epoch(t)+1)]$, $\canonical[blck={\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]},time=t,to=\slotstart(\epoch(t)+1)]$.
% \end{proof}

% \begin{lemma}\label{lem:output-find-latest-canonical-canonical-at-the-start-of-an-epoch-for-ever}
%     % Pick any $b_c \in  \var[val=v,time=\slotstart(\epoch(t))]{\bcands}$, any time $t' \geq \slotstartslot{t}$ and any honest validator $v'$.
%     If
%     \begin{enumerate}
%         \item $\slotstart(\firstslot(\epoch(t)-1)-1)\geq \GST$
%         \item  $t = \slotstart(\epoch(t))$
%         \item\label{itm:lem:output-find-latest-canonical-canonical-at-the-start-of-an-epoch-for-ever:cond3} the \KwSty{if} condition at line \Cref{ln:if-bcand-npreceq-head} is false
%         % \item\label{itm:lem:conf-prev-slot-canonical-at-the-start-of-an-epoch:4} \ref{def:induction-conditions:ub} holds for $\bconfirmed[val=v,time=\slotstart(\epoch(t))]$
%         % \item $\slotstart(\lastslot(\epoch(t)-1)) \geq \GST$
%         % \item $\epoch(b_c) \geq \epoch(t)-1$
%         % \item $b_c \in \filtered[val=v',time=t']$
%     \end{enumerate},
%     then
%     \begin{enumerate}
%         \item $\sir(\bconfirmed[val=v,time=\slotstart(\epoch(t))],t,\guattime[val=v,time={\slotstart(\prevfirstslotepoch{t})}],\block(\guattime[val=v,time={\slotstart(\slot(\var[val=v]{t})-1)}]))$ holds
%         \item no checkpoint $C$ s.t. $\epoch(C) = \epoch(t)-1$ and $C$ conflicts with $\bconfirmed[val=v,time=\slotstart(\epoch(t))]$ can ever be justified
%         % \item for any honest validators $v'$ and time $t'$ s.t. $\epoch(t') = \epoch(t)$, $\gjattime[time=t',val=v']  \preceq \bconfirmed[val=v,time=\slotstart(\epoch(t))]$
%         \item for any justified checkpiont $C$, $\epoch(C) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)-1] \implies C  \preceq \bconfirmed[val=v,time=\slotstart(\epoch(t))]$
%         \item for any justified checkpiont $C$, $\epoch(C) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)-1] \implies C  \succeq \guattime[time=\slotstart(\prevfirstslotepoch{t}),val=v]$
%         \item $\canonical[blck={\bconfirmed[val=v,time=\slotstart(\epoch(t))]},time=t]$
%     \end{enumerate}
% \end{lemma}

% \begin{proof}
%     Lemma's condition~\ref {itm:lem:output-find-latest-canonical-canonical-at-the-start-of-an-epoch-for-ever:cond3}  imply that $\bconfirmed[val=v,time=\slotstart(\epoch(t))] = \var[val=v]{\findlatestconfirmeddescendant}(\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})])$.

%     \Cref{lem:conf-prev-slot-canonical-at-the-start-of-an-epoch-no-extra-assum} implies hat that no checkpoint $C$ s.t. $\epoch(C) = \epoch(t)-1$ and $\block(C)$ conflicts with $\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$ can ever be justified,which also allows us to apply
%     \Cref{lem:output-find-latest-canonical-canonical-at-the-start-of-an-epoch} which implies that
%     \begin{enumerate}
%         \item \sirone, \sirtwo and \sirthree for $\sir(\bconfirmed[val=v,time=\slotstart(\epoch(t))],t,\guattime[val=v,time={\slotstart(\prevfirstslotepoch{t})}],\block(\guattime[val=v,time={\slotstart(\slot(\var[val=v]{t})-1)}]))$ hold,  
%         \item for any justified checkpiont $C$, $\epoch(C) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)-1] \implies C  \succeq \guattime[time=\slotstart(\prevfirstslotepoch{t}),val=v]$,
%         \item for any justified checkpiont $C$, $\epoch(C) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)-1] \implies C  \preceq \bconfirmed[val=v,time=\slotstart(\epoch(t))]$
%         \item $\canonical[blck={\bconfirmed[val=v,time=\slotstart(\epoch(t))]},time=t,to=\slotstart(\epoch(t)+1)]$
%     \end{enumerate}

%     Then, apply \Cref{lem:helper-hard-to-name} to conclude the proof.
% \end{proof}

\begin{lemma}\label{lem:confirmed-end-first-slot-canonical-no-extra-assum}
    If
    \begin{enumerate}
        \item $\slotstart(\firstslot(\epoch(t)-1)-1)\geq \GST$
        % \item  $t = \slotstart(\epoch(t))$
        \item $\epoch(\bconfirmed[val=v,time=\slotstart(\epoch(t))])=\epoch(t)-1$
        % \item if $\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})] \preceq \bconfirmed[val=v,time=\slotstart(\slot(t))]$,
        % then no checkpoint $C$ s.t. $\epoch(C) = \epoch(\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})])$ and $C \neq \chkp(\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})])$ can ever be justified
        % \item \ref{def:induction-conditions:ub} holds for $\var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}$
        % \item \ref{def:induction-conditions:ub} holds for $\var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}$
        % \item $\slotstart(\lastslot(\epoch(t)-1)) \geq \GST$
        % \item $\epoch(b_c) \geq \epoch(t)-1$
        % \item $b_c \in \filtered[val=v',time=t']$
    \end{enumerate},
    then, 
    \begin{enumerate}
        \item $\sir(\bconfirmed[val=v,time=\slotstart(\epoch(t))],\slotstart(\epoch(t)),\guattime[val=v,time={\slotstart(\slot(\var[val=v]{t})-1)}],\block(\guattime[val=v,time={\slotstart(\slot(\var[val=v]{t})-1)}]))$
        \item $\canonical[blck={\bconfirmed[val=v,time=\slotstart(\epoch(t))]},time=\slotstart(\epoch(t))]$
        \item for any justified checkpiont $C$, $\epoch(C) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)-1] \implies C  \succeq \guattime[time=\slotstart(\prevfirstslotepoch{t}),val=v]$,
        \item for any justified checkpiont $C$, $\epoch(C) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)-1] \implies C  \preceq \bconfirmed[val=v,time=\slotstart(\epoch(t))]$
        \item no checkpoint $C$ s.t. $\epoch(C) = \epoch(t)-1$ and $C$ conflicts with $\bconfirmed[val=v,time=\slotstart(\epoch(t))]$ can ever be justified
    \end{enumerate}
\end{lemma}

\begin{proof}
    Below, first we prove that (i) no checkpoint $C$ s.t. $\epoch(C) = \epoch(t)-1$ and $C$ conflicts with $\bconfirmed[val=v,time=\slotstart(\epoch(t))]$ can ever be justified and (ii) we can apply
    \Cref{lem:output-find-latest-canonical-canonical-at-the-start-of-an-epoch} to conclude that
    \begin{enumerate}
        \item $\sir(\bconfirmed[val=v,time=\slotstart(\epoch(t))],t,\guattime[val=v,time={\slotstart(\prevfirstslotepoch{t})}],\block(\guattime[val=v,time={\slotstart(\slot(\var[val=v]{t})-1)}])).\{\sirone,\sirtwo,\sirthree\}$ holds,  
        \item for any justified checkpiont $C$, $\epoch(C) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)-1] \implies C  \succeq \guattime[time=\slotstart(\prevfirstslotepoch{t}),val=v]$,
        \item for any justified checkpiont $C$, $\epoch(C) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)-1] \implies C  \preceq \bconfirmed[val=v,time=\slotstart(\epoch(t))]$
        \item $\canonical[blck={\bconfirmed[val=v,time=\slotstart(\epoch(t))]},time=\slotstart(\epoch(t)),to=\slotstart(\epoch(t)+1)]$
    \end{enumerate}


    % \Cref{lem:code-implications-of-confirmed-block-from-prev-epoch-at-the-beginning-of-epoch} implies that 
% $\bconfirmed[val=v,time=\slotstart(\epoch(t))] = \var[val=v]{\findlatestconfirmeddescendant}(\block(\guattime[val=v,time=\slotstart(\prevfirstslotepoch{t})]))$.

    % Then, again per \Cref{lem:code-implications-of-confirmed-block-from-prev-epoch-at-the-beginning-of-epoch}, we can proceed by the following cases to prove that we can apply  \Cref{lem:output-find-latest-canonical-canonical-at-the-start-of-an-epoch}.

    Per \Cref{lem:code-implications-of-confirmed-block-from-prev-epoch-at-the-beginning-of-epoch}, we can proceed by the following cases.
    \begin{description}[style=nextline]
        \item[Case 1:  the \KwSty{if} condition at line \Cref{ln:if-bcand-npreceq-head} is false 
        and\\${\bconfirmed[val=v,time=\slotstart(\epoch(t))]} = {\var[val=v,time=\slotstart(\epoch(t))]{\findlatestconfirmeddescendant}(\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})])}$.]   
        
        % Lemma's condition~\ref {itm:lem:output-find-latest-canonical-canonical-at-the-start-of-an-epoch-for-ever:cond3}  imply that $\bconfirmed[val=v,time=\slotstart(\epoch(t))] = \var[val=v]{\findlatestconfirmeddescendant}(\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})])$.

        Given that $\bconfirmed[time=\slotstart(\epoch(t)),val=v]\succeq \bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$, \Cref{lem:conf-prev-slot-canonical-at-the-start-of-an-epoch-no-extra-assum} implies hat that no checkpoint $C$ s.t. $\epoch(C) = \epoch(t)-1$ and $\block(C)$ conflicts with $\bconfirmed[val=v,time=\slotstart(\epoch(t))]$ can ever be justified.
        It also allows us to apply \Cref{lem:output-find-latest-canonical-canonical-at-the-start-of-an-epoch}.


        \item[Case 2: {$\guattime[val=v,time=\slotstart(\prevfirstslotepoch{t})]=\chkp(\bconfirmed[val=v,time=\slotstart(\epoch(t))])$ and\\ 
        $\bconfirmed[val=v,time=\slotstart(\epoch(t))] = \var[val=v]{\findlatestconfirmeddescendant}(\block(\guattime[val=v,time=\slotstart(\prevfirstslotepoch{t})]))$ and $\exists b' \succeq \bconfirmed[val=v,time=\slotstart(\epoch(t))], \gu(b')=\chkp(\bconfirmed[val=v,time=\slotstart(\epoch(t))])$}.]
        This case clarly implies that no checkpoint $C$ s.t. $\epoch(C) = \epoch(t)-1$ and $\block(C)$ conflicts with $\bconfirmed[val=v,time=\slotstart(\epoch(t))]$ can ever be justified.
        \Cref{lem:gu-e-1-canonical} allows us to apply \Cref{lem:output-find-latest-canonical-canonical-at-the-start-of-an-epoch}.
    \end{description}

    Now, we can apply \Cref{lem:helper-hard-to-name} to conclude the proof.
\end{proof}

\begin{lemma}\label{lem:willNoConflictingChkpBeJustified}
    If
    \begin{enumerate}
        \item $\slot(t)>\firstslot(\epoch(t))$
        \item $\epoch(\bconfirmed[val=v,time=\slotstartslot{t}]) = \epoch(t)-1$
        \item $\bconfirmed[val=v,time=\slotstartslot{t}]\neq\bconfirmed[val=v,time=\prevslotstartslot{t}]$
    \end{enumerate}
    , then
    \begin{enumerate}
        \item $\exists b', b' \succeq \bconfirmed[val=v,time=\slotstartslot{t}] \land \epoch(b') = \epoch(t) \land \var[val=v,time=\slotstartslot{t}]{\willNoConflictingChkpBeJustified}(\chkp(b',\epoch(t)))$
    \end{enumerate}
\end{lemma}

\begin{lemma}\label{lem:conf-prev-epoch-in-current-epoch-no-nonsucc-chkp-can-be-justified}
    If
    \begin{enumerate}
        \item $\slot(t)>\firstslot(\epoch(t))$
        \item $\epoch(\bconfirmed[val=v,time=\slotstartslot{t}]) = \epoch(t)-1$
        \item $\bconfirmed[val=v,time=\slotstartslot{t}]\neq\bconfirmed[val=v,time=\prevslotstartslot{t}]$
        \item $\canonical[blck={\bconfirmed[val=v,time=\slotstartslot{t}]},time=\slotstartslot{t}]$
    \end{enumerate}
    , then
    \begin{enumerate}
        \item for any jusitified checkpoint $C$, if $\epoch(C) = \epoch(t)$, then $C\succeq \bconfirmed[val=v,time=\slotstartslot{t}]$. 
    \end{enumerate}
\end{lemma}

\begin{proof}
    From \Cref{lem:willNoConflictingChkpBeJustified} we know that $\exists b', b' \succeq \bconfirmed[val=v,time=\slotstartslot{t}] \land \epoch(b') = \epoch(t) \land \var[val=v,time=\slotstartslot{t}]{\willNoConflictingChkpBeJustified}(\chkp(b',\epoch(t)))$.
    The above and the Lemma's conditions imply that $\chkp(b',\epoch(t)) \succeq \bconfirmed[val=v,time=\slotstartslot{t}]$.

    Then, give that $\canonical[blck={\bconfirmed[val=v,time=\slotstartslot{t}]},time=\slotstartslot{t}]$, from $\var[val=v,time=\slotstartslot{t}]{\willNoConflictingChkpBeJustified}(\chkp(b',\epoch(t)))$, we know that, for any block $b'$,
    $\weightofset[chkp=b']{\bigcup_{C \succeq \bconfirmed[val=v,time=\slotstartslot{t}] \land epoch(C) = \epoch(t)} \ffgvalsetallsentraw[source=,target=C,time=\slotstart(\epoch(t)+1)] \cap \totvalset[]{\honvals}} \geq \frac{1}{3} \totvalsetweight[chkp=b']{\allvals}$

    This implies that ,for any checkpoint $C'$ such that $\epoch(C) =\epoch(t) \land C \nsucceq \bconfirmed[val=v,time=\slotstartslot{t}]$, for any time $t'$,
    $\weightofset[chkp={b'}]{\ffgvalsetallsentraw[time=t',source=,target=C']} < \frac{2}{3} \totvalsetweight[chkp=b']{\allvals} $ which concludes the proof.
\end{proof}

\begin{lemma}\label{lem:conf-prev-epoch-in-current-epoch-exists-succ-with-gu-from-prev-epoch}
    If
    \begin{enumerate}
        \item $\slot(t)>\firstslot(\epoch(t))$
        \item $\epoch(\bconfirmed[val=v,time=\slotstartslot{t}]) = \epoch(t)-1$
        \item $\bconfirmed[val=v,time=\slotstartslot{t}]\neq\bconfirmed[val=v,time=\prevslotstartslot{t}]$
    \end{enumerate}
    , then
    \begin{enumerate}
        \item $\exists b' \in \viewattime[val=v,time=\slotstartslot{t}], b' \succeq \bconfirmed[val=v,time=\slotstart(\sind)], \epoch(\gu(b'))\geq \epoch(t)-1$. 
    \end{enumerate}
\end{lemma}

\begin{lemma}\label{lem:canonical-no-extra-assum}
    If
    \begin{enumerate}
        \item $\slotstart(\prevfirstslot{\epoch(t)-1})\geq \GST$
        % \item  $t = \slotstart(\slot(t))$
        \item $\epoch(\bconfirmed[val=v,time=\slotstartslot{t}])=\epoch(t)-1$
        % \item \ref{def:induction-conditions:ub} holds for $\var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}$
        % \item $\slotstart(\lastslot(\epoch(t)-1)) \geq \GST$
        % \item $\epoch(b_c) \geq \epoch(t)-1$
        % \item $b_c \in \filtered[val=v',time=t']$
    \end{enumerate},
    then,
    \begin{enumerate}
        \item $\canonical[blck={\bconfirmed[val=v,time=\slotstartslot{t}]},time=\slotstartslot{t}]$
        \item\label{itm:lem:conf-prev-epoch-in-current-epoch-exists-succ-with-gu-from-prev-epoch:conc2} if $\epoch(\bconfirmed[val=v,time=\slotstartslot{t}]) = \epoch(t)$, then for any justified checkpiont $C$, $\epoch(C) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)] \implies C  \preceq \bconfirmed[val=v,time=\slotstart(\sind)]$
    \end{enumerate}
\end{lemma}

\begin{proof}
    By induction on slot $\sind \in [\firstslot(\epoch(t)),\slot(t)]$ we show that\\ $\canonical[blck={\bconfirmed[val=v,time=\slotstart(\sind)]},time=\slotstart(\sind)]$.
    
    % Also, add the following inductive hypothesis.
    % \begin{enumerate}
    %     % \item $\var[val=v,time=\slotstart(\slot(\tind))]{\bconfirmed} \succeq \bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$
    %     \item \label{itm:lem:canonical-no-extra-assum:ind-1}  for any justified checkpiont $C$, $\epoch(C) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)-1] \implies C  \preceq \bconfirmed[val=v,time=\slotstart(\sind)]$
    %     \item   for any justified checkpiont $C$, $\epoch(C) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)-1] \implies C  \succeq \guattime[time=\slotstart(\prevfirstslotepoch{t}),val=v]$\RSfn{Even though $\sind$ does not appear here, I list this as an inductive hypothesis here for convenience.}    
    %     \item \label{itm:lem:canonical-no-extra-assum:ind-3}no checkpoint $C$ s.t. $\epoch(C) = \epoch(t)-1$ and $C$ conflicts with $\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$ can ever be justified
    %     % \item no checkpoint $C$ s.t. $\epoch(C) = \epoch(t)-1$ and $C$ conflicts with $\bconfirmed[val=v,time=\slotstart(\epoch(t))]$ can ever be justified
    %     % \item if $\epoch(\var[val=v,time=\slotstart(\slot(\tind))]{\bconfirmed}) = \epoch(t)$, then there exists a slot $s'$ s.t. $
    % \end{enumerate}
    \begin{description}
        \item[Base Case: $\sind = \firstslot(\epoch(t))$.]  \Cref{lem:confirmed-end-first-slot-canonical-no-extra-assum} proves the base case.
    
        \item[Inductive Step: $\sind > \firstslot(\epoch(t))$.] 
        
        From \Cref{lem:conf-beginning-epoch-prec-bcand}, we know that $\bconfirmed[val=v,time=\slotstart(\sind)] \succeq \var[val=v,time=\slotstart(\sind-1)]{\bconfirmed}$.


        If $\var[val=v,time=\slotstart(\sind-1)]{\bconfirmed} = \bconfirmed[val=v,time=\slotstart(\sind)]$, then $\canonical[blck={\var[val=v,time=\slotstart(\sind)]{\bconfirmed}},time=\slotstart(\sind)]$ follows by the inductive hypothesis.

        Now, assume $\var[val=v,time=\slotstart(\sind-1)]{\bconfirmed} \neq \bconfirmed[val=v,time=\slotstart(\sind)]$.
        From \Cref{lem:if-new-bc-then-output-find-latest,lem:conf-beginning-epoch-prec-bcand}, we know that\\ $\bconfirmed[val=v,time=\slotstart(\sind)]=\findlatestconfirmeddescendant(\var[val=v,time=\slotstart(\sind-1)]{\bconfirmed})$ and $\bconfirmed[val=v,time=\slotstart(\sind)] \succeq \var[val=v,time=\slotstart(\firstslot(\epoch(\sind)))]{\bconfirmed}$.

        Then, \Cref{lem:confirmed-end-first-slot-canonical-no-extra-assum} implies that
        \begin{enumerate}
            \item \label{itm:lem:canonical-no-extra-assum:ind-1}  for any justified checkpiont $C$, $\epoch(C) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)-1] \implies C  \preceq \bconfirmed[val=v,time=\slotstart(\sind)]$
            \item   for any justified checkpiont $C$, $\epoch(C) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)-1] \implies C  \succeq \guattime[time=\slotstart(\prevfirstslotepoch{t}),val=v]$
            \item \label{itm:lem:canonical-no-extra-assum:ind-3}no checkpoint $C$ s.t. $\epoch(C) = \epoch(t)-1$ and $C$ conflicts with $\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$ can ever be justified
        \end{enumerate}

        Given that, by the inductive hypothesis, $\canonical[blck={\var[val=v,time=\slotstart(\sind-1)]{\bconfirmed}},time=\slotstart(\sind), to=\slotstart(\epoch(t)+1)]$,
        we can apply \Cref{lem:output-find-latest-canonical-canonical-at-the-start-of-an-epoch} to conclude that
        \begin{enumerate}[resume]
            \item $\canonical[blck={ \bconfirmed[val=v,time=\slotstart(\sind)]},time=\slotstart(\sind),to=\slotstart(\epoch(t)+1)]$
            \item  $\sir({ \bconfirmed[val=v,time=\slotstart(\sind)]},\slotstart(\sind),\var[val=v,time=\slotstartslot{\tind}]{\chkp_{EBA}},{ \var[val=v,time=\slotstart(\sind-1)]{\bconfirmed}}).\{\sirone,\sirtwo,\sirthree\}$ holds.
            \item  \label{itm:lem:canonical-no-extra-assum:ind-2} for any justified checkpiont $C$, $\epoch(C) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)-1] \implies C  \succeq \ceba[val=v,time=\slotstart(\sind)]$
        \end{enumerate} 



        \begin{description}
            \item\item[Case 1: ${\epoch(\bconfirmed[val=v,time=\slotstart(\sind)])=\epoch(t)-1}$.]
            Given we assume $\bconfirmed[val=v,time=\slotstart(\sind)] \neq \var[val=v,time=\slotstart(\sind-1)]{\bconfirmed}$, we can apply \Cref{lem:conf-prev-epoch-in-current-epoch-exists-succ-with-gu-from-prev-epoch} to ensure $\sirfour(\bconfirmed[val=v,time=\slotstart(\sind)])$.
            
            Then,  $\canonical[blck={ \bconfirmed[val=v,time=\slotstart(\sind)]},time=\tind,to=\slotstart(\epoch(t)+1)]$, \Cref{lem:conf-prev-epoch-in-current-epoch-no-nonsucc-chkp-can-be-justified} and condition~\ref{itm:lem:canonical-no-extra-assum:ind-3} above imply $\sirfive(\bconfirmed[val=v,time=\slotstart(\sind)],\epoch(t)-1,\epoch(t)) = \sirfive(\bconfirmed[val=v,time=\slotstart(\sind)],\epoch(\bconfirmed[val=v,time=\slotstart(\sind)]),\epoch(\bconfirmed[val=v,time=\slotstart(\sind)])+1)$.
            Hence, $\sir({ \bconfirmed[val=v,time=\slotstart(\sind)]},\tind,\var[val=v,time=\slotstartslot{\tind}]{\chkp_{EBA}},{ \var[val=v,time=\slotstart(\sind-1)]{\bconfirmed}})$ holds.
            Now, \Cref{lem:ffg-safety-from-sir} imply  $\canonical[blck={\bconfirmed[val=v,time=\slotstart(\sind)]},time=t]$ 
            \item [Case 2: ${\epoch(\bconfirmed[val=v,time=\slotstart(\sind)])=\epoch(t)}$.]
            Let $v'$ be any honest validator and $t' \in [\slotstart(\sind), \slotstart(\epoch(t)+1)]$. 
            \Cref{lem:no-curr-epochconflict-chkp-is-justified,lem:conf-beginning-epoch-prec-bcand}, Lemma 13 of the paper, and $\canonical[blck={ \bconfirmed[val=v,time=\slotstart(\sind)]},time=\slotstart(\sind),to=\slotstart(\epoch(t)+1)]$ ensure that any checkpoint $C$ s.t. $C$ is justified and $\epoch(C)=\epoch(t)$, then $C = \chkp( \bconfirmed[val=v,time=\slotstart(\sind)])$.
            This and condition~\ref{itm:lem:canonical-no-extra-assum:ind-1} imply
            conclusion~\ref{itm:lem:conf-prev-epoch-in-current-epoch-exists-succ-with-gu-from-prev-epoch:conc2}.
            Then, this,
            $\epoch(\gjattime[time=t',val=v']) \in [\epoch(\guattime[time=\slotstart(\firstslot(\epoch(t)-1))]),\epoch(t)]$, the fact that \sirone implies $\ceba[val=v,time=\slotstart(\sind)]\preceq \bconfirmed[val=v,time=\slotstart(\sind)]$, 
            and condition~\ref{itm:lem:canonical-no-extra-assum:ind-2} above, imply that  $\gjattime[time=t',val=v']  \preceq \bconfirmed[val=v,time=\slotstart(\sind)]$ and $\gjattime[time=t',val=v']  \succeq \ceba[val=v,time=\slotstart(\sind)]$.
            Then, $\sirthree(\ceba[val=v,time=\slotstart(\sind)],\slotstart(\sind),\slotstart(\epoch(t)+1))$ holds.
            \Cref{lem:conf-prev-epoch-then-vs-two-epochs-ago,lem:conf-current-epoch-then-gu-curr-epoch} then imply that $\sirtwo(\bconfirmed[val=v,time=\slotstart(\sind)],\slotstart(\sind),\slotstart(\epoch(t)+1))$ holds as well.
            Then, \Cref{lem:ffg-condition-on-q-implies-safety} implies that $\canonical[blck={ \bconfirmed[val=v,time=\slotstart(\sind)]},time=\tind,to=\slotstart(\epoch(t)+2)]$.
            All the above then implies that $\sirfive(\bconfirmed[val=v,time=\slotstart(\sind)],\epoch(t),\epoch(t)+1) = \sirfive(\bconfirmed[val=v,time=\slotstart(\sind)],\epoch(\bconfirmed[val=v,time=\slotstart(\sind)]),\epoch(\bconfirmed[val=v,time=\slotstart(\sind)])+1)$ holds.
            Finally, \Cref{lem:no-curr-epochconflict-chkp-is-justified,lem:conf-beginning-epoch-prec-bcand}, $\canonical[blck={ \bconfirmed[val=v,time=\slotstart(\sind)]},time=\tind,to=\slotstart(\epoch(t)+2)]$, \Cref{assm:bcand-chkp-in-allu} imply $\sirfour(\bconfirmed[val=v,time=\slotstart(\sind)])$.
            Now, \Cref{lem:ffg-safety-from-sir} imply  $\canonical[blck={\bconfirmed[val=v,time=\slotstart(\sind)]},time=\slotstart(\sind)]$.

            % \sep
            % With modified hypothesis this should give us that $\gjattime[time=t',val=v']  \preceq \bconfirmed[val=v,time=\slotstart(\sind)]$ from which $\gjattime[time=t',val=v']  \succeq \var[val=v,time=\slotstartslot{\tind}]{\chkp_{EBA}}$.
            % \Cref{lem:conf-prev-epoch-then-vs-two-epochs-ago} then implies that \sirtwo and \sirthree holds.
            % Then, \Cref{lem:ffg-condition-on-q-implies-safety} implies that $\canonical[blck={ \bconfirmed[val=v,time=\slotstart(\sind)]},time=\tind,to=\slotstart(\epoch(t)+2)]$.
            % All the above then implies that \sirfive holds.
            % Finally, \Cref{lem:no-curr-epochconflict-chkp-is-justified}, $\canonical[blck={ \bconfirmed[val=v,time=\slotstart(\sind)]},time=\tind,to=\slotstart(\epoch(t)+2)]$, \Cref{lem:if-new-bc-then-output-find-latest} imply \ref{def:induction-conditions:ub}.
        \end{description}

    %     \sep
        
    %     Let $v'$ be any honest validator and $t' \in [t, \slotstart(\epoch(t)+1)]$.



    %     If $\var[val=v,time=\slotstart(\sind-1)]{\bconfirmed} = \bconfirmed[val=v,time=\slotstart(\sind)]$ by the inductive hypothesis above.

    %     Otherwise, from \Cref{lem:if-new-bc-then-output-find-latest} we know that\\ $\bconfirmed[val=v,time=\slotstart(\sind)]=\findlatestconfirmeddescendant(\var[val=v,time=\slotstart(\sind-1)]{\bconfirmed})$.
    %     Then $\bconfirmed[val=v,time=\slotstart(\sind)] \succeq \var[val=v,time=\slotstart(\sind-1)]{\bconfirmed}\succeq \bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]$.

    %     We also know that $\canonical[blck={\var[val=v,time=\slotstart(\sind-1)]{\bconfirmed}},time=t]$.


    %     \begin{description}
    %         \item[Case 1: ${\epoch(\bconfirmed[val=v,time=\slotstart(\sind)])=\epoch(t)-1}$.] 
            
    %         The above, together with the additional inductive hypothesis allows us to apply \Cref{lem:output-find-latest-canonical-canonical-at-the-start-of-an-epoch} which implies that $\canonical[blck={ \bconfirmed[val=v,time=\slotstart(\sind)]},time=\tind,to=\slotstart(\epoch(t)+1)]$ and 
    %         \sirone, \sirtwo and \sirthree for $\sir({ \bconfirmed[val=v,time=\slotstart(\sind)]},\tind,\var[val=v,time=\slotstartslot{\tind}]{\chkp_{EBA}},{ \var[val=v,time=\slotstart(\sind-1)]{\bconfirmed}})$ hold
    %         Given we assume $\bconfirmed[val=v,time=\slotstart(\sind)] \neq \var[val=v,time=\slotstart(\sind-1)]{\bconfirmed}$, we know that there exists a block $b' \succeq \bconfirmed[val=v,time=\slotstart(\sind)]$ s.t. $\epoch(\gu(b'))\geq \epoch(t)-1$. 
    %         This is sufficient to ensure \ref{def:induction-conditions:ub}.

    %         Then,  $\canonical[blck={ \bconfirmed[val=v,time=\slotstart(\sind)]},time=\tind,to=\slotstart(\epoch(t)+1)]$ and the inductive hypothesis \ref{itm:lem:canonical-no-extra-assum:ind-3} imply \sirfive.
    %         Now, \Cref{lem:ffg-safety-from-sir} imply  $\canonical[blck={\bconfirmed[val=v,time=\slotstart(\sind)]},time=t]$    
    %         \item [Case 2: ${\epoch(\bconfirmed[val=v,time=\slotstart(\sind)])=\epoch(t)}$.] 
    %         We can use \Cref{lem:output-find-latest-canonical-canonical-at-the-start-of-an-epoch} to conclude \sirone.
    %         \begin{description}
    %             \item[$\epoch(t')=\epoch(t)$.]
    %             We can use \Cref{lem:output-find-latest-canonical-canonical-at-the-start-of-an-epoch} to conclude \sirtwo and \sirthree and $\canonical[blck={ \bconfirmed[val=v,time=\slotstart(\sind)]},time=\tind,to=\slotstart(\epoch(t)+1)]$.
    %             % From the inductive hypothesis \ref{itm:lem:canonical-no-extra-assum:ind-1} and \Cref{lem:conf-beginning-epoch-prec-bcand}, we can conclude that $\gjattime[time=t',val=v']  \preceq \bconfirmed[val=v,time=\slotstart(\sind)]$.
    %             % \Cref{lem:conf-prev-epoch-then-vs-two-epochs-ago} then implies \ref{def:induction-conditions:all-validators:not-filtered-out}.
    %             \item[$\epoch(t')=\epoch(t)+1$.]  
    %             \Cref{lem:no-curr-epochconflict-chkp-is-justified} and the inductive hypothesis, and $\canonical[blck={ \bconfirmed[val=v,time=\slotstart(\sind)]},time=\tind,to=\slotstart(\epoch(t)+1)]$ ensure that any checkpoint $C$ s.t. is justified and $\epoch(C)=\epoch(t)$, then $C = \chkp( \bconfirmed[val=v,time=\slotstart(\sind)])$.
    %             With modified hypothesis this should give us that $\gjattime[time=t',val=v']  \preceq \bconfirmed[val=v,time=\slotstart(\sind)]$ from which $\gjattime[time=t',val=v']  \succeq \var[val=v,time=\slotstartslot{\tind}]{\chkp_{EBA}}$.
    %             \Cref{lem:conf-prev-epoch-then-vs-two-epochs-ago} then implies that \sirtwo and \sirthree holds.
    %             Then, \Cref{lem:ffg-condition-on-q-implies-safety} implies that $\canonical[blck={ \bconfirmed[val=v,time=\slotstart(\sind)]},time=\tind,to=\slotstart(\epoch(t)+2)]$.
    %             All the above then implies that \sirfive holds.
    %             Finally, \Cref{lem:no-curr-epochconflict-chkp-is-justified}, $\canonical[blck={ \bconfirmed[val=v,time=\slotstart(\sind)]},time=\tind,to=\slotstart(\epoch(t)+2)]$, \Cref{lem:if-new-bc-then-output-find-latest} imply \ref{def:induction-conditions:ub}.
    %         \end{description}
    %         Now, \Cref{lem:ffg-safety-from-sir} imply  $\canonical[blck={\bconfirmed[val=v,time=\slotstart(\sind)]},time=\tind]$.
    %     \end{description}

    \end{description}
\end{proof}

% \begin{lemma}\label{lem:output-find-latest-canonical-canonical-at-the-start-of-an-epoch-for-ever}
%     % Let $b_o := \var[val=v]{\findlatestconfirmeddescendant}(b_c)$.
%     Let $b_c$ be a block such that
%     If
%     \begin{enumerate}
%         \item $\bconfirmed[val=v,time=\slotstart(\slot(t))] =  \var[val=v]{\findlatestconfirmeddescendant}(b_c)$
%         \item $\slotstart(\prevfirstslotepoch{t})\geq \GST$
%         % \item $\sir(b_c,t,\guattime[val=v,time={\slotstart(\slot({t})-1)}],\cdot)$ holds
%         \item $\canonical[blck=b_c,time={\var[val=v]{t}}]$
%         \item \label{itm:lem:output-find-latest-canonical-canonical-at-the-start-of-an-epoch:4}for any honest validators $v'$ and time $t'$ s.t. $\epoch(t') = \epoch(t)$, $\gjattime[time=t',val=v']  \preceq b_c$
%         \item  \label{itm:lem:output-find-latest-canonical-canonical-at-the-start-of-an-epoch:5}for any honest validators $v'$ and time $t'$ s.t. $\epoch(t') = \epoch(t)$, $\gjattime[time=t',val=v']  \succeq \guattime[time=\slotstart(\prevfirstslotepoch{t}),val=v]$
%         % \item \ref{def:induction-conditions:ub} holds for a block $b_0$ s.t. $b_0 \preceq b_c$ and $\epoch(b_0) = \epoch(t)-1$ %\bconfirmed[val=v,time=\slotstart(\prevfirstslotepoch{t})]
%         % \item $\epoch(b_c) \geq \epoch(\var[val=v]{t})-1$
%         \item $t = \slotstart(\slot(t))$

%         % \item $\var[val=v]{t} = \slotstart(\epoch(\var[val=v]{t}))$
%     \end{enumerate},
%     then
%     \begin{enumerate}
%         \item for any honest validators $v'$ and time $t'$ s.t. $\epoch(t') = \epoch(t)$, $\gjattime[time=t',val=v']  \preceq \bconfirmed[val=v,time=\slotstart(\slot(t))]$
%         \item \sirone, \sirtwo and \sirthree for $\sir(\bconfirmed[val=v,time=\slotstart(\slot(t))],t,\ceba[val=v,time=\slotstartslot{t}],b_c)$ hold
%         % \item $\sir(b_o,t,\guattime[val=v,time={\s\lotstart(\slot(\var[val=v]{t})-1)}],b_c)$, with the exception of  \ref{def:induction-conditions:ub}, holds
%         \item $\canonical[blck=b_o,time={\var[val=v]{t}}]$
%     \end{enumerate}
% \end{lemma}

\begin{lemma}\label{lem:epoch-conf-less-prev-then-conf-finalized}
    If
    \begin{enumerate}
        % \item $\slotstart(\slot(t)-1)\geq \GST$
        \item $\epoch(\bconfirmed[val=v,time=\slotstart(\slot(t))]) < \epoch(t) - 1$
        % \item $\slot(t) = \firstslot(\epoch(t))$
    \end{enumerate},
    then
    \begin{enumerate}
        \item $\bconfirmed[val=v,time=\slotstart(\slot(t))] = \block(\gfattime[time=\slotstart(\epoch(t)),val=v])$
    \end{enumerate}
\end{lemma}

\begin{lemma}
    If
    \begin{enumerate}
        \item $\slotstart(\firstslot(\epoch(t)-1)-1)\geq \GST$
        % \item  $t = \slotstart(\slot(t))$
        % \item $\epoch(\bconfirmed[val=v,time=t])=\epoch(t)-1$
        % \item \ref{def:induction-conditions:ub} holds for $\var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}$
        % \item $\slotstart(\lastslot(\epoch(t)-1)) \geq \GST$
        % \item $\epoch(b_c) \geq \epoch(t)-1$
        % \item $b_c \in \filtered[val=v',time=t']$
    \end{enumerate},
    then,
    \begin{enumerate}
        \item $\canonical[blck={\bconfirmed[val=v,time=\slotstartslot{t}]},time=\slotstart(\slot(t)+1)]$
    \end{enumerate}    
\end{lemma}
\begin{proof}
    Follows from \Cref{lem:epoch-conf-less-prev-then-conf-finalized,lem:canonical-no-extra-assum}.
\end{proof}

% \begin{lemma}
%     If
%     \begin{enumerate}
%         \item $\slotstart(\epoch(t)-1) \geq \GST$
%         \item $\epoch(\var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}) = \epoch(t)-1$
%         \item $\slot(t) = \firstslot(\epoch(t))$
%     \end{enumerate},
%     then,
%     \begin{enumerate}
%         \item $\willNoConflictingChkpBeJustified(\chkp(\var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}))$
%     \end{enumerate}
% \end{lemma}

% \begin{proof}
%     \Cref{lem:bcand-current-epoch-then-no-first-slot} together with \Cref{lem:no-curr-epochconflict-chkp-is-justified} and the synchrony assumption concludes the proof.
% \end{proof}

\begin{lemma}\label{lem:gu-prev-slot-descendant-of-gj-prev-slot}
    If
    \begin{enumerate}
        \item $\slotstart(\epoch(t)) \geq \GST$
        \item $\epoch(\bconfirmed[val=v,time=\slotstart(\slot(t))]) = \epoch(t)$
    \end{enumerate},
    then,
    \begin{enumerate}
        \item $\gjattime[val=v,time=\slotstart(\slot(t)-1)] \preceq \guattime[val=v,time=\slotstart(\prevfirstslot{\epoch(t)+1})]$.
        \item $\gjattime[val=v,time=\slotstart(\slot(t)-1)] \preceq \bconfirmed[val=v,time=\slotstart(\slot(t))]$.
        \item $\guattime[val=v,time=\slotstart(\prevfirstslot{\epoch(t)+1})] \preceq \bconfirmed[val=v,time=\slotstart(\slot(t))]$.
    \end{enumerate}
\end{lemma}

\begin{proof}
    Condition $\epoch(\bconfirmed[val=v,time=\slotstart(\slot(t))]) = \epoch(t)$ implies that $\slot(t) > \firstslot(\epoch(t))$.
    This further implies that $\epoch(\gjattime[val=v,time=\slotstart(\slot(t)-1)]) \in [\epoch(\guattime[val=v,time=\slotstart(\prevfirstslot{\epoch(t)})]),\epoch(t)-1]$.
    We also know that $\epoch(\guattime[val=v,time=\slotstart(\prevfirstslot{\epoch(t)+1})]) \in [\epoch(\guattime[val=v,time=\slotstart(\prevfirstslot{\epoch(t)})]),\epoch(t)]$.
    \Cref{lem:canonical-no-extra-assum} then implies that $\gjattime[val=v,time=\slotstart(\slot(t)-1)] \preceq \bconfirmed[val=v,time=\slotstart(\slot(t))]$ and $\guattime[val=v,time=\slotstart(\prevfirstslot{\epoch(t)+1})]\preceq \bconfirmed[val=v,time=\slotstart(\slot(t))]$.
    Given that $\epoch(\guattime[val=v,time=\slotstart(\prevfirstslot{\epoch(t)+1})])\geq\epoch(\gjattime[val=v,time=\slotstart(\slot(t)-1)] )$, this
    concludes the proof.
\end{proof}

\begin{lemma}\label{lem:bconf-curr-epoch-ancestor-is-one-confirmed}
    Pick any $b \preceq \bconfirmed[val=v,time=\slotstart(\slot(t))]$.
    If
    \begin{enumerate}
        \item $\epoch(\bconfirmed[val=v,time=\slotstart(\slot(t))]) = \epoch(t)$
        \item $\epoch(b) = \epoch(t)$
    \end{enumerate},
    then,
    \begin{enumerate}
        \item There exists slot $s > \firstslot(\epoch(t))$ such that
        {$\indicatorfromblock[from=b,to=s-1,val=v,when=\slotstart(s),chkp={C}]{\indQ}
        > \frac{1}{2}\left(1 + \frac{\boostweight[chkp={C}]}{\commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals}}\right)
        + \beta
        - \frac
            {\attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s),chkp={C}]{\slashvals}}
            {\commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals}}$},
        where $\chkp = \gjattime[val=v,time=\slotstart(s-1)]$.
    \end{enumerate}
\end{lemma}

\begin{proof}
    Because of the condition in the Lemma's statement we know that $\exists b_c \in \var[val=v,time=\slotstartslot{t}]{\bcands}$ such that $\epoch(b_c)=\epoch(t)$.
    By contradiction.
    Suppose $\exists b' \preceq b_c$ such that $\epoch(b')=\epoch(t)$, {$\indicatorfromblock[from=b',to=s-1,val=v,when=\slotstart(s),chkp={C}]{\indQ}
    \leq \frac{1}{2}\left(1 + \frac{\boostweight[chkp={C}]}{\commweightfromblock[from=b',to=s-1,chkp={C}]{\allvals}}\right)
    + \beta
    - \frac
        {\attsetweightfromblock[from=b',to=s-1,val=v,when=\slotstart(s),chkp={C}]{\slashvals}}
        {\commweightfromblock[from=b',to=s-1,chkp={C}]{\allvals}}$}.
    Given that together with the fact that \Cref{set-btcand-to-btemp} is the only place where $\bcand$ gets assigned to a block from $\epoch(t)$,
    the check in \Cref{ln:if-is-one-confirmed-second-loop} must never be true for $b'$.
    Thus either $b_c \notin \var[val=v,time=\slotstartslot{t}]{\bcands}$.
\end{proof}

\begin{assumption}\label{assum:maxratiowttoonecommittee}
    For any
    honest validator $v$,
    time $t\geq \GGST$,
    slot s,
    valid block $b$, 
    and checkpoint $C \in \allU(b)$,
    % \teffbalass $\calB$ in the view of validator $v$ at any point in time,
    $\commweightfromslot[from=s,to=s,chkp=C,when=t,val=v]{\allvals} \geq \frac{\totvalsetweight[chkp=C]{\allvals}}{\maxratiowttoonecommittee}$.
    % \footnote{Given Assumption~\ref{assum:no-change-to-the-validator-set}, an equivalent condition is assuming that $\valsetweightfromslot[from=s,to=s',chkp={\genesis}]{\honvals} \geq (1-\beta) \valsetweightfromslot[from=s,to=s',chkp={\genesis}]{\allvals}$.}
\end{assumption}

\begin{lemma}\label{lem:beta-less-than-quarter-no-reconfirmation-required}
    Let $s' := \firstslot(\epoch(t)+1)$.
    Pick any block $b$ such that $b \preceq \var[val=v,time=\slotstartslot{t}]{\bconfirmed}$.
    If
    \begin{enumerate}
        \item $\slotstart(\epoch(t)) \geq \GST$
        \item $\epoch(b) = \epoch(t)$
        \item  $\beta  \leq \frac{1}{4}$
    \end{enumerate},
    then,
    \begin{enumerate}
        \item {$
            \indicatorfromblock[from=b,to=s'-1,val=v,when=\slotstart(s'),chkp={C}]{\indQ}
            > \frac{1}{2}\left(1 + \frac{\boostweight[chkp={C}]}{\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}\right)
            + \beta
            - \frac
                {\attsetweightfromblock[from=b,to=s'-1,val=v,when=\slotstart(s'),chkp={C}]{\slashvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}$}
    \end{enumerate}
\end{lemma}

\begin{proof}
    % Let $\attsetweightfromblock[from={s},to=s'-1,val=v,when=\slotstart(s'),chkp={C}]{\allatts}$ be the total balance of validators voted in the support of block $b$ between slot $s$ and $s'-1$ inclusive according to the effective balance distribution defined by the checkpoint $C$ as per the view of validator $v$ at the start of slot $s'$.
    Let $s:=\slot(t)$.
    \def\alignexplwidth{7cm}
    \allowdisplaybreaks
    \begin{align*}
        &\hspace{3ex} \indicatorfromblock[from=b,to=s'-1,val=v,when=\slotstart(s'),chkp={C}]{\indQ}\\  
        &=
        \frac
            {\attsetweightfromblock[from=b,to=s'-1,val=v,when=\slotstart(s'),chkp={C}]{\allatts}}
            {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
        &&\alignexpl{By definition.}
        \\
        &=
        \frac
            {\commweightfromslot[from={s},to=s'-1,val=v,when=\slotstart(s'),chkp={C}]{\honvals}}
            {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
        +
        \frac
            {\attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s'),chkp={C}]{\allatts}}
            {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
        &&\alignexpl[\alignexplwidth]{First, $\attsetweightfromblock[from=b,to=s'-1,val=v,when=\slotstart(s'),chkp={C}]{\allatts} \geq \weightofset[chkp=C]{\attsetfromblock[from=b,to=s-1,val=v,when=\slotstart(s')]{\allatts}\cap \commfromblock[from=\slot(b),to=s-1]{\allvals}} + \commweightfromslot[from={s},to=s'-1,val=v,when=\slotstart(s'),chkp={C}]{\honvals}$ because $\epoch(b) = \epoch(t)$ and, due to \Cref{lem:canonical-no-extra-assum}, $\canonical[blck=b,time=\slotstart(s)]$. 
        Then 
        $\weightofset[chkp=C]{\attsetfromblock[from=b,to=s-1,val=v,when=\slotstart(s')]{\allatts}\cap \commfromblock[from=\slot(b),to=s-1]{\allvals}} = \attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s'),chkp={C}]{\allatts}$ because no validators in $\commfromslot[from=\parentslotplusone(b),to=\slot(b)-1]{\allvals} \setminus \commfromslot[from=\slot(b),to=s-1]{\allvals}$
        can have cast a valid \LMDGHOST vote for $b$. }
        \\
        &=
        \begin{aligned}[t]
            &\frac
                {\commweightfromslot[from={s},to=s'-1,val=v,when=\slotstart(s'),chkp={C}]{\honvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
            \\
            &+
            \frac
                {\attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s),chkp={C}]{\allatts} - \left(\attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s'),chkp={C}]{\slashvals}-\attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s),chkp={C}]{\slashvals}\right)}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
        \end{aligned}
        &&\alignexpl[\alignexplwidth]{As, $\attsetfromblockunfiltered[from=b,to=s-1,val=v,when=\slotstart(s')]{\allatts} = \attsetfromblockunfiltered[from=b,to=s-1,val=v,when=\slotstart(s)]{\allatts} \\ \setminus \left(\attsetfromblockunfiltered[from=b,to=s-1,val=v,when=\slotstart(s')]{\slashvals} \\ \setminus \attsetfromblockunfiltered[from=b,to=s-1,val=v,when=\slotstart(s)]{\slashvals}\right)$.}
        \\
        &=
        \begin{aligned}[t]
            &\frac
                {\commweightfromslot[from={s},to=s'-1,val=v,when=\slotstart(s'),chkp={C}]{\honvals} - \attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s'),chkp={C}]{\slashvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
            \\
            &+
            \frac
                {\attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s),chkp={C}]{\allatts}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
            +
            \frac
                {\attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s),chkp={C}]{\slashvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
        \end{aligned}
        &&\alignexpl[\alignexplwidth]{By simplification.}
        \\
        &=
        \begin{aligned}[t]
            &\frac
                {\commweightfromslot[from={s},to=s'-1,val=v,when=\slotstart(s'),chkp={C}]{\honvals} - \attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s'),chkp={C}]{\slashvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
            \\
            &+
            \frac
                {\indicatorfromblock[from=b,to=s-1,val=v,when=\slotstart(s),chkp={C}]{\indQ} \commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals}
                -2\beta\totvalsetweight[chkp=C]{\allvals}\penr}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
            +
            \frac
                {\attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s),chkp={C}]{\slashvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
        \end{aligned}
        &&\alignexpl[\alignexplwidth]{By definition.}
        \\
        &>
        \begin{aligned}[t]
            &\frac
                {\commweightfromslot[from={s},to=s'-1,val=v,when=\slotstart(s'),chkp={C}]{\honvals} - \attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s'),chkp={C}]{\slashvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
            \\
            &+
            \frac
                {\left(\frac{1}{2}\left(1 + \frac{\boostweight[chkp=C]}{\commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals}}\right) + \beta - \frac{\attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s),chkp={C}]{\slashvals}}{\commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals}}\right) \commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
            \\
            &+
            \frac
                {\attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s),chkp={C}]{\slashvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
        \end{aligned}
        &&\alignexpl[\alignexplwidth]{Due to \Cref{lem:bconf-curr-epoch-ancestor-is-one-confirmed}.}
        \\
        &=
        \begin{aligned}[t]
            &\frac
                {\commweightfromslot[from={s},to=s'-1,val=v,when=\slotstart(s'),chkp={C}]{\honvals} - \attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s'),chkp={C}]{\slashvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
            \\
            &+
            \frac
                {\frac{1}{2}\left(\commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals} 
                + \boostweight[chkp=C]\right) + \beta \commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals}-\attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s),chkp={C}]{\slashvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
            \\
            &+
            \frac
                {\attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s),chkp={C}]{\slashvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
        \end{aligned}
        &&\alignexpl[\alignexplwidth]{By simplification.}
        \\
        &\geq
        \begin{aligned}[t]
            &\frac
                {\commweightfromslot[from={s},to=s'-1,val=v,when=\slotstart(s'),chkp={C}]{\honvals} - \attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s'),chkp={C}]{\slashvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
            \\
            &+
            \frac
                {\frac{1}{2}\left(\commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals} 
                + \boostweight[chkp=C]\right) + \beta \commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
        \end{aligned}
        &&\alignexpl[\alignexplwidth]{By simplification.}
        % \\
        % &\geq
        % \begin{aligned}[t]
        %     &\frac
        %         {\commweightfromslot[from={s},to=s'-1,val=v,when=\slotstart(s'),chkp={C}]{\honvals} - \attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s'),chkp={C}]{\slashvals}}
        %         {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
        %     \\
        %     &+
        %     \frac
        %         {\left(\frac{1}{2}\left(\commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals} + \boostweight[chkp=C]\right) + \beta \commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals}\right)(1-2\penr)}
        %         {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
        % \end{aligned}
        % &&\alignexpl[\alignexplwidth]{As, $\commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals} \leq \commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals}$ and $\boostweight[chkp=C] \leq \boostweight[chkp=C]$ due to \Cref{lem:gu-prev-slot-descendant-of-gj-prev-slot} together with Assumption 1 of the Paper.}
        \\     
        &\geq
        \begin{aligned}[t]
            &\frac
                {\left(1-\beta\right) \commweightfromblock[from=s,to=s'-1,chkp={C}]{\allvals} - \attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s'),chkp={C}]{\slashvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
            \\
            &+
            \frac
                {\frac{1}{2}\left(\commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals} 
                + \boostweight[chkp=C]\right) + \beta \commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals}
                }
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
        \end{aligned}
        &&\alignexpl[\alignexplwidth]{By Assumption 2 of the paper.}
        \\
        &\geq
        \begin{aligned}[t]
            &\frac
                {\left(\frac{1}{2}+\beta \right) \commweightfromblock[from=s,to=s'-1,chkp={C}]{\allvals} - \attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s'),chkp={C}]{\slashvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
            \\
            &+
            \frac
                {\frac{1}{2}\left(\commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals} 
                + \boostweight[chkp=C]\right) + \beta \commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
        \end{aligned}
        &&\alignexpl[\alignexplwidth]{Given that $\beta \leq \frac{1}{4}$, $1-\beta \geq \frac{1}{2}+\beta$.}        
        \\
        &=
        \begin{aligned}[t]
            &\frac
                {\frac{1}{2}\left(\commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals} + \commweightfromblock[from=s,to=s'-1,chkp={C}]{\allvals} + \boostweight[chkp=C]\right)}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
            \\
            &+
            \frac
                {\left(\commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals}+ \commweightfromblock[from=s,to=s'-1,chkp={C}]{\allvals}\right) \beta - \attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s'),chkp={C}]{\slashvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
        \end{aligned}
        &&\alignexpl[\alignexplwidth]{By simplification.}
        \\
        &\geq
        \begin{aligned}[t]
            &\frac
                {\frac{1}{2}\left(\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals} + \boostweight[chkp=C]\right)}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
            \\
            &+
            \frac
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals} \beta - \attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s'),chkp={C}]{\slashvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
        \end{aligned}
        &&\alignexpl[\alignexplwidth]{As, $\commfromblock[from=b,to=s'-1]{\allvals} = \commfromblock[from=b,to=s-1]{\allvals} \cup \commfromblock[from=s,to=s'-1]{\allvals}$.}         
        \\
        &=
            \frac{1}{2}\left(1 + \frac{\boostweight[chkp=C]}{\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}\right)
            + \beta
            - \frac
                {\attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s'),chkp={C}]{\slashvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
        &&\alignexpl[\alignexplwidth]{By simplification.}
    \end{align*}
\end{proof}

\begin{lemma}\label{lem:beta-less-than-quarter-no-reconfirmation-required-bconf-prev-epoch}
    Let $s := \firstslot(\epoch(t)+1)$, $\chkp := \guattime[val=v,time=\slotstart(s-1)]$.
    If
    \begin{enumerate}
        \item $\slotstart(\epoch(t)) \geq \GST$
        \item $\epoch(\var[val=v,time=\slotstartslot{t}]{\bconfirmed}) = \epoch(t)$
        \item $\beta \leq \frac{1}{4}$
    \end{enumerate},
    then, $\forall b' \prec \var[val=v,time=\slotstartslot{t}]{\bconfirmed}$ such that $\epoch(b') = \epoch(t)-1$,
    \begin{enumerate}
        \item {$\indicatorfromblock[from=b',to=s-1,val=v,when=\slotstart(s),chkp={C}]{\indQ}
        > \frac{1}{2}\left(1 + \frac{\boostweight[chkp={C}]}{\commweightfromblock[from=b',to=s-1,chkp={C}]{\allvals}}\right)
        + \beta
        - \frac
            {\attsetweightfromblock[from=b',to=s-1,val=v,when=\slotstart(s),chkp={C}]{\slashvals}}
            {\commweightfromblock[from=b',to=s-1,chkp={C}]{\allvals}}$}
    \end{enumerate}
\end{lemma}

\begin{proof}
    Let $b$ be the lowest block in the chain of $\var[val=v,time=\slotstartslot{t}]{\bconfirmed}$ such that $\epoch(b)=\epoch(t)$.
    Given that $\commweightfromblock[from=b',to=s-1,chkp={C}]{\allvals} = \commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals} = \totvalsetweight[chkp=C]{\allvals}$,
    because $\parentslotplusone(b') \leq \parentslotplusone(b) \leq \firstslot(\epoch(t))$.
    With this in mind we proceed as the following:
    \def\alignexplwidth{5cm}
    \allowdisplaybreaks
    \begin{align*}
        \indicatorfromblock[from=b',to=s-1,val=v,when=\slotstart(s),chkp={C}]{\indQ}
        &=
        \frac
            {\attsetweightfromblock[from=b',to=s-1,val=v,when=\slotstart(s),chkp={C}]{\allatts}}
            {\commweightfromblock[from=b',to=s-1,chkp={C}]{\allvals}}
        &&\alignexpl{By definition.}
        \\
        &=
        \frac
            {\attsetweightfromblock[from=b',to=s-1,val=v,when=\slotstart(s),chkp={C}]{\allatts}}
            {\commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals}}
        &&\alignexpl{As, $\commweightfromblock[from=b',to=s-1,chkp={C}]{\allvals} = \commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals}$.}
        \\
        &\geq
        \frac
            {\attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s),chkp={C}]{\allatts}}
            {\commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals}}
        &&\alignexpl{As, $\attsetfromblockunfiltered[from=b,to=s-1,val=v,when=\slotstart(s)]{\allatts} \subseteq \attsetfromblockunfiltered[from=b',to=s-1,val=v,when=\slotstart(s)]{\allatts}$, because $b' \prec b$.}
        \\
        &\geq
        \indicatorfromblock[from=b,to=s-1,val=v,when=\slotstart(s),chkp={C}]{\indQ}
        &&\alignexpl{By definition.}
        \\
        &> \frac{1}{2}\left(1 + \frac{\boostweight[chkp={C}]}{\commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals}}\right)
        + \beta
        - \frac
            {\attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s),chkp={C}]{\slashvals}}
            {\commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals}}
        &&\alignexpl{Due to \Cref{lem:beta-less-than-quarter-no-reconfirmation-required}.}
        \\
        &> \frac{1}{2}\left(1 + \frac{\boostweight[chkp={C}]}{\commweightfromblock[from=b',to=s-1,chkp={C}]{\allvals}}\right)
        + \beta
        - \frac
            {\attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s),chkp={C}]{\slashvals}}
            {\commweightfromblock[from=b',to=s-1,chkp={C}]{\allvals}}
        &&\alignexpl{As, $\commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals} = \commweightfromblock[from=b',to=s-1,chkp={C}]{\allvals}$.}
        \\
        &> \frac{1}{2}\left(1 + \frac{\boostweight[chkp={C}]}{\commweightfromblock[from=b',to=s-1,chkp={C}]{\allvals}}\right)
        + \beta
        - \frac
            {\attsetweightfromblock[from=b',to=s-1,val=v,when=\slotstart(s),chkp={C}]{\slashvals}}
            {\commweightfromblock[from=b',to=s-1,chkp={C}]{\allvals}}
        &&\alignexpl{As, $\attsetfromblockunfiltered[from=b,to=s-1,val=v,when=\slotstart(s)]{\slashvals} \subseteq \attsetfromblockunfiltered[from=b',to=s-1,val=v,when=\slotstart(s)]{\slashvals}$.}
    \end{align*}
\end{proof}

\begin{lemma}
    Let $s := \firstslot(\epoch(t)+1)$, $\chkp := \guattime[val=v,time=\slotstart(s-1)]$.
    If
    \begin{enumerate}
        \item $\slotstart(\epoch(t)-1) \geq \GST$
        \item $\epoch(\var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}) = \epoch(t)-1$
        \item $\beta \leq \frac{1}{4}$
    \end{enumerate},
    then, $\forall b \succeq \guattime[val=v,time=\slotstart(\slot(t)-1)]$ such that $b \preceq \var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed}$,
    \begin{enumerate}
        \item {$\indicatorfromblock[from=b,to=s-1,val=v,when=\slotstart(s),chkp={C}]{\indQ}
        > \frac{1}{2}\left(1 + \frac{\boostweight[chkp={C}]}{\commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals}}\right)
        + \beta
        - \frac
            {\attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s),chkp={C}]{\slashvals}}
            {\commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals}}$}
    \end{enumerate}
\end{lemma}

\begin{proof}
    Due to \Cref{lem:conf-current-epoch-then-gu-curr-epoch} we know that $\exists b' \in \viewattime[val=v,time=\slotstart(\slot(t)-1)], b' \succeq \var[val=v,time=\slotstart(\slot(t)-1)]{\bconfirmed} \land \epoch(\gu(b')) \geq \epoch(t)-2$.
    Then we can conclude that $\epoch(\guattime[val=v,time=\slotstart(\slot(t)-1)]) \geq \epoch(t)-2$.
    By cases.
    \begin{description}
        \item[Case 1: {$\epoch(b') = \epoch(t)-1$}.] Apply \Cref{lem:beta-less-than-quarter-no-reconfirmation-required}.
        \item[Case 2: {$\epoch(b') \neq \epoch(t)-1$}.] Implies $\epoch(b') = \epoch(t)-2$. Apply \Cref{lem:beta-less-than-quarter-no-reconfirmation-required-bconf-prev-epoch}.
    \end{description}
\end{proof}

\section{Improve performance with missed slots}

\begin{algorithm}[t]
    \vbox{
    \small
    \begin{numbertabbing}\reset
    xxxx\=xxxx\=xxxx\=xxxx\=xxxx\=xxxx\=MMMMMMMMMMMMMMMMMMM\=\kill
    \textbf{function} $\ghostvoters[block=b, view=\View]$\label{}\\
    \> \textbf{return } $\{\signer(a) : a \in \ghostsinview(\View) \land \block(a) \succeq b \}$\label{}\\[1ex]
    \textbf{function} $\fcparam[fc=\GHOST,balf=\frakB](\View, t)$\label{}\\
    \> $b \gets \genesis$ \label{}\\
    \> \textbf{while} $\exists b' \in \children[blck=b,view=\blocksinview(\View]),\; slot(b') \leq \slot(t)$ \label{}\\
    \>\> $b \gets \argmax_{b' \in \children[blck=b,view=\blocksinview(\View]) \land \slot(b') \leq \slot(t)}\weightofset[chkp={\frakB(\View,t)}]{\ghostvoters[block=b, view={\View}]}$\label{ln:alg:GHOST:argmax}\\
    \> \textbf{end while}\label{}\\
    \> \textbf{return} $b$\label{}\\
    [-5ex]
    \end{numbertabbing}
    }
    \caption{\GHOST fork-choice}\label{alg:GHOST}
\end{algorithm}

\begin{algorithm}[t]
    \vbox{
    \small
    \begin{numbertabbing}\reset
    xxxx\=xxxx\=xxxx\=xxxx\=xxxx\=xxxx\=MMMMMMMMMMMMMMMMMMM\=\kill
    \textbf{function} $\FILEQ(\View)$\label{}\\
    \> \textbf{return } $\begin{aligned}[t]
        \View \setminus \{a \in \ghostsinview(\View) : \exists a',a'' \in \ghostsinview(\View), \; &\land \signer(a) = \signer(a') = \signer(a'') \\
        &\land \slot(a') = \slot(a'') \\
        &\land \block(a') \neq \block(a'') \}
    \end{aligned}$\label{}\\[1ex]
    \textbf{function} $\FILLMD(\View)$\label{}\\
    \> \textbf{return } $\View \setminus \{a \in \ghostsinview(\View) : \exists a' \in \View, \; \signer(a') = \signer(a) \land \slot(a) < \slot(a')  \}$\label{}\\[1ex]
    \textbf{function} $\FILINV(\View)$\label{}\\
    \> \textbf{return } $\View \setminus \{a \in \ghostsinview(\View) : \slot(a)  \notin \commfromslot[from=\slot(a),to=\slot(a)]{\allvals} \lor \slot(\block(a)) > \slot(a) \}$\label{}\\[1ex]
    \textbf{function} $\FILCUR(\View, t)$\label{}\\
    \> \textbf{return } $\View \setminus \{a \in \blocksinview(\View) : \slot(a) \geq \slot(t)  \}$\label{}\\[1ex]
    \textbf{function} $\fcparam[fc=\LMDGHOST,balf=\frakB](\View, t)$\label{}\\
    \> \textbf{return} $\fcparam[fc=\GHOST,balf=\frakB](\FILLMD(\FILINV(\FILCUR(\FILEQ(\View),t))), t)$\label{}\\
    [-5ex]
    \end{numbertabbing}
    }
    \caption{\LMDGHOST fork-choice}\label{alg:lmd-ghost}
\end{algorithm}

\begin{assumption}\label{assum:no-change-to-the-validator-set}
    The only change that can occur to the validator set and effective balances is due to Byzantine validators potentially getting slashed.
    In other words, no new validator is ever added to the validator set, no rewards are incurred, and honest validators never exit or incur penalties.
    This immediately implies that
    \begin{enumerate}
        \item $\commatepoch[epoch=e]{\allvals}\subseteq\commatepoch[epoch=\epoch(\genesis)]{\allvals}=\totvalset[chkp=\genesis]{\allvals}$
        \item $\commatepoch[epoch=e]{\honvals} = \commatepoch[epoch=\epoch(\genesis)]{\honvals} = \totvalset[chkp=\genesis]{\honvals}$
        % \item for any valid block $b$ and honest validator $v$, $\totvalsetweight[chkp=b]{\honvals}=\totvalsetweight[chkp=\genesis]{\honvals}$ and $\totvalsetweight[chkp=b]{\allvals}\leq\totvalsetweight[chkp=\genesis]{\allvals}$
        \item for any valid block $b$ and honest validator $v$, $\weightofset[chkp=b]{v}=\weightofset[chkp=\genesis]{v}$
        \item for any valid block $b$ and Byzantine validator $v$, $\weightofset[chkp=b]{v}\leq\weightofset[chkp=\genesis]{v}$
    \end{enumerate}
\end{assumption}

\begin{assumption}\label{assum:beta}
    There exists a constant $\beta$, known to anyone using the Confirmation Rule,
    such that,
    for any
    honest validator $v$,
    time $t\geq \GGST$,
    two slots $s'$ and $s$,
    valid block $b$, 
    and checkpoint $C \in \allU(b)$,
    % \teffbalass $\calB$ in the view of validator $v$ at any point in time,
    $\commweightfromslot[from=s,to=s',chkp=C,when=t,val=v]{\honvals} \geq (1-\beta) \commweightfromslot[from=s,to=s',chkp=C,when=t,val=v]{\allvals}$.
    % \footnote{Given Assumption~\ref{assum:no-change-to-the-validator-set}, an equivalent condition is assuming that $\valsetweightfromslot[from=s,to=s',chkp={\genesis}]{\honvals} \geq (1-\beta) \valsetweightfromslot[from=s,to=s',chkp={\genesis}]{\allvals}$.}
\end{assumption}

% Let $\attsettobediscfromblock[from=b,to=s,when=t,val=v]{\allatts}$ be the set of validators in $\commfromslot[from=\parentslotplusone(b), to=\slot(b)-1,when=t,val=v]{\allvals}\setminus \commfromslot[from=\slot(b), to=s,when=t,val=v]{\allvals}$ that, according to $\viewattime[val=v,time=t]$, have sent a \GHOST vote that \LMDGHOST voted \emph{exactly} for $\parent(b)$, \ie, not for any $b' \succ \parent(b)$, just exactly for $\parent(b)$.

Let $\attsettobediscfromblock[from=b,to=s,when=t,val=v]{\allatts}$ be the set of validators in $\commfromslot[from=\slot(\parent(b))+1, to=s,when=t,val=v]{\allvals}$ that, according to view $\FILLMD(\FILINV(\FILCUR(\FILEQ(\viewattime[val=v,time=t]),t)))$, have sent a \GHOST vote that \emph{does not} \LMDGHOST voted for a block $\succ \parent(b)$, \ie, it \LMDGHOST votes for either a block $\preceq \parent(b)$ or a block conflicting with $\parent(b)$.


Let $\attsettobediscfromblock[from=b,to=s,when=t,val=v]{\honatts}$ be $\attsettobediscfromblock[from=b,to=s,when=t,val=v]{\allatts} \cap \honvals$.

\begin{definition}
    $$
    \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\honattsub}
    =
    \max\left(
        \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\allatts}
        -\beta \commweightfromblock[from=b',to=\slot(b)-1,chkp=C]{\allvals}
        +\attsetweightfromblock[from=b',to=\slot(b)-1,val=v,when=t,chkp=C]{\slashvals}
        ,0
    \right)    
    $$
\end{definition}

\begin{definition}[\LMDGHOST safety condition]
    The \LMDGHOST safety condition for block $b$ according to checkpoint $C$ and the view of validator $v$ at time $t\geq\GGST$ corresponds to the following condition, formally named $\var[val=v]{\mathrm{isLMDGHOSTSafe}}(b,C,t)$.
    $$\var[val=v]{\mathrm{isLMDGHOSTSafe}}(b,C,t) := \forall b' \preceq b,\;
    \begin{aligned}[t]
            &\indicatorfromblock[from=b',to=\slot(t)-1,val=v,when=t,chkp=C]{\indQ}
            >
                \frac{1}{2}
                    \left( 1+
                        \frac
                        {
                            \boostweight[chkp=C] 
                            -\attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\honattsub}              
                        }
                        {\commweightfromblock[from=b',to=\slot(t)-1,chkp=C,when=t,val=v]{\allvals}}
                    \right)
                + \beta 
                \\
                &\lor
                b' = \genesis
    \end{aligned}
                $$
\end{definition}

\begin{lemma}[Analogous of Lemma 2 in the paper]\label{lem:condition-on-h-for-canonical-ex}
    Let $v$ be any honest validator, $t$ be any time and $b$ be any block, if
    \begin{enumerate}
        \item $t\geq \GGST$,
        \item $\chain(b) \subseteq \viewattime[time=t,val=v]$,
        \item $\slot(b) \leq \slot(t)$ and
        \item $\forall b' \preceq b,\;
        \attsetweightfromblock[from=b',to=\slot(t)-1,val=v,when=t,chkp={\gjattime[val=v,time=t]}]{\honatts}
        >
        \frac
            {
                \commweightfromblock[from=b',to=\slot(t)-1,chkp={\gjattime[val=v,time=t]}]{\allvals}
                -\attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\honatts}
                +\boostweight[chkp={\gjattime[val=v,time=t]}]}
            {2}
        $,
    \end{enumerate}
    then block $b$ is canonical in the view of validator $v$ at time $t$.
\end{lemma}

\begin{proof}
    % Let $\View$ be the view of an arbitrary honest validator $v$ by the time it casts its vote in slot $s+1$.
    % As per the protocol definition, $v$ will cast its vote for the block outputted by $\LMDGHOSTHFC(\View, M)$.
    % Hence, our objective is to prove that $\LMDGHOSTHFC(\View, M) \in desc(b)$.


    We want to prove that $b \preceq \fcparam[fc=\LMDGHOST,balf=\gjviewsym,val=v](t)$.

    Let $b_i$ be the value of the variable $b$ at the end of the $i$-th iteration of the \textbf{while} loop %executed by $\LMDGHOSTHFC(\View, M)$
    of Algorithm~\ref{alg:GHOST}, with $b_0$ corresponding to the value of the variable $b$ at the beginning of the first iteration.
    We now prove by induction on $i$ that either $b_i \succeq b$ or $b_i \preceq b$. %$b_i \succeq b \lor b_i \preceq b$.

    \begin{description}
        \item[Base case: $i=0$.]
        Trivial as the \textbf{while} loop in Algorithm~\ref{alg:lmd-ghost} starts with variable $b$ set to $\genesis \preceq b$.

        \item[Inductive step.]
        By the inductive hypothesis, we assume that $b_i \succeq b \lor b_i \preceq b$ and prove that $b_{i+1} \succeq b \lor b_{i+1} \preceq b$.
        By line~\ref{ln:alg:GHOST:argmax} of Algorithm~\ref{alg:GHOST}, $b_{i+1}$ is the descendant of $b_i$ with the heaviest total weight.
        Let us proceed by cases.
        \begin{description}
            \item[Case $b_i \succeq b$.]
            This immediately implies that $b_{i+1} \succeq b$.

            \item[Case $b_i \prec b$.]
            Let $b_c$ be the child of $b_i$ in the chain of $b$, \ie, $b_c \preceq b \land \parent(b_c) = b_i$, and let $b'$ be any child of $b_i$.
            Let $\FIL_\LMDGHOST(\View, t) := \FILLMD(\FILINV(\FILCUR(\FILEQ(\View),t)))$ and
            note that, for $\LMDGHOST^{\gjviewsym}$, the argument of $\argmax$ at line~\ref{ln:alg:GHOST:argmax} of Algorithm~\ref{alg:GHOST} corresponds to $\weightofset[chkp={\gjattime[time=t,val=v]}]{\ghostvoters[block=b',view={\FIL_\LMDGHOST(\View), t}]}$.
            Due to \FILINV and \FILCUR, such expression can evaluate at most to the weight of the the committees between slot $\slot(b_i)+1$ and slot $\slot(t)-1$ plus, potentially, the proposer boost weight, less the weight of the honest validators in the committees between $\slot(b_i)+1$ and $\slot(t)-1$ that have already \LMDGHOST voted for a block $\nsucceq b_i$, \ie, $
            \commweightfromblock[from={b},to={\slot(t)-1},chkp={\gjattime[time=t,val=v]}]{\allvals} 
            + \boostweight[chkp={\gjattime[val=v,time=t]}]
            -\attsetweighttobediscfromblock[from=b',to=\slot(t)-1,val=v,when=t,chkp=C]{\honatts}
            $.
            % Note that $\FILLATE(\FILCUR(\FILINV(\View), t), t) \subseteq \FIL_\LMDGHOST(\View, t)$.
            Given that honest validators never equivocate, we have that
            $$
            \weightofset[chkp={\gjattime[time=t,val=v]}]{\ghostvoters[block=b_c,view={\FIL_\LMDGHOST(\View, t)}]}
            \geq
            \attsetweightfromblock[from=b_c,to=\slot(t)-1,val=v,when=t,chkp={\gjattime[val=v,time=t]}]{\honatts}
            >
            \frac
                {\commweightfromblock[from=b,to=\slot(t)-1,chkp={\gjattime[val=v,time=t]}]
                {\allvals}
                -\attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\honatts}
                +\boostweight[chkp={\gjattime[val=v,time=t]}] }{2}
            $$

            Take any $b' \neq b_c$.
            Given that honest validators never equivocates, the maximum amount of weight that can vote for a descendant of $\parent(b)$  

            This means that $b'$ and $b_c$ conflict which implies that
            
            \begin{align*}
                \weightofset[chkp={\gjattime[time=t,val=v]}]{\ghostvoters[block=b',view={\FIL_\LMDGHOST(\View, t)}]} 
                &< 
                \begin{aligned}[t]
                    &\commweightfromblock[from={b},to={\slot(t)-1},chkp={\gjattime[time=t,val=v]}]{\allvals}
                    -\attsetweighttobediscfromblock[from=b',to=\slot(t)-1,val=v,when=t,chkp=C]{\honatts} 
                    + \boostweight[chkp={\gjattime[val=v,time=t]}] 
                    \\
                    &-  \weightofset[chkp={\gjattime[time=t,val=v]}]{\ghostvoters[block=b_c,view={\FIL_\LMDGHOST(\View, t)}]}
                \end{aligned}
                \\                
                &\leq 
                \begin{aligned}[t]
                    &\commweightfromblock[from={b},to={\slot(t)-1},chkp={\gjattime[time=t,val=v]}]{\allvals}
                    -\attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\honatts} 
                    + \boostweight[chkp={\gjattime[val=v,time=t]}] 
                    \\
                    &-  \weightofset[chkp={\gjattime[time=t,val=v]}]{\ghostvoters[block=b_c,view={\FIL_\LMDGHOST(\View, t)}]}
                \end{aligned}
                &&\alignexpl[2cm]{As $\attsetweighttobediscfromblock[from=b',to=\slot(t)-1,val=v,when=t,chkp=C]{\honatts}\geq\attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\honatts}$.}
                \\
                &\leq
                \frac
                {\commweightfromblock[from=b,to=\slot(t)-1,chkp={\gjattime[val=v,time=t]}]
                {\allvals}
                -\attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\honatts}
                +\boostweight[chkp={\gjattime[val=v,time=t]}] }{2}
            \end{align*}

            This furhter implies that
            $b_c = b_{i+1}$ and hence $b_{i+1} \preceq b$.
            % $\attsetweightfromblock[from=b',to=\slot(t)-1,val=v,when=t,chkp={\gjattime[val=v,time=t]}]{\allatts}$
        \end{description}
    \end{description}

    Note that any block in $\chain(b)$ has at least one child, except potentially for $b$.
    Note also that the \textbf{while} loop continues till it finds a block that either is for a slot higher than $\slot(t)$ or that has no valid children.
    Given that we assume $\slot(b) \leq \slot(t)$, honest validators never \GHOST vote for an invalid block
    and that above we have established that $\fcparam[fc=\LMDGHOST,balf=\gjviewsym,val=v](t) \succeq b \lor \fcparam[fc=\LMDGHOST,balf=\gjviewsym,val=v](t) \preceq b$, we can conclude the proof for this Lemma.
\end{proof}

% \begin{definition}\label{def:safety-indicator-1-ex}
%     Let $\indicatordiscfromblock[from=b,to=s',val=v,when=t,chkp=\calB]{\indP}:=\frac{\attsetweightfromblock[from=b,to=s',val=v,when=t,chkp=\calB]{\honatts}}{\commweightfromblock[from=b,to=s',chkp=\calB,when=t,val=v]{\honvals}-\attsetweighttobediscfromblock[from=b,to=s',when=t,val=v,chkp=\calB]{\honatts}}$.
% \end{definition}

% \begin{lemma}\label{lem:lmd-p-monotonic-ex}
%     Given Assumption~\ref{assum:no-change-to-the-validator-set}\RSfn{Left like this in case we copy the assumption from the paper in here},
%     for any two honest validator $v$ and $v'$, block $b$, times $t'$ and $t$, and any two checkpoints $C$ and $C'$,
%     if
%     \begin{enumerate}
%         \item $\slotstart(\slot(t)-1)\geq\GGST$,
%         \item $t'\geq \slotstart(\slot(t))$ and
%         \item all honest validators in the committees for slots $[\slot(t),\slot(t') -1]$ \GHOST vote in support of $b$,
%     \end{enumerate}
%     then
%     $$
%     \forall b' \preceq b,\;
%     \indicatordiscfromblock[from=b',to=\slot(t')-1,val=v',when=t',chkp={C'}]{\indP}
%     \geq
%     \indicatordiscfromblock[from=b',to=\slot(t)-1,val=v,when=t,chkp={C}]{\indP}
%     $$
% \end{lemma}

% \begin{proof}
%     Let $s := \slot(t)$, $s' := \slot(t')$, and $b'$ any block such that $b' \preceq b$.
%     Then we can proceed as follows.
%     \def\alignexplwidth{7cm}
%     \allowdisplaybreaks
%     \begin{align*}
%         &\quad\indicatordiscfromblock[from=b',to=s'-1,val=v,when=t',chkp={C '}]{\indP}
%         \\  
%         % &=
%         % \frac
%         %     {\attsetweightfromblock[from=b', to=s'-1,val=v',when=t', chkp={C '}]{\honatts}}
%         %     {\commweightfromblock[from=b', to=s'-1, chkp={C '}]{\honvals}
%         %     -\attsetweighttobediscfromblock[from=b',to=s'-1,when=t,val=v',chkp=C']{\allatts}}
%         % &&\alignexpl[\alignexplwidth]{By definition.}
%         % \\
%         &=
%         \frac
%             {\attsetweightfromblock[from=b', to=s'-1,val=v',when=t', chkp={C}]{\honatts}}
%             {\commweightfromblock[from=b', to=s'-1, chkp={C}]{\honvals}
%             -\attsetweighttobediscfromblock[from=b',to=s'-1,when=t',val=v',chkp=C]{\honatts}}
%         &&\alignexpl[\alignexplwidth]{As, per Assumption~\ref{assum:no-change-to-the-validator-set}, the effictive balance of honest validators never changes.}
%         \\
%         &=
%         \frac
%         {
%             \attsetweightfromblock[from=b', to=s'-1, val=v, when=t', chkp={C}]{\honatts}
%         }
%         {
%             \commweightfromblock[from=b', to=s'-1, chkp={C}]{\honvals}
%             -\attsetweighttobediscfromblock[from=b',to=s'-1,when=t',val=v,chkp=C]{\honatts}
%         }
%         &&\alignexpl[\alignexplwidth]{Given that $\slotstart(s'-1)\geq\slotstart(s-1)\geq\GGST$ and $t' \geq \slotstart(s')$, any honest attestation for slots up to $s'-1$ received by $v'$ at time $t'$, it is also received by $v'$ by the same time $t'$.}\\
%         &=
%         \frac
%         {
%             \attsetweightfromblock[from=b', to=s-1, val=v, when=t, chkp={C}]{\honatts}
%             +
%             \weightofset[chkp=C]{
%                 \commfromslot[from=s, to=s'-1]{\honvals}
%                 \setminus
%                 \attsetfromblockunfiltered[from=b', to=s-1, val=v, when=t]{\honatts}
%             }
%         }
%         {
%             \commweightfromblock[from=b', to=s'-1, chkp={C}]{\honvals}
%             -\attsetweighttobediscfromblock[from=b',to=s'-1,when=t',val=v,chkp=C]{\honatts}
%         }
%         &&\alignexpl[\alignexplwidth]{$\attsetfromblockunfiltered[from=b', to=s'-1, val=v, when=t']{\honatts}$ corresponds to the union of the honest validators whose \GHOST votes in support of $b$ and for slots up to $s-1$ are in the view of validator $v$ at time $t$ with the honest validators in the committees between slot $s$ ans slot $s'-1$, as we assume that any of these validators has \GHOST voted in support of $b$ and $\slotstart(\slot(s))\geq \GGST$.}
%         \\
%         &=
%         \frac
%         {
%             \begin{aligned}[t]
%                 &\attsetweightfromblock[from=b', to=s-1, val=v,when=t, chkp={C}]{\honatts}
%                 +
%                 \weightofset[chkp=C]{
%                     \commfromslot[from=s, to=s'-1]{\honvals}
%                     \setminus
%                     \attsetfromblockunfiltered[from=b', to=s-1, val=v, when=t]{\honatts}
%                     \setminus
%                     \attsettobediscfromblock[from=b',to=s-1,when=t,val=v]{\honatts}
%                 }
%                 \\
%                 &+
%                 \weightofset[chkp=C]{
%                     \attsettobediscfromblock[from=b,to=s-1,when=t,val=v]{\honatts}
%                     \cap
%                     \commfromslot[from=s, to=s'-1]{\honvals}
%                 }
%             \end{aligned}
%         }
%         {
%             \commweightfromblock[from=b', to=s'-1, chkp={C}]{\honvals}
%             -\attsetweighttobediscfromblock[from=b',to=s'-1,when=t',val=v,chkp=C]{\honatts}
%         } 
%         &&\alignexpl[\alignexplwidth]{
%             As $|A| = |A\setminus B| + |A \cap B|$ and 
%             $\attsettobediscfromblock[from=b,to=s-1,when=t,val=v]{\honatts}
%                     \cap
%             \left(\commfromslot[from=s, to=s'-1]{\honvals}
%                     \setminus
%                     \attsetfromblockunfiltered[from=b', to=s-1, val=v, when=t]{\honatts}\right)
%                     =
%             \attsettobediscfromblock[from=b,to=s-1,when=t,val=v]{\honatts}
%                     \cap
%             \commfromslot[from=s, to=s'-1]{\honvals}$ because 
%             $\attsetfromblockunfiltered[from=b', to=s-1, val=v, when=t]{\honatts} \cap \attsettobediscfromblock[from=b,to=s-1,when=t,val=v]{\honatts} =\emptyset $ by definition.
%         }
%         \\        
%         &=
%         \frac
%         {
%             \begin{aligned}[t]
%                 &\attsetweightfromblock[from=b', to=s-1, val=v,when=t, chkp={C}]{\honatts}
%                 +
%                 \weightofset[chkp=C]{
%                     \commfromslot[from=s, to=s'-1]{\honvals}
%                     \setminus
%                     \attsetfromblockunfiltered[from=b', to=s-1, val=v, when=t]{\honatts}
%                     \setminus
%                     \attsettobediscfromblock[from=b,to=s-1,when=t,val=v]{\honatts}
%                 }
%                 \\
%                 &+
%                 \weightofset[chkp=C]{
%                     \attsettobediscfromblock[from=b',to=s-1,when=t,val=v]{\honatts}
%                     \cap
%                     \commfromslot[from=s, to=s'-1]{\honvals}
%                 }
%             \end{aligned}
%         }
%         {
%             \begin{aligned}[t]
%                 &\commweightfromblock[from=b', to=s-1, chkp={C}]{\honvals}
%                 +
%                 \weightofset[chkp=C]{
%                     \commfromslot[from=s, to=s'-1]{\honvals}
%                     \setminus
%                     \commfromblock[from=b', to=s-1]{\honvals}
%                 }
%                 -\attsetweighttobediscfromblock[from=b',to=s'-1,when=t',val=v,chkp=C]{\honatts}
%             \end{aligned}
%         } 
%         &&\alignexpl[\alignexplwidth]{By definition}
%         \\        
%         &=
%         \frac
%         {
%             \begin{aligned}[t]
%                 &\attsetweightfromblock[from=b', to=s-1, val=v,when=t, chkp={C}]{\honatts}
%                 +
%                 \weightofset[chkp=C]{
%                     \commfromslot[from=s, to=s'-1]{\honvals}
%                     \setminus
%                     \attsetfromblockunfiltered[from=b', to=s-1, val=v, when=t]{\honatts}
%                     \setminus
%                     \attsettobediscfromblock[from=b,to=s-1,when=t,val=v]{\honatts}
%                 }
%                 \\
%                 &+
%                 \weightofset[chkp=C]{
%                     \attsettobediscfromblock[from=b,to=s-1,when=t,val=v]{\honatts}
%                     \cap
%                     \commfromslot[from=s, to=s'-1]{\honvals}
%                 }
%             \end{aligned}
%         }
%         {
%             \begin{aligned}[t]
%                 &\commweightfromblock[from=b', to=s-1, chkp={C}]{\honvals}
%                 +
%                 \weightofset[chkp=C]{
%                     \commfromslot[from=s, to=s'-1]{\honvals}
%                     \setminus
%                     \commfromblock[from=b', to=s-1]{\honvals}
%                     \setminus
%                     \attsettobediscfromblock[from=b,to=s-1,when=t,val=v]{\honatts}
%                 }
%                 \\
%                 &-
%                 \left(
%                     \attsetweighttobediscfromblock[from=b',to=s-1,when=t,val=v,chkp=C]{\honatts}
%                     -
%                     \weightofset[chkp=C]{
%                     \attsettobediscfromblock[from=b,to=s-1,when=t,val=v]{\honatts}
%                     \cap
%                     \commfromslot[from=s, to=s'-1]{\honvals}
%                     }
%                 \right) 
%             \end{aligned}
%         } 
%         &&\alignexpl[\alignexplwidth]{By definition}
%         \\
%         &\geq
%         \frac
%         {
%             \attsetweightfromblock[from=b', to=s-1, val=v, when=t, chkp={C}]{\honatts}
%         }
%         {
%             \commweightfromblock[from=b', to=s-1, chkp={C}]{\honvals}
%             -\attsetweighttobediscfromblock[from=b',to=s-1,when=t,val=v,chkp=C]{\honatts}
%         }
%         &&\alignexpl[\alignexplwidth]{
%             From,
%                 $\attsetfromblockunfiltered[from=b', to=s-1, val=v, when=t]{\honatts} \subseteq \commfromblock[from=b', to=s-1]{\honvals}$ and the fact that
%                 $\frac{a+x}{b+y} \geq \frac{a}{b}$, if $a \leq b \land x \geq y$.
%         }
%         \\
%         &=
%         \indicatordiscfromblock[from=b',to=s-1,val=v,when=t,chkp={C}]{\indP}
%     \end{align*}
% \end{proof}

% \begin{proof}
%     Let $s := \slot(t)$, $s' := \slot(t')$, and $b'$ any block such that $b' \preceq b$.
%     Then we can proceed as follows.
%     \def\alignexplwidth{7cm}
%     \allowdisplaybreaks
%     \begin{align*}
%         &\quad\indicatordiscfromblock[from=b',to=s'-1,val=v,when=t',chkp={C '}]{\indP}
%         \\  
%         &=
%         \frac
%             {\attsetweightfromblock[from=b', to=s'-1,val=v',when=t', chkp={C '}]{\honatts}}
%             {\commweightfromblock[from=b', to=s'-1, chkp={C '}]{\honvals}
%             -\attsetweighttobediscfromblock[from=b',to=s'-1,when=t,val=v',chkp=C']{\honatts}}
%         &&\alignexpl[\alignexplwidth]{By definition.}
%         \\
%         &=
%         \frac
%             {\attsetweightfromblock[from=b', to=s'-1,val=v',when=t', chkp={C}]{\honatts}}
%             {\commweightfromblock[from=b', to=s'-1, chkp={C}]{\honvals}
%             -\attsetweighttobediscfromblock[from=b',to=s'-1,when=t',val=v',chkp=C]{\honatts}}
%         &&\alignexpl[\alignexplwidth]{As, per Assumption~\ref{assum:no-change-to-the-validator-set}, the effictive balance of honest validators never changes.}
%         \\
%         &=
%         \frac
%         {
%             \attsetweightfromblock[from=b', to=s'-1, val=v, when=t', chkp={C}]{\honatts}
%         }
%         {
%             \commweightfromblock[from=b', to=s'-1, chkp={C}]{\honvals}
%             -\attsetweighttobediscfromblock[from=b',to=s'-1,when=t',val=v,chkp=C]{\honatts}
%         }
%         &&\alignexpl[\alignexplwidth]{Given that $\slotstart(s'-1)\geq\slotstart(s-1)\geq\GGST$ and $t' \geq \slotstart(s')$, any honest attestation for slots up to $s'-1$ received by $v'$ at time $t'$, it is also received by $v'$ by the same time $t'$.}\\
%         &=
%         \frac
%         {
%             \attsetweightfromblock[from=b', to=s-1, val=v, when=t, chkp={C}]{\honatts}
%             +
%             \weightofset[chkp=C]{
%                 \commfromslot[from=s, to=s'-1]{\honvals}
%                 \setminus
%                 \attsetfromblockunfiltered[from=b', to=s-1, val=v, when=t]{\honatts}
%             }
%         }
%         {
%             \commweightfromblock[from=b', to=s'-1, chkp={C}]{\honvals}
%         }
%         &&\alignexpl[\alignexplwidth]{$\attsetfromblockunfiltered[from=b', to=s'-1, val=v, when=t']{\honatts}$ corresponds to the union of the honest validators whose \GHOST votes in support of $b$ and for slots up to $s-1$ are in the view of validator $v$ at time $t$ with the honest validators in the committees between slot $s$ ans slot $s'-1$, as we assume that any of these validators has \GHOST voted in support of $b$ and $\slotstart(\slot(s))\geq \GGST$.}\\
%         &=
%         \frac
%         {
%             \begin{aligned}[t]
%                 &\attsetweightfromblock[from=b', to=s-1, val=v,when=t, chkp={C}]{\honatts}
%                 +
%                 \weightofset[chkp=C]{
%                     \commfromslot[from=s, to=s'-1]{\honvals}
%                     \setminus
%                     \attsetfromblockunfiltered[from=b', to=s-1, val=v, when=t]{\honatts}
%                     \setminus
%                     \attsettobediscfromblock[from=b,to=s-1,when=t,val=v]{\honatts}
%                 }
%                 \\
%                 &+
%                 \weightofset[chkp=C]{
%                     \attsettobediscfromblock[from=b,to=s-1,when=t,val=v]{\honatts}
%                     \cap
%                     \commfromslot[from=s, to=s'-1]{\honvals}
%                 }
%             \end{aligned}
%         }
%         {
%             \begin{aligned}[t]
%                 &\commweightfromblock[from=b', to=s-1, chkp={C}]{\honvals}
%                 +
%                 \weightofset[chkp=C]{
%                     \commfromslot[from=s, to=s'-1]{\honvals}
%                     \setminus
%                     \commfromblock[from=b', to=s-1]{\honvals}
%                     \setminus
%                     \attsettobediscfromblock[from=b,to=s-1,when=t,val=v]{\honatts}
%                 }
%                 \\
%                 &-
%                 \left(
%                     \attsetweighttobediscfromblock[from=b',to=s-1,when=t,val=v,chkp=C]{\honatts}
%                     -
%                     \weightofset[chkp=C]{
%                     \attsettobediscfromblock[from=b,to=s-1,when=t,val=v]{\honatts}
%                     \cap
%                     \commfromslot[from=s, to=s'-1]{\honvals}
%                     }
%                 \right) 
%             \end{aligned}
%         } 
%         &&\alignexpl[\alignexplwidth]{By definition}\\
%         &\geq
%         \frac
%         {
%             \attsetweightfromblock[from=b', to=s-1, val=v, when=t, chkp={C}]{\honatts}
%         }
%         {
%             \commweightfromblock[from=b', to=s-1, chkp={C}]{\honvals}
%         }
%         &&\alignexpl[\alignexplwidth]{
%             From,
%                 $\attsetfromblockunfiltered[from=b', to=s-1, val=v, when=t]{\honatts} \subseteq \commfromblock[from=b', to=s-1]{\honvals}$ and the fact that
%                 $\frac{a+x}{b+y} \geq \frac{a}{b}$, if $a \leq b \land x \geq y$.
%         }
%         \\
%         &=
%         \indicatorfromblock[from=b',to=s-1,val=v,when=t,chkp={C}]{\indP}
%     \end{align*}
% \end{proof}

\begin{lemma}[Analogous to Lemma 1 in the paper]\label{lem:lmd-p-monotonic-ex}
    Given Assumption~\ref{assum:no-change-to-the-validator-set},
    for any two honest validator $v$ and $v'$, block $b$, times $t'$ and $t$, and any two checkpoints $C$ and $C'$,
    if
    \begin{enumerate}
        \item $\slotstart(\slot(t)-1)\geq\GGST$,
        \item $t'\geq \slotstart(\slot(t))$ and
        \item all honest validators in the committees for slots $[\slot(t),\slot(t') -1]$ \GHOST vote in support of $b$,
    \end{enumerate}
    then
    $$
    \forall b' \preceq b,\;
    \indicatorfromblock[from=b',to=\slot(t')-1,val=v',when=t',chkp={C'}]{\indP}
    \geq
    \indicatorfromblock[from=b',to=\slot(t)-1,val=v,when=t,chkp={C}]{\indP}
    +
    \frac
    {
        \weightofset[chkp=C]{
            \attsettobediscfromblock[from=b',to=\slot(b')-1,when=t,val=v]{\honatts}
            \cap
            \commfromslot[from=\slot(t), to=\slot(t'-1]{\honvals}
        }
    }
    {
        \commweightfromblock[from=b', to=\slot(t)-1, chkp={C}]{\honvals}
    }      
    $$
\end{lemma}

\begin{proof}
    Let $s := \slot(t)$, $s' := \slot(t')$, and $b'$ any block such that $b' \preceq b$.
    Then we can proceed as follows.
    \def\alignexplwidth{7cm}
    \allowdisplaybreaks
    \begin{align*}
        &\quad\indicatorfromblock[from=b',to=s'-1,val=v,when=t',chkp={C '}]{\indP}
        \\  
        % &=
        % \frac
        %     {\attsetweightfromblock[from=b', to=s'-1,val=v',when=t', chkp={C '}]{\honatts}}
        %     {\commweightfromblock[from=b', to=s'-1, chkp={C '}]{\honvals}
        %     -\attsetweighttobediscfromblock[from=b',to=s'-1,when=t,val=v',chkp=C']{\allatts}}
        % &&\alignexpl[\alignexplwidth]{By definition.}
        % \\
        &=
        \frac
            {\attsetweightfromblock[from=b', to=s'-1,val=v',when=t', chkp={C}]{\honatts}}
            {\commweightfromblock[from=b', to=s'-1, chkp={C}]{\honvals}}
        &&\alignexpl[\alignexplwidth]{As, per Assumption~\ref{assum:no-change-to-the-validator-set}, the effictive balance of honest validators never changes.}
        \\
        &=
        \frac
        {
            \attsetweightfromblock[from=b', to=s'-1, val=v, when=t', chkp={C}]{\honatts}
        }
        {
            \commweightfromblock[from=b', to=s'-1, chkp={C}]{\honvals}
        }
        &&\alignexpl[\alignexplwidth]{Given that $\slotstart(s'-1)\geq\slotstart(s-1)\geq\GGST$ and $t' \geq \slotstart(s')$, any honest attestation for slots up to $s'-1$ received by $v'$ at time $t'$, it is also received by $v'$ by the same time $t'$.}\\
        &=
        \frac
        {
            \attsetweightfromblock[from=b', to=s-1, val=v, when=t, chkp={C}]{\honatts}
            +
            \weightofset[chkp=C]{
                \commfromslot[from=s, to=s'-1]{\honvals}
                \setminus
                \attsetfromblockunfiltered[from=b', to=s-1, val=v, when=t]{\honatts}
            }
        }
        {
            \commweightfromblock[from=b', to=s'-1, chkp={C}]{\honvals}
        }
        &&\alignexpl[\alignexplwidth]{$\attsetfromblockunfiltered[from=b', to=s'-1, val=v, when=t']{\honatts}$ corresponds to the union of the honest validators whose \GHOST votes in support of $b$ and for slots up to $s-1$ are in the view of validator $v$ at time $t$ with the honest validators in the committees between slot $s$ ans slot $s'-1$, as we assume that any of these validators has \GHOST voted in support of $b$ and $\slotstart(\slot(s))\geq \GGST$.}
        \\
        &=
        \frac
        {
            \begin{aligned}[t]
                &\attsetweightfromblock[from=b', to=s-1, val=v,when=t, chkp={C}]{\honatts}
                +
                \weightofset[chkp=C]{
                    \commfromslot[from=s, to=s'-1]{\honvals}
                    \setminus
                    \attsetfromblockunfiltered[from=b', to=s-1, val=v, when=t]{\honatts}
                    \setminus
                    \attsettobediscfromblock[from=b',to=\slot(b')-1,when=t,val=v]{\honatts}
                }
                \\
                &+
                \weightofset[chkp=C]{
                    \attsettobediscfromblock[from=b',to=\slot(b')-1,when=t,val=v]{\honatts}
                    \cap
                    \commfromslot[from=s, to=s'-1]{\honvals}
                }
            \end{aligned}
        }
        {
            \commweightfromblock[from=b', to=s'-1, chkp={C}]{\honvals}
        } 
        &&\alignexpl[\alignexplwidth]{
            As $|A| = |A\setminus B| + |A \cap B|$ and 
            $\attsettobediscfromblock[from=b',to=\slot(b')-1,when=t,val=v]{\honatts}
                    \cap
            \left(\commfromslot[from=s, to=s'-1]{\honvals}
                    \setminus
                    \attsetfromblockunfiltered[from=b', to=s-1, val=v, when=t]{\honatts}\right)
                    =
            \attsettobediscfromblock[from=b',to=\slot(b')-1,when=t,val=v]{\honatts}
                    \cap
            \commfromslot[from=s, to=s'-1]{\honvals}$ because 
            $\attsetfromblockunfiltered[from=b', to=s-1, val=v, when=t]{\honatts} \cap \attsettobediscfromblock[from=b',to=\slot(b')-1,when=t,val=v]{\honatts} =\emptyset $ by definition.
        }
        \\        
        &=
        \frac
        {
            \begin{aligned}[t]
                &\attsetweightfromblock[from=b', to=s-1, val=v,when=t, chkp={C}]{\honatts}
                +
                \weightofset[chkp=C]{
                    \commfromslot[from=s, to=s'-1]{\honvals}
                    \setminus
                    \attsetfromblockunfiltered[from=b', to=s-1, val=v, when=t]{\honatts}
                    \setminus
                    \attsettobediscfromblock[from=b',to=\slot(b')-1,when=t,val=v]{\honatts}
                }
                \\
                &+
                \weightofset[chkp=C]{
                    \attsettobediscfromblock[from=b',to=\slot(b')-1,when=t,val=v]{\honatts}
                    \cap
                    \commfromslot[from=s, to=s'-1]{\honvals}
                }
            \end{aligned}
        }
        {
            \begin{aligned}[t]
                &\commweightfromblock[from=b', to=s-1, chkp={C}]{\honvals}
                +
                \weightofset[chkp=C]{
                    \commfromslot[from=s, to=s'-1]{\honvals}
                    \setminus
                    \commfromblock[from=b', to=s-1]{\honvals}
                }
            \end{aligned}
        } 
        &&\alignexpl[\alignexplwidth]{By definition}
        \\        
        &=
        \frac
        {
            \begin{aligned}[t]
                &\attsetweightfromblock[from=b', to=s-1, val=v,when=t, chkp={C}]{\honatts}
                +
                \weightofset[chkp=C]{
                    \commfromslot[from=s, to=s'-1]{\honvals}
                    \setminus
                    \attsetfromblockunfiltered[from=b', to=s-1, val=v, when=t]{\honatts}
                    \setminus
                    \attsettobediscfromblock[from=b',to=\slot(b')-1,when=t,val=v]{\honatts}
                }
                \\
                &+
                \weightofset[chkp=C]{
                    \attsettobediscfromblock[from=b',to=\slot(b')-1,when=t,val=v]{\honatts}
                    \cap
                    \commfromslot[from=s, to=s'-1]{\honvals}
                }
            \end{aligned}
        }
        {
            \begin{aligned}[t]
                &\commweightfromblock[from=b', to=s-1, chkp={C}]{\honvals}
                +
                \weightofset[chkp=C]{
                    \commfromslot[from=s, to=s'-1]{\honvals}
                    \setminus
                    \commfromblock[from=b', to=s-1]{\honvals}
                    \setminus
                    \attsettobediscfromblock[from=b',to=\slot(b')-1,when=t,val=v]{\honatts}
                }
            \end{aligned}
        } 
        &&\alignexpl[\alignexplwidth]{As $\attsettobediscfromblock[from=b',to=\slot(b')-1,when=t,val=v]{\honatts}\subseteq\commfromblock[from=b', to=s-1]{\honvals} $.}
        \\
        &\geq
        \frac
        {
            \attsetweightfromblock[from=b', to=s-1, val=v, when=t, chkp={C}]{\honatts}
            +
            \weightofset[chkp=C]{
                \attsettobediscfromblock[from=b',to=\slot(b')-1,when=t,val=v]{\honatts}
                \cap
                \commfromslot[from=s, to=s'-1]{\honvals}
            }
        }
        {
            \commweightfromblock[from=b', to=s-1, chkp={C}]{\honvals}
        }
        &&\alignexpl[\alignexplwidth]{
            From,
                $\attsetfromblockunfiltered[from=b', to=s-1, val=v, when=t]{\honatts} \subseteq \commfromblock[from=b', to=s-1]{\honvals}$ and the fact that
                $\frac{a+x}{b+y} \geq \frac{a}{b}$, if $a \leq b \land x \geq y$.
        }
        \\
        &=
        \indicatorfromblock[from=b',to=s-1,val=v,when=t,chkp={C}]{\indP}
        +
        \frac
        {
            \weightofset[chkp=C]{
                \attsettobediscfromblock[from=b',to=\slot(b')-1,when=t,val=v]{\honatts}
                \cap
                \commfromslot[from=s, to=s'-1]{\honvals}
            }
        }
        {
            \commweightfromblock[from=b', to=s-1, chkp={C}]{\honvals}
        }        
    \end{align*}
\end{proof}

\begin{lemma}[Analogous of Lemma 3 in the paper]\label{lem:lmd-cond-on-p-implies-cond-on-h-ex}
    Given Assumption~\ref{assum:beta},
    for any time $t\geq\GGST$,
    honest validator $v$,
    block $b$,
    slot $s$,% such that $slot(b) \leq s$ % \leq \slotattime{t}$
    and checkpoint $C \in \allU(b)$ with $b$ being any valid block,\\% that is canonical in the view of validator $v$ at time $t$,\\
    if
    $$
    \forall b' \preceq b,\;
    \indicatorfromblock[from=b',to=s,val=v,when=t,chkp=C]{\indP}
    > \frac{1}{2(1-\beta)}
    \left( 1+
        \frac
            {
                \boostweight[chkp=C]
                -
                \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\honattsub}
            }
        {\commweightfromblock[from=b',to=s,chkp=C]{\allvals}}
    \right)
    $$
    then,
    $$
    \forall b' \preceq b,\;
    \attsetweightfromblock[from=b',to=s,val=v,when=t,chkp=C]{\honatts}
    >
    \frac
    {
        \commweightfromblock[from=b',to=s,chkp=C]{\allvals} + \boostweight[chkp=C]
        - \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\honatts}  
    }
    {2}
    $$.
\end{lemma}



\begin{proof}
    Let $b'$ by any block such that $b' \preceq b$.
    Now we can proceed as follows.
    \def\alignexplwidth{4cm}
    \begin{align*}
        \attsetweightfromblock[from=b',to=s,val=v,when=t,chkp=C]{\honatts}
        &=
        \indicatorfromblock[from=b',to=s,val=v,when=t,chkp=C]{\indP}  \commweightfromblock[from=b',to=s,chkp=C]{\honvals}
        &&\alignexpl{By definition}
        \\
        &>
        \frac{\commweightfromblock[from=b',to=s,chkp=C]{\honvals}}{2(1-\beta)}
        \left( 1+
            \frac
            {
                \boostweight[chkp=C]
                -
                \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\honattsub}
            }
            {\commweightfromblock[from=b',to=s,chkp=C]{\allvals}}
        \right)
        &&\alignexpl[\alignexplwidth]{By expanding the condition on \indicatorfromblock[from=b',to=s,val=v,when=t,chkp=C]{\indP}}\\
        &\geq
        \frac{\commweightfromblock[from=b',to=s,chkp=C]{\allvals}(1-\beta)}{2(1-\beta)}
        \left( 1+
            \frac
            {
                \boostweight[chkp=C]
                -
                \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\honattsub}
            }
            {\commweightfromblock[from=b',to=s,chkp=C]{\allvals}}
        \right)
        &&\alignexpl{As, due to Assumption~\ref{assum:beta}, $\commweightfromblock[from=b',to=s,chkp=C]{\honvals} \geq \commweightfromblock[from=b',to=s,chkp=C]{\allvals}(1-\beta)$}\\
        &=
        \frac
        {
            \commweightfromblock[from=b',to=s,chkp=C]{\allvals} 
            + \boostweight[chkp=C]
            -
            \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\honattsub}            
        }
        {2}
        \\
        &\geq
        \frac
        {
            \commweightfromblock[from=b',to=s,chkp=C]{\allvals} 
            + \boostweight[chkp=C]
            - \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\honatts}      
        }
        {2}        
    \end{align*}
\end{proof}

\begin{lemma}[Analogous of Lemma 4 in the paper]\label{lem:lmd-cond-on-q-implies-cond-on-p-ex2}
    Given Assumption~\ref{assum:beta},
    for any time $t\geq\GGST$,
    honest validator $v$,
    block $b'$,
    slot $s$
    % such that $slot(b') \leq s$ % \leq \slotattime{t}$
    and checkpoint $C \in \allU(b')$ with $b'$ being any valid block,\\
    % that is canonical in the view of validator $v$ at time $t$ and
    % checkpoint $C$,\\
    % Let $b'$, $v$, $s$, $t$, $C$ and $C$ be any block, honest validator, slot, time and two checkpoints respectively.
    if
    $$
    \indicatorfromblock[from=b',to=s,val=v,when=t,chkp=C]{Q}
    >
    \frac{1}{2}
        \left( 1+
            \frac
            {
                \boostweight[chkp=C] 
                -\attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\honattsub}                  
            }
            {\commweightfromblock[from=b',to=s,chkp=C]{\allvals}}
        \right)
        + \beta
    $$, then
    $$
    \indicatorfromblock[from=b',to=s,val=v,when=t,chkp=C]{\indP}
    >
    \frac{1}{2(1-\beta)}
        \left( 1+
            \frac
            {
                \boostweight[chkp=C] 
                -\attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\honattsub}                  
            }
            {\commweightfromblock[from=b',to=s,chkp=C]{\allvals}}
        \right)
    $$
\end{lemma}

\begin{proof}
We proceed as follows.\\
\def\alignexplwidth{5cm}
\begin{align*}
    \indicatorfromblock[from=b',to=s,val=v,when=t,chkp=C]{\indP}
    &=
    \frac
    {\attsetweightfromblock[from=b',to=s,val=v,when=t,chkp=C]{\honatts}}
    {\commweightfromblock[from=b',to=s,chkp=C]{\honvals}}
    &&\alignexpl[\alignexplwidth]{By definition.}
    \\
    &\geq
    \frac
    {\attsetweightfromblock[from=b',to=s,val=v,when=t,chkp=C]{\allatts}-
    \commweightfromblock[from=b',to=s,chkp=C]{\advvals}}
    {\commweightfromblock[from=b',to=s,chkp=C]{\honvals}}
    &&\alignexpl[\alignexplwidth]{By definition, $\commweightfromblock[from=b',to=s,chkp=C]{\advvals}= \valsetfromblock[from=b',to=s,chkp=C]{\allvals}  \setminus \honvals$.}
    \\
    &=
    \frac
    {\attsetweightfromblock[from=b',to=s,val=v,when=t,chkp=C]{\allatts}-
    \commweightfromblock[from=b',to=s,chkp=C]{\advvals}}
    {\commweightfromblock[from=b',to=s,chkp=C]{\allvals} - \commweightfromblock[from=b',to=s,chkp=C]{\advvals}}
    &&\alignexpl[\alignexplwidth]{By definition, $\commweightfromblock[from=b',to=s,chkp=C]{\allvals} = \commweightfromblock[from=b',to=s,chkp=C]{\honvals} + \commweightfromblock[from=b',to=s,chkp=C]{\advvals}$.}
    \\    
    &\geq
    \frac
    {\attsetweightfromblock[from=b',to=s,val=v,when=t,chkp=C]{\allatts}-
    \beta \commweightfromblock[from=b',to=s,chkp=C]{\allvals}}
    {\commweightfromblock[from=b',to=s,chkp=C]{\allvals} - \beta \commweightfromblock[from=b',to=s,chkp=C]{\allvals}}
    &&\alignexpl[\alignexplwidth]{
        By Assumption~\ref{assum:beta}, $\commweightfromblock[from=b',to=s,chkp=C]{\advvals}\leq \beta \commweightfromblock[from=b',to=s,chkp=C]{\allvals}$, and, given that $\attsetweightfromblock[from=b',to=s,val=v,when=t,chkp=C]{\allatts} \leq \commweightfromblock[from=b',to=s,chkp=C]{\allvals}$, the function $g(x)=\frac{\attsetweightfromblock[from=b',to=s,val=v,when=t,chkp=C]{\allatts}-x}{\commweightfromblock[from=b',to=s,chkp=C]{\allvals}-x}$ is monotone decreasing in $[0,\commweightfromblock[from=b',to=s,chkp=C]{\allvals}]$
    }
    \\
    &=
    \frac
    {\attsetweightfromblock[from=b',to=s,val=v,when=t,chkp=C]{\allatts}-
    \beta \commweightfromblock[from=b',to=s,chkp=C]{\allvals}}
    {\commweightfromblock[from=b',to=s,chkp=C]{\allvals}}
    \left( \frac{1}{1-\beta} \right)
    &&\alignexpl[\alignexplwidth]{Simplification.}
    \\
    &=
    \left(\indicatorfromblock[from=b',to=s,val=v,when=t,chkp=C]{\indQ}  -\beta\right)\left(\frac{1}{1-\beta}\right)
    &&\alignexpl[\alignexplwidth]{Simplification.}
    \\
    &>
        \frac{1}{2(1-\beta)}
            \left( 1+
                \frac
                {
                    \boostweight[chkp=C] 
                    -\attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\honattsub}                  
                }
                {\commweightfromblock[from=b',to=s,chkp=C]{\allvals}}
            \right)
    &&\alignexpl[\alignexplwidth]{By applying the condition on $\indicatorfromblock[from=b',to=s,val=v,when=t,chkp=C]{\indQ}$.}
\end{align*}
\end{proof}

\begin{lemma}[Analogous to Lemma 6 of the paper]\label{lem:condition-on-q-implies-safety-ex}
    Given Assumptions~\ref{assum:no-change-to-the-validator-set} and \ref{assum:beta},
    %~\ref{assum:beta}, \ref{assum:sync}, \ref{assum:ffg-assumptions:beta} and \ref{assum:oracle-access-to-committee-selection},
    let $v$ be any honest validator,
    $t$ and $t'$ be any two times and
    $b$ be any block,
    if
    \begin{enumerate}
        \item $\slotstart(\slot(t-1) \geq \GGST$,
        % \item $slot(b) < slot(t)$
        \item  $\var[val=v]{\mathit{isLMDGHOSTSafe}}(b,\gjattime[time=t,val=v],t)$,
        \item $t' \geq \slotstart(\slot(t))$ and
        \item for any validator $v'' \in \commfromslot[from=\slot(t),to=\slot(t')]{\honvals}$ and time $t''$ such that $t \leq t'' \leq t'$, $\totvalsetweight[chkp={\gjattime[time=t'',val=v'']}]{\allvals} \leq \totvalsetweight[chkp={\gjattime[time=t,val=v]}]{\allvals}$,
        % \item\label{itm:thm:lmd-confirmed-changing-balances:cond-on-justified-next-epoch} by the end of epoch $\epoch(t) + 1$, any honest validator has in their view a block $b''$ such that $\epoch(U(b'')) = \epoch(t) \land U(b'') \succeq \gjblock(b)$
    \end{enumerate}
    % then, for any time $t' \geq \slotstart(\slot(t))$ such that
    % \begin{enumerate}[resume]
    %     % \item $t' \geq t$, and

    % \end{enumerate}
    % we have that,
    then $b$ is canonical in the view of any honest validator at time $t'$.
    % \begin{enumerate}
    %     \item at time $t'$, $b$ is canonical in the view of any honest validator, and
    %     \item any honest validator voting at time $t'$ LMD votes for a descendant of block $b$ in slot $\slotattime{t'}$.
    % \end{enumerate}
\end{lemma}

\begin{proof}
    Up until the case analysis of the Inductive Case the proof is as in the paper.
    Then, let us proceed with the case analysis of the Inductive Case.
    \begin{description}
        \item[Case {$\commweightfromblock[from=b', to=s'-1, chkp={\gjviewsym '}]{\allvals} \geq \commweightfromblock[from=b', to=s-1, chkp={\gjviewsym}]{\allvals}$}.]
        \def\alignexplwidth{3.7cm}
        \begin{align*}
            & \hphantom{{}\geq{}} \indicatorfromblock[from=b',to=\slot(t')-1,val=v',when=\slotstartslot{t},chkp={\gjviewsym '}]{\indP}
            \\
            &\geq
            \indicatorfromblock[from=b',to=\slot(t)-1,val=v,when=\slotstartslot{t},chkp={\gjviewsym}]{\indP}
            +
            \frac
            {
                \weightofset[chkp=\gjviewsym]{
                    \attsettobediscfromblock[from=b',to=\slot(b')-1,when=\slotstartslot{t},val=v]{\honatts}
                    \cap
                    \commfromslot[from=s, to=\slot(t')-1]{\honvals}
                }
            }
            {
                \commweightfromblock[from=b', to=\slot(t)-1, chkp=\gjviewsym]{\honvals}
            }          
            &&\alignexpl[\alignexplwidth]{
                By Lemma~\ref{lem:lmd-p-monotonic-ex}.
            }
            \\
            &>
            \begin{aligned}[t]
                &\frac{1}{2}
                \left( 1+
                    \frac
                    {
                        \boostweight[chkp=\gjviewsym]
                        -
                        \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=\slotstartslot{t},chkp=\gjviewsym]{\honattsub}
                    }
                    {\commweightfromblock[from=b',to=\slot(t)-1,chkp={\gjviewsym}]{\allvals}}
                \right)\\
                &+
                \frac
                {
                    \weightofset[chkp=\gjviewsym]{
                        \attsettobediscfromblock[from=b',to=\slot(b')-1,when=\slotstartslot{t},val=v]{\honatts}
                        \cap
                        \commfromslot[from=s, to=\slot(t')-1]{\honvals}
                    }
                }
                {
                    \commweightfromblock[from=b', to=\slot(t)-1, chkp=\gjviewsym]{\honvals}
                }          
            \end{aligned}
            &&\alignexpl[\alignexplwidth]{
                By condition 2 of the Lemma's statement and Lemma~\ref{lem:lmd-cond-on-q-implies-cond-on-p}.
            }
            \\
            &\geq
            \begin{aligned}[t]
                &\frac{1}{2}
                \left( 1+
                    \frac
                    {
                        \boostweight[chkp=\gjviewsym]
                        -
                        \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,chkp=\gjviewsym,when=\slotstartslot{t},val=v]{\honatts}
                    }
                    {\commweightfromblock[from=b',to=\slot(t)-1,chkp={\gjviewsym}]{\allvals}}
                \right)
                \\
                &+
                \frac
                {
                    \weightofset[chkp=\gjviewsym]{
                        \attsettobediscfromblock[from=b',to=\slot(b')-1,when=\slotstartslot{t},val=v]{\honatts}
                        \cap
                        \commfromslot[from=s, to=\slot(t')-1]{\honvals}
                    }
                }
                {
                    \commweightfromblock[from=b', to=\slot(t)-1, chkp={\gjviewsym}]{\honvals}
                }    
            \end{aligned}     
            \\        
            &\geq
            \begin{aligned}[t]
                &\frac{1}{2}
                \left( 1+
                    \frac
                    {
                        \boostweight[chkp={\gjviewsym'}]
                        -
                        \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,chkp=\gjviewsym,when=\slotstartslot{t},val=v]{\honatts}
                    }
                    {\commweightfromblock[from=b',to=\slot(t')-1,chkp={\gjviewsym'}]{\allvals}}
                \right)
                \\
                &+
                \frac
                {
                    \weightofset[chkp=\gjviewsym]{
                        \attsettobediscfromblock[from=b',to=\slot(b')-1,when=\slotstartslot{t},val=v]{\honatts}
                        \cap
                        \commfromslot[from=s, to=\slot(t')-1]{\honvals}
                    }
                }
                {
                    \commweightfromblock[from=b',to=\slot(t')-1,chkp={\gjviewsym'}]{\allvals}
                }  
            \end{aligned}               
            &&\alignexpl[\alignexplwidth]{
                As we assume $\commweightfromblock[from=b', to=\slot(t')-1, chkp={\gjviewsym '}]{\allvals} \geq \commweightfromblock[from=b', to=\slot(t)-1, chkp={\gjviewsym}]{\allvals}$ and have established above that $\boostweight[chkp={\gjviewsym'}] \leq \boostweight[chkp={\gjviewsym}]$
                Also, 
                $\commweightfromblock[from=b', to=\slot(t)-1, chkp={\gjviewsym}]{\honvals}
                \leq\commweightfromblock[from=b',to=\slot(t')-1,chkp={\gjviewsym}]{\honvals}\leq\commweightfromblock[from=b',to=\slot(t')-1,chkp={\gjviewsym}]{\allvals}$.
            }
            \\        
            &\geq
            \frac{1}{2}
            \left( 1+
                \frac
                {
                    \boostweight[chkp={\gjviewsym'}]
                    -
                    \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,chkp=\gjviewsym,when=\slotstartslot{t'},val=v]{\honatts} 
                }
                {\commweightfromblock[from=b',to=\slot(t')-1,chkp={\gjviewsym'}]{\allvals}}
            \right) 
            &&\alignexpl[\alignexplwidth]{
                As,
                $
                \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,chkp=\gjviewsym,when=\slotstartslot{t},val=v]{\honatts}-
                \weightofset[chkp=\gjviewsym]{
                    \attsettobediscfromblock[from=b',to=\slot(b')-1,when=\slotstartslot{t},val=v]{\honatts}
                    \cap
                    \commfromslot[from=s, to=\slot(t')-1]{\honvals}
                }   
                =
                \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,chkp=\gjviewsym,when=\slotstartslot{t'},val=v]{\honatts}          
                $
                given that any validator in $\commfromslot[from=s, to=\slot(t')-1]{\honvals}$ \LMDGHOST vote in support of $b$ as per the Lemma's statement.
            }     
        \end{align*} 
        From here, we can apply Lemmas~\ref{lem:condition-on-h-for-canonical-ex} and \ref{lem:lmd-cond-on-p-implies-cond-on-h-ex} to conclude the proof for this case.        
        \item[Case {$\commweightfromblock[from=b', to=s'-1, chkp={\gjviewsym '}]{\allvals} < \commweightfromblock[from=b', to=s-1, chkp={\gjviewsym}]{\allvals}$}.]
            \def\alignexplwidth{5cm}
            \begin{align*}
                &\hphantom{{}={}}\attsetweightfromblock[from=b', to=s'-1, val=v', when=t', chkp={\gjviewsym '}]{\honatts}
                \\
                &=
                \weightofset[chkp={\gjviewsym '}]{
                    \attsetfromblockunfiltered[from=b', to=s-1, val=v', when=t']{\honatts}
                    \cup
                    \commfromslot[from=s, to=s'-1]{\honvals}
                }
                &&\alignexpl[\alignexplwidth]{As, by the inductive hypothesis, all honest validators in the committees between slot $s$ and slot $s'-1$ \GHOST vote in support of $b$.}\\
                \\
                &\geq
                \attsetweightfromblock[from=b', to=s-1, val=v', when=t, chkp={\gjviewsym '}]{\honatts}
                \\
                &=
                \attsetweightfromblock[from=b', to=s-1, val=v', when=t, chkp={\gjviewsym}]{\honatts}
                &&\alignexpl[\alignexplwidth]{Due to Assumption~\ref{assum:no-change-to-the-validator-set}.}\\
                % &\geq
                % \attsetweightfromblock[from=b', to=s-1, val=v, when=t, chkp={\gjviewsym}]{\honatts}
                % &&\alignexpl[\alignexplwidth]{Given that $slotstart(s-1)\geq\GGST$, any honest attestation for slots up to $s'-1$ received by $v'$ at time $t'$, it is also received by $v'$ by the same time $t'$.}
                % \\
                &\geq
                \attsetweightfromblock[from=b', to=s-1, when=t, chkp={\gjviewsym}]{\allatts}
                -
                \commweightfromblock[from=b', to=s-1, chkp={\gjviewsym}]{\advvals}
                &&\alignexpl{By definition.}\\
                &=
                \commweightfromblock[from=b', to=s-1, chkp={\gjviewsym}]{\allvals}
                \indicatorfromblock[from=b',to=s-1,val=v,when=t,chkp={\gjviewsym}]{\indQ}
                -
                \commweightfromblock[from=b', to=s-1, chkp={\gjviewsym}]{\advvals}
                &&\alignexpl{By definition of $\indicatorfromblock[from=b',to=s-1,val=v,when=t,chkp={\gjviewsym}]{\indQ}$.}\\
                &>
                \commweightfromblock[from=b', to=s-1, chkp={\gjviewsym}]{\allvals}
                \left(
                    \frac{1}{2}
                    \left( 1+
                        \frac
                        {
                            \boostweight[chkp=C] 
                            -\attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=\gjviewsym]{\honatts}                
                        }
                        {\commweightfromblock[from=b',to=s-1,chkp={\gjviewsym}]{\allvals}}
                    \right)
                    + \beta
                \right)
                -
                \commweightfromblock[from=b', to=s-1, chkp={\gjviewsym}]{\advvals}
                &&\alignexpl[\alignexplwidth]{
                    By applying condition 2 of the Lemma's statement and 
                    $
                    \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=\gjviewsym]{\honatts}
                    \geq
                    \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=\gjviewsym]{\honattsub}$.
                }
                \\
                &=
                \frac
                {\commweightfromblock[from=b', to=s-1, chkp={\gjviewsym}]{\allvals} + \boostweight[chkp={\gjviewsym}]
                -\attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=\gjviewsym]{\honatts} }
                {2}
                +
                \beta
                \commweightfromblock[from=b', to=s-1, chkp={\gjviewsym}]{\allvals}
                -
                \commweightfromblock[from=b', to=s-1, chkp={\gjviewsym}]{\advvals}
                &&\alignexpl[\alignexplwidth]{By simplifications.}\\
                &\geq
                \frac
                {\commweightfromblock[from=b', to=s-1, chkp={\gjviewsym}]{\allvals} + \boostweight[chkp={\gjviewsym}]
                -\attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=\gjviewsym]{\honatts} }
                {2}
                &&\alignexpl[\alignexplwidth]{As, due to Assumption~\ref{assum:beta},
                % we assume
                $\beta
                \commweightfromblock[from=b', to=s-1, chkp={\gjviewsym}]{\allvals}
                \geq 
                \commweightfromblock[from=b', to=s-1, chkp={\gjviewsym}]{\advvals}$.
                }\\
                &>
                \frac
                {\commweightfromblock[from=b', to=s'-1, chkp={\gjviewsym '}]{\allvals} + \boostweight[chkp={\gjviewsym '}]
                -\attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=\gjviewsym]{\honatts} }
                {2}
                &&\alignexpl[\alignexplwidth]{As we assume $\commweightfromblock[from=b', to=s'-1, chkp={\gjviewsym '}]{\allvals} < \commweightfromblock[from=b', to=s-1, chkp={\gjviewsym}]{\allvals}$ and and have established above that $\boostweight[chkp={\gjviewsym'}] \leq \boostweight[chkp={\gjviewsym}]$.}\\
            \end{align*}
            Now we can apply Lemma~\ref{lem:condition-on-h-for-canonical-ex} to conclude the proof for this case.                         
    \end{description}  
\end{proof}

\begin{proof}
    \def\alignexplwidth{5cm}
    \allowdisplaybreaks
    \begin{align*}
        &\hphantom{{}={}}
        \attsetweighttobediscfromblock[from=b,to=\slot(b)-1,val=v,when=\slotstart(s),chkp=C]{\honattsub}
        \\
        &=
        \attsetweighttobediscfromblock[from=b,to=\slot(b)-1,val=v,when=\slotstart(s),chkp=C]{\allatts}
            -\beta \commweightfromblock[from=b,to=\slot(b)-1,chkp=C]{\allvals}
            +\attsetweightfromblock[from=b,to=\slot(b)-1,val=v,when=\slotstart(s),chkp=C]{\slashvals}  
        \\
        &=
        \begin{aligned}[t]
            &\attsetweighttobediscfromblock[from=b,to=\slot(b)-1,val=v,when=\slotstart(s),chkp=C]{\honatts}
            +
            \weightofset[chkp=C]{
                \attsettobediscfromblock[from=b,to=\slot(b)-1,val=v,when=\slotstart(s)]{\allatts}
                \cap
                \commfromblock[from=b,to=\slot(b)-1]{\advvals}
            }
            \\
            &-\beta \commweightfromblock[from=b,to=\slot(b)-1,chkp=C]{\allvals}
            +\attsetweightfromblock[from=b,to=\slot(b)-1,val=v,when=\slotstart(s),chkp=C]{\slashvals}
        \end{aligned}
        \\ 
        &=
        \begin{aligned}[t]
            &\attsetweighttobediscfromblock[from=b,to=\slot(b)-1,val=v,when=\slotstart(s'),chkp=C']{\honatts}
            +
            \weightofset[chkp=C]{
                \attsettobediscfromblock[from=b,to=\slot(b)-1,val=v,when=\slotstart(s)]{\allatts}
                \cap
                \commfromblock[from=b,to=\slot(b)-1]{\advvals}
            }
            \\
            &-\beta \left(
                \commweightfromblock[from=b,to=\slot(b)-1,chkp=C]{\honvals}
                +\commweightfromblock[from=b,to=\slot(b)-1,chkp=C]{\advvals}
            \right)
            +\attsetweightfromblock[from=b,to=\slot(b)-1,val=v,when=\slotstart(s),chkp=C]{\slashvals}
        \end{aligned}
        \\ 
        &=
        \begin{aligned}[t]
            &\attsetweighttobediscfromblock[from=b,to=\slot(b)-1,val=v,when=\slotstart(s'),chkp=C']{\honatts}
            +
            \weightofset[chkp=C]{
                \attsettobediscfromblock[from=b,to=\slot(b)-1,val=v,when=\slotstart(s)]{\allatts}
                \cap
                \commfromblock[from=b,to=\slot(b)-1]{\advvals}
            }
            \\
            &-\beta \commweightfromblock[from=b,to=\slot(b)-1,chkp=C']{\honvals}
                -\beta\commweightfromblock[from=b,to=\slot(b)-1,chkp=C]{\advvals}
            +\attsetweightfromblock[from=b,to=\slot(b)-1,val=v,when=\slotstart(s),chkp=C]{\slashvals}
        \end{aligned}
        \\         
        &====
        \\
        &\leq
        \begin{aligned}[t]
            &\attsetweighttobediscfromblock[from=b,to=\slot(b)-1,val=v,when=\slotstart(s'),chkp=C']{\honatts}
            +
            \weightofset[chkp=C]{
                \attsettobediscfromblock[from=b,to=\slot(b)-1,val=v,when=\slotstart(s)]{\allatts}
                \cap
                \commweightfromblock[from=b,to=\slot(b)-1,chkp=C]{\advvals}
            }
            \\
            &-\beta \commweightfromblock[from=b,to=\slot(b)-1,chkp=C']{\allvals}
            +\attsetweightfromblock[from=b,to=\slot(b)-1,val=v,when=\slotstart(s),chkp=C]{\slashvals}
        \end{aligned}
        \\         
        &\leq
        \begin{aligned}[t]
            &\attsetweighttobediscfromblock[from=b,to=\slot(b)-1,val=v,when=\slotstart(s'),chkp=C]{\honatts}
            +
            \weightofset[chkp=C]{
                \attsettobediscfromblock[from=b,to=\slot(b)-1,val=v,when=\slotstart(s')]{\allatts}
                \cap
                \commweightfromblock[from=b,to=\slot(b)-1,chkp=C]{\advvals}
            }                        
            \\
            &
            -\beta \commweightfromblock[from=b,to=\slot(b)-1,chkp=C]{\allvals}
            +\attsetweightfromblock[from=b,to=\slot(b)-1,val=v,when=\slotstart(s'),chkp=C]{\slashvals}
        \end{aligned}   
        &&\alignexpl[\alignexplwidth]
        {
            As 
            $
                \attsetfromblock[from=b,to=\slot(b)-1,val=v,when=\slotstart(s')]{\slashvals}
                \subseteq
                \attsetfromblock[from=b,to=\slot(b)-1,val=v,when=\slotstart(s')]{\slashvals}
            $
            and
            $
            \left(
                \attsettobediscfromblock[from=b,to=\slot(b)-1,val=v,when=\slotstart(s)]{\allatts}
                \cap
                \commweightfromblock[from=b,to=\slot(b)-1,chkp=C]{\advvals}                
            \right)
            \setminus
            \left(
                \attsettobediscfromblock[from=b,to=\slot(b)-1,val=v,when=\slotstart(s')]{\allatts}
                \cap
                \commweightfromblock[from=b,to=\slot(b)-1,chkp=C]{\advvals}
            \right)
            \subseteq
            \left(
                \attsetfromblock[from=b,to=\slot(b)-1,val=v,when=\slotstart(s')]{\slashvals}
                \setminus
                \attsetfromblock[from=b,to=\slot(b)-1,val=v,when=\slotstart(s)]{\slashvals}
            \right)
            $
        }
        \\     
        &=
        \attsetweighttobediscfromblock[from=b,to=\slot(b)-1,val=v,when=\slotstart(s'),chkp=C]{\allatts}
        -\beta \commweightfromblock[from=b,to=\slot(b)-1,chkp=C]{\allvals}
            +\attsetweightfromblock[from=b,to=\slot(b)-1,val=v,when=\slotstart(s'),chkp=C]{\slashvals}                                
    \end{align*}
\end{proof}


\begin{lemma}\label{lem:beta-less-than-quarter-no-reconfirmation-required-ex}
    Let $s' := \firstslot(\epoch(t)+1)$.
    Pick any block $b$ such that $b \preceq \var[val=v,time=\slotstartslot{t})]{\bconfirmed}$.
    If
    \begin{enumerate}
        \item $\slotstart(\epoch(t)) \geq \GST$
        \item $\epoch(b) = \epoch(t)$
        \item  $\beta  \leq \frac{1}{4}$
    \end{enumerate},
    then,
    \begin{enumerate}
        \item {$
            \indicatorfromblock[from=b,to=s'-1,val=v,when=\slotstart(s'),chkp={C}]{\indQ}
            > \frac{1}{2}\left(1 + \frac{\boostweight[chkp={C}]-\attsetweighttobediscfromblock[from=b,to=\slot(b)-1,val=v,when=\slotstart(s'),chkp=C]{\honattsub}}{\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}\right)
            + \beta
            - \frac
                {\attsetweightfromblock[from=b,to=s'-1,val=v,when=\slotstart(s'),chkp={C}]{\slashvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}$}
    \end{enumerate}
\end{lemma}

\begin{proof}
    % Let $\attsetweightfromblock[from={s},to=s'-1,val=v,when=\slotstart(s'),chkp={C}]{\allatts}$ be the total balance of validators voted in the support of block $b$ between slot $s$ and $s'-1$ inclusive according to the effective balance distribution defined by the checkpoint $C$ as per the view of validator $v$ at the start of slot $s'$.
    Let $s:=\slot(t)$.
    \def\alignexplwidth{5cm}
    \allowdisplaybreaks
    \begin{align*}
        &\hspace{3ex} \indicatorfromblock[from=b,to=s'-1,val=v,when=\slotstart(s'),chkp={C}]{\indQ}\\  
        &=
        \frac
            {\attsetweightfromblock[from=b,to=s'-1,val=v,when=\slotstart(s'),chkp={C}]{\allatts}}
            {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
        &&\alignexpl{By definition.}
        \\
        &=
        \frac
            {\commweightfromslot[from={s},to=s'-1,val=v,when=\slotstart(s'),chkp={C}]{\honvals}}
            {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
        +
        \frac
            {\attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s'),chkp={C}]{\allatts}}
            {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
        &&\alignexpl[\alignexplwidth]{First, $\attsetweightfromblock[from=b,to=s'-1,val=v,when=\slotstart(s'),chkp={C}]{\allatts} \geq \weightofset[chkp=C]{\attsetfromblock[from=b,to=s-1,val=v,when=\slotstart(s')]{\allatts}\cap \commfromblock[from=\slot(b),to=s-1]{\allvals}} + \commweightfromslot[from={s},to=s'-1,val=v,when=\slotstart(s'),chkp={C}]{\honvals}$ because $\epoch(b) = \epoch(t)$ and, due to \Cref{lem:canonical-no-extra-assum}, $\canonical[blck=b,time=\slotstart(s)]$. 
        Then 
        $\weightofset[chkp=C]{\attsetfromblock[from=b,to=s-1,val=v,when=\slotstart(s')]{\allatts}\cap \commfromblock[from=\slot(b),to=s-1]{\allvals}} = \attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s'),chkp={C}]{\allatts}$ because no validators in $\commfromslot[from=\parentslotplusone(b),to=\slot(b)-1]{\allvals} \setminus \commfromslot[from=\slot(b),to=s-1]{\allvals}$
        can have cast a valid \LMDGHOST vote for $b$. }
        \\
        &=
        \begin{aligned}[t]
            &\frac
                {\commweightfromslot[from={s},to=s'-1,val=v,when=\slotstart(s'),chkp={C}]{\honvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
            \\
            &+
            \frac
                {\attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s),chkp={C}]{\allatts} - \left(\attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s'),chkp={C}]{\slashvals}-\attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s),chkp={C}]{\slashvals}\right)}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
        \end{aligned}
        &&\alignexpl[\alignexplwidth]{As, $\attsetfromblockunfiltered[from=b,to=s-1,val=v,when=\slotstart(s')]{\allatts} = \attsetfromblockunfiltered[from=b,to=s-1,val=v,when=\slotstart(s)]{\allatts} \\ \setminus \left(\attsetfromblockunfiltered[from=b,to=s-1,val=v,when=\slotstart(s')]{\slashvals} \\ \setminus \attsetfromblockunfiltered[from=b,to=s-1,val=v,when=\slotstart(s)]{\slashvals}\right)$.}
        \\
        &=
        \begin{aligned}[t]
            &\frac
                {\commweightfromslot[from={s},to=s'-1,val=v,when=\slotstart(s'),chkp={C}]{\honvals} - \attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s'),chkp={C}]{\slashvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
            \\
            &+
            \frac
                {\attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s),chkp={C}]{\allatts}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
            +
            \frac
                {\attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s),chkp={C}]{\slashvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
        \end{aligned}
        &&\alignexpl[\alignexplwidth]{By simplification.}
        \\
        &=
        \begin{aligned}[t]
            &\frac
                {\commweightfromslot[from={s},to=s'-1,val=v,when=\slotstart(s'),chkp={C}]{\honvals} - \attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s'),chkp={C}]{\slashvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
            \\
            &+
            \frac
                {\indicatorfromblock[from=b,to=s-1,val=v,when=\slotstart(s),chkp={C}]{\indQ} \commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals}
                }
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
            +
            \frac
                {\attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s),chkp={C}]{\slashvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
        \end{aligned}
        &&\alignexpl[\alignexplwidth]{By definition.}
        \\
        &>
        \begin{aligned}[t]
            &\frac
                {\commweightfromslot[from={s},to=s'-1,val=v,when=\slotstart(s'),chkp={C}]{\honvals} - \attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s'),chkp={C}]{\slashvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
            \\
            &+
            \frac
                {\left(\frac{1}{2}\left(1 + \frac{\boostweight[chkp=C]-\attsetweighttobediscfromblock[from=b,to=\slot(b)-1,val=v,when=\slotstart(s),chkp=C]{\honattsub}}{\commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals}}\right) + \beta - \frac{\attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s),chkp={C}]{\slashvals}}{\commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals}}\right) \commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
            \\
            &+
            \frac
                {\attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s),chkp={C}]{\slashvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
        \end{aligned}
        &&\alignexpl[\alignexplwidth]{Due to \Cref{lem:bconf-curr-epoch-ancestor-is-one-confirmed}.}
        \\
        &=
        \begin{aligned}[t]
            &\frac
                {\commweightfromslot[from={s},to=s'-1,val=v,when=\slotstart(s'),chkp={C}]{\honvals} - \attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s'),chkp={C}]{\slashvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
            \\
            &+
            \frac
                {\frac{1}{2}\left(\commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals} 
                + \boostweight[chkp=C]
                -\attsetweighttobediscfromblock[from=b,to=\slot(b)-1,val=v,when=\slotstart(s),chkp=C]{\honattsub}\right) 
                + \beta \commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals}-\attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s),chkp={C}]{\slashvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
            \\
            &+
            \frac
                {\attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s),chkp={C}]{\slashvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
        \end{aligned}
        &&\alignexpl[\alignexplwidth]{By simplification.}
        \\       
        &\geq
        \begin{aligned}[t]
            &\frac
                {\commweightfromslot[from={s},to=s'-1,val=v,when=\slotstart(s'),chkp={C}]{\honvals} - \attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s'),chkp={C}]{\slashvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
            \\
            &+
            \frac
                {\frac{1}{2}\left(\commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals} 
                + \boostweight[chkp=C]
                -\attsetweighttobediscfromblock[from=b,to=\slot(b)-1,val=v,when=\slotstart(s),chkp=C]{\honattsub}\right) + \beta \commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
        \end{aligned}
        &&\alignexpl[\alignexplwidth]{By simplification.}
        \\       
        &\geq
        \begin{aligned}[t]
            &\frac
                {\commweightfromslot[from={s},to=s'-1,val=v,when=\slotstart(s'),chkp={C}]{\honvals} - \attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s'),chkp={C}]{\slashvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
            \\
            &+
            \frac
                {\frac{1}{2}\left(\commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals} 
                + \boostweight[chkp=C]
                -\attsetweighttobediscfromblock[from=b,to=\slot(b)-1,val=v,when=\slotstart(s),chkp=C]{\honattsub}\right) + \beta \commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
        \end{aligned}
        &&\alignexpl[\alignexplwidth]{As $\boostweight[chkp=C]\geq\boostweight[chkp=C]$
        and $\commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals}\geq\commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals}$ due to \Cref{lem:gu-prev-slot-descendant-of-gj-prev-slot} and Assumption 1 of the paper.}      
        \\       
        &\geq
        \begin{aligned}[t]
            &\frac
                {\commweightfromslot[from={s},to=s'-1,val=v,when=\slotstart(s'),chkp={C}]{\honvals} - \attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s'),chkp={C}]{\slashvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
            \\
            &+
            \frac
                {\frac{1}{2}\left(\commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals}
                -\attsetweighttobediscfromblock[from=b,to=\slot(b)-1,val=v,when=\slotstart(s'),chkp=C]{\honattsub} 
                + \boostweight[chkp=C]
                \right) + \beta \commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
        \end{aligned}
        &&\alignexpl[\alignexplwidth]{
            $
            \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=\slotstart(s'),chkp=C]{\allatts}
            \geq 
            \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=\slotstart(s),chkp=C]{\allatts}
            - \left(\attsetweightfromblock[from=b',to=\slot(b)-1,val=v,when=\slotstart(s'),chkp=C]{\slashvals}-
            \attsetweightfromblock[from=b',to=\slot(b)-1,val=v,when=\slotstart(s),chkp=C]{\slashvals}\right)
            $.
            So,
            $
            \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=\slotstart(s),chkp=C]{\allatts} + \attsetweightfromblock[from=b',to=\slot(b)-1,val=v,when=\slotstart(s),chkp=C]{\slashvals}
            \leq
            \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=\slotstart(s'),chkp=C]{\allatts}+ \attsetweightfromblock[from=b',to=\slot(b)-1,val=v,when=\slotstart(s'),chkp=C]{\slashvals}$.
        }           
        % \\
        % &\geq
        % \begin{aligned}[t]
        %     &\frac
        %         {\commweightfromslot[from={s},to=s'-1,val=v,when=\slotstart(s'),chkp={C}]{\honvals} - \attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s'),chkp={C}]{\slashvals}}
        %         {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
        %     \\
        %     &+
        %     \frac
        %         {\left(\frac{1}{2}\left(\commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals} + \boostweight[chkp=C]\right) + \beta \commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals}\right)(1-2\penr)}
        %         {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
        % \end{aligned}
        % &&\alignexpl[\alignexplwidth]{As, $\commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals} \leq \commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals}$ and $\boostweight[chkp=C] \leq \boostweight[chkp=C]$ due to \Cref{lem:gu-prev-slot-descendant-of-gj-prev-slot} together with Assumption 1 of the Paper.}
        \\
        &\geq
        \begin{aligned}[t]
            &\frac
                {\left(1-\beta\right) \commweightfromblock[from=s,to=s'-1,chkp={C}]{\allvals} - \attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s'),chkp={C}]{\slashvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
            \\
            &+
            \frac
                {\frac{1}{2}\left(\commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals}
                -\attsetweighttobediscfromblock[from=b,to=\slot(b)-1,val=v,when=\slotstart(s'),chkp=C]{\honattsub} 
                + \boostweight[chkp=C]\right) + \beta \commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
        \end{aligned}
        &&\alignexpl[\alignexplwidth]{By Assumption 2 of the paper.}
        \\
        &\geq
        \begin{aligned}[t]
            &\frac
                {\left(\frac{1}{2}+\beta \right) \commweightfromblock[from=s,to=s'-1,chkp={C}]{\allvals} - \attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s'),chkp={C}]{\slashvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
            \\
            &+
            \frac
                {\frac{1}{2}\left(\commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals}
                -\attsetweighttobediscfromblock[from=b,to=\slot(b)-1,val=v,when=\slotstart(s'),chkp=C]{\honattsub}  
                + \boostweight[chkp=C]\right) + \beta \commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
        \end{aligned}
        &&\alignexpl[\alignexplwidth]{Given that $\beta \leq \frac{1}{4}$.}        
        \\
        &=
        \begin{aligned}[t]
            &\frac
                {\frac{1}{2}\left(\commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals} + \commweightfromblock[from=s,to=s'-1,chkp={C}]{\allvals}
                -\attsetweighttobediscfromblock[from=b,to=\slot(b)-1,val=v,when=\slotstart(s'),chkp=C]{\honattsub}  
                + \boostweight[chkp=C]\right)}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
            \\
            &+
            \frac
                {\left(\commweightfromblock[from=b,to=s-1,chkp={C}]{\allvals}+ \commweightfromblock[from=s,to=s'-1,chkp={C}]{\allvals}\right) \beta - \attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s'),chkp={C}]{\slashvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
        \end{aligned}
        &&\alignexpl[\alignexplwidth]{By simplification.}     
        \\        
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        &\geq
        \begin{aligned}[t]
            &\frac
                {\frac{1}{2}\left(\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals} 
                -\attsetweighttobediscfromblock[from=b,to=\slot(b)-1,val=v,when=\slotstart(s'),chkp=C]{\honattsub} 
                + \boostweight[chkp=C]\right)}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
            \\
            &+
            \frac
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals} \beta - \attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s'),chkp={C}]{\slashvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
        \end{aligned}
        &&\alignexpl[\alignexplwidth]{As, $\commfromblock[from=b,to=s'-1]{\allvals} = \commfromblock[from=b,to=s-1]{\allvals} \cup \commfromblock[from=s,to=s'-1]{\allvals}$.}         
        \\
        &=
            \frac{1}{2}\left(1 + \frac{\boostweight[chkp=C]-\attsetweighttobediscfromblock[from=b,to=\slot(b)-1,val=v,when=\slotstart(s'),chkp=C]{\honattsub} }
            {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}
            }\right)
            + \beta
            - \frac
                {\attsetweightfromblock[from=b,to=s-1,val=v,when=\slotstart(s'),chkp={C}]{\slashvals}}
                {\commweightfromblock[from=b,to=s'-1,chkp={C}]{\allvals}}
        &&\alignexpl[\alignexplwidth]{By simplification.}
    \end{align*}
\end{proof}



% \begin{lemma}\label{lem:lmd-cond-on-p-implies-cond-on-h-ex2}
%     Given Assumption~\ref{assum:beta},
%     for any time $t\geq\GGST$,
%     honest validator $v$,
%     block $b$,
%     slot $s$,% such that $slot(b) \leq s$ % \leq \slotattime{t}$
%     and checkpoint $C \in \allU(b)$ with $b$ being any valid block,\\% that is canonical in the view of validator $v$ at time $t$,\\
%     if
%     % $$\forall b' \preceq b,\;
%     % \indicatorfromblock[from=b',to=s,val=v,when=t,chkp=C]{\indP}
%     % > \frac{1}{2(1-\beta)}
%     % \left( 1+
%     %     \frac
%     %     {\boostweight[chkp=C]}
%     %     {
%     %         \commweightfromblock[from=b',to=s,chkp=C]{\allvals}
%     %         -
%     %         % \min\left(
%     %         %     \commweightfromblock[from=b',to=\slot(b)-1,chkp=C]{\allvals}
%     %         %     ,
%     %             \frac
%     %                 {\attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\allatts}}
%     %                 {1-\beta}
%     %         % \right)
%     %     }
%     % \right)$$
%     $$\forall b' \preceq b,\;
%     \indicatordiscfromblock[from=b',to=s,val=v,when=t,chkp=C]{\indP}
%     \begin{aligned}[t]
%         &>  \begin{aligned}[t]
%             &\frac
%             {1}
%             {2\left(
%                 \frac
%                     {
%                         (1-\beta)\commweightfromblock[from=b',to=s,chkp=C]{\allvals}
%                         -\attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\honatts}
%                     }
%                     {
%                         \commweightfromblock[from=b',to=s,chkp=C]{\allvals}
%                         -\max\left(
%                             \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\allatts}
%                             -\beta \commweightfromblock[from=b',to=\slot(b)-1,chkp=C]{\allvals}
%                             ,0
%                         \right)
%                     }
%             \right)}
%             \\
%             &\left( 1+
%                 \frac
%                 {\boostweight[chkp=C]}
%                 {
%                     \commweightfromblock[from=b',to=s,chkp=C]{\allvals}
%                     -\max\left(
%                         \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\allatts}
%                         -\beta \commweightfromblock[from=b',to=\slot(b)-1,chkp=C]{\allvals}
%                         ,0
%                     \right)
%                 }
%             \right)
%             \end{aligned}
%         \\
%         &=
%         \frac
%             {\commweightfromblock[from=b',to=s,chkp=C]{\allvals}-
%             \max\left(
%                 \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\allatts}
%                 -\beta \commweightfromblock[from=b',to=\slot(b)-1,chkp=C]{\allvals}
%                 ,0
%             \right)
%             +\boostweight[chkp=C]
%             }
%             {2\left((1-\beta)\commweightfromblock[from=b',to=s,chkp=C]{\allvals}-\attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\honatts}\right)}
%     \end{aligned}
%     $$    
%     then,
%     $$\forall b' \preceq b,\;
%     \attsetweightfromblock[from=b',to=s,val=v,when=t,chkp=C]{\honatts}
%     >
%     \frac{
%             \commweightfromblock[from=b',to=s,chkp=C]{\allvals}
%             -\attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\honatts}
%             +\boostweight[chkp=C]
%         }
%         {
%             2
%         }
%     $$.
% \end{lemma}



% \begin{proof}
%     Let $b'$ by any block such that $b' \preceq b$.
%     Now we can proceed as follows.
%     \def\alignexplwidth{5cm}
%     \begin{align*}
%         \attsetweightfromblock[from=b',to=s,val=v,when=t,chkp=C]{\honatts}
%         &=
%         \left(
%             \commweightfromblock[from=b',to=s,chkp=C]{\honvals}
%             -\attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\honatts}
%         \right)
%         \indicatordiscfromblock[from=b',to=s,val=v,when=t,chkp=C]{\indP}  
%         &&\alignexpl{By definition}
%         \\      
%         &\geq
%         \left(
%             (1-\beta)\commweightfromblock[from=b',to=s,chkp=C]{\allvals}
%             -\attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\honatts}
%         \right)
%         \indicatordiscfromblock[from=b',to=s,val=v,when=t,chkp=C]{\indP}  
%         &&\alignexpl{}
%         \\
%         &>
%         \frac{
%             \commweightfromblock[from=b',to=s,chkp=C]{\allvals}-
%             \max\left(
%                 \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\allatts}
%                 -\beta \commweightfromblock[from=b',to=\slot(b)-1,chkp=C]{\allvals}
%                 ,0
%             \right)
%             +\boostweight[chkp=C]
%         }
%         {
%             2
%         }
%         \\   
%         &\geq        
%         \frac{
%             \commweightfromblock[from=b',to=s,chkp=C]{\allvals}-
%             \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\honatts}
%             +\boostweight[chkp=C]
%         }
%         {
%             2
%         }
%     \end{align*}
% \end{proof}

% \begin{lemma}\label{lem:lmd-cond-on-q-implies-cond-on-p}
%     Given Assumption~\ref{assum:beta},
%     for any time $t\geq\GGST$,
%     honest validator $v$,
%     block $b'$,
%     slot $s$
%     % such that $slot(b') \leq s$ % \leq \slotattime{t}$
%     and checkpoint $C \in \allU(b')$ with $b'$ being any valid block,\\
%     % that is canonical in the view of validator $v$ at time $t$ and
%     % checkpoint $C$,\\
%     % Let $b'$, $v$, $s$, $t$, $C$ and $C$ be any block, honest validator, slot, time and two checkpoints respectively.
%     if
%     % $$
%     % \begin{aligned}[t]
%     %     &\frac
%     %     {\attsetweightfromblock[from=b',to=s,val=v,when=t,chkp=C]{\allatts} }
%     %     {(1-\beta)\commweightfromblock[from=b',to=s,chkp=C]{\allvals}  
%     %     -\max\left(
%     %         \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\allatts}
%     %         -\beta\commweightfromblock[from=b',to=\slot(b')-1,chkp=C]{\allvals}
%     %     ,0
%     %     \right)
%     %     }   
%     %     >
%     %     \\
%     %     &\hspace{5cm}\frac
%     %             {\commweightfromblock[from=b',to=s,chkp=C]{\allvals}-
%     %             \max\left(
%     %                 \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\allatts}
%     %                 -\beta \commweightfromblock[from=b',to=\slot(b)-1,chkp=C]{\allvals}
%     %                 ,0
%     %             \right)
%     %             +\boostweight[chkp=C]
%     %             }
%     %             {2\left((1-\beta)\commweightfromblock[from=b',to=s,chkp=C]{\allvals}-\attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\allatts}\right)}
%     %     \\
%     %     &\hspace{5cm} +
%     %     \frac
%     %         {\beta\commweightfromblock[from=b',to=s,chkp=C]{\allvals}}
%     %         {(1-\beta)\commweightfromblock[from=b',to=s,chkp=C]{\allvals}  
%     %         -\max\left(
%     %             \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\allatts}
%     %             -\beta\commweightfromblock[from=b',to=\slot(b')-1,chkp=C]{\allvals}
%     %         ,0
%     %         \right)
%     %         }
%     % \end{aligned}   
%     % $$
%     $$
%     \begin{aligned}[t]
%         &\attsetweightfromblock[from=b',to=s,val=v,when=t,chkp=C]{\allatts}
%         >
%         \frac
%                 {\commweightfromblock[from=b',to=s,chkp=C]{\allvals}-
%                 \max\left(
%                     \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\allatts}
%                     -\beta \commweightfromblock[from=b',to=\slot(b)-1,chkp=C]{\allvals}
%                     ,0
%                 \right)
%                 +\boostweight[chkp=C]
%                 }
%                 {2}
%         +
%         \beta\commweightfromblock[from=b',to=s,chkp=C]{\allvals}
%     \end{aligned}   
%     $$  
    
%     $$
%     \begin{aligned}[t]
%         &\indicatorfromblock[from=b,to=s',val=v,when=t,chkp=\calB]{\indQ}
%         >
%         \frac{1}{2}
%         \left(
%             1+
%             \frac
%                     {
%                     \boostweight[chkp=C]
%                     -
%                     \max\left(
%                         \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\allatts}
%                         -\beta \commweightfromblock[from=b',to=\slot(b)-1,chkp=C]{\allvals}
%                         ,0
%                     \right)
%                     }
%                     {\commweightfromblock[from=b',to=s,chkp=C]{\allvals}}
%         \right)
%         +
%         \beta
%     \end{aligned}   
%     $$ 
%     , then
%     $$
%     \indicatorfromblock[from=b',to=s,val=v,when=t,chkp=C]{\indP}
%     >
%     \frac{1}{2(1-\beta)}
%         \left( 1+
%             \frac
%             {\boostweight[chkp=C]}
%             {\commweightfromblock[from=b',to=s,chkp=C]{\allvals}}
%         \right)
%     $$
% \end{lemma}

% \begin{proof}

% \def\alignexplwidth{7cm}
% \allowdisplaybreaks
% \begin{align*}
%     &\indicatordiscfromblock[from=b',to=s,val=v,when=t,chkp=C]{\indP}
%     \\
%     &=\frac
%     {\attsetweightfromblock[from=b',to=s,val=v,when=t,chkp=C]{\honatts}}
%     {\commweightfromblock[from=b',to=s,chkp=C]{\honvals}-\attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\honatts}}
%     \\
%     &\geq
%     \frac
%     {\attsetweightfromblock[from=b',to=s,val=v,when=t,chkp=C]{\allatts}-
%     \commweightfromblock[from=b',to=s,chkp=C]{\advvals}}
%     {
%         \commweightfromblock[from=b',to=s,chkp=C]{\honvals}
%         -\attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\honatts}
%     }
%     \\
%     &=
%     \frac
%     {\attsetweightfromblock[from=b',to=s,val=v,when=t,chkp=C]{\allatts}-
%     \commweightfromblock[from=b',to=s,chkp=C]{\advvals}}
%     {\commweightfromblock[from=b',to=s,chkp=C]{\allvals} - \commweightfromblock[from=b',to=s,chkp=C]{\advvals}-\attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\honatts}}
%     \\
%     % &\geq
%     % \frac
%     % {\attsetweightfromblock[from=b',to=s,val=v,when=t,chkp=C]{\allatts}-
%     % \commweightfromblock[from=b',to=s,chkp=C]{\advvals}}
%     % {\commweightfromblock[from=b',to=s,chkp=C]{\allvals} 
%     % -\commweightfromblock[from=b',to=s,chkp=C]{\advvals}
%     % -\max\left(
%     %     \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\allatts}
%     %     -\commweightfromblock[from=b',to=\slot(b')-1,chkp=C]{\advvals}
%     % ,0\right)}
%     % \\
%     &\geq
%     \frac
%     {\attsetweightfromblock[from=b',to=s,val=v,when=t,chkp=C]{\allatts}-\beta\commweightfromblock[from=b',to=s,chkp=C]{\allvals} }
%     {\commweightfromblock[from=b',to=s,chkp=C]{\allvals} 
%     -\beta\commweightfromblock[from=b',to=s,chkp=C]{\allvals} 
%     -\attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\honatts}
%     }   
%     \\
%     &=
%     \frac
%     {\attsetweightfromblock[from=b',to=s,val=v,when=t,chkp=C]{\allatts}-\beta\commweightfromblock[from=b',to=s,chkp=C]{\allvals} }
%     {(1-\beta)\commweightfromblock[from=b',to=s,chkp=C]{\allvals}  
%     -\attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\honatts}
%     }  
%     \\   
%     &>
%     \frac
%     {
%         \indicatorfromblock[from=b,to=s',val=v,when=t,chkp=\calB]{\indQ}
%         \commweightfromblock[from=b',to=s,chkp=C]{\allvals}
%         -\beta\commweightfromblock[from=b',to=s,chkp=C]{\allvals} }
%     {(1-\beta)\commweightfromblock[from=b',to=s,chkp=C]{\allvals}  
%     -\attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\honatts}
%     }
%     \\
%     &=
%     \frac
%     {
%         \frac
%                 {\commweightfromblock[from=b',to=s,chkp=C]{\allvals}-
%                 \max\left(
%                     \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\allatts}
%                     -\beta \commweightfromblock[from=b',to=\slot(b)-1,chkp=C]{\allvals}
%                     ,0
%                 \right)
%                 +\boostweight[chkp=C]
%                 }
%                 {2}
%         +
%         \beta\commweightfromblock[from=b',to=s,chkp=C]{\allvals}
%         -\beta\commweightfromblock[from=b',to=s,chkp=C]{\allvals} }
%     {(1-\beta)\commweightfromblock[from=b',to=s,chkp=C]{\allvals}  
%     -\attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\honatts}
%     }
%     \\   
%     &=
%     \frac
%     {
%         \commweightfromblock[from=b',to=s,chkp=C]{\allvals}-
%                 \max\left(
%                     \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\allatts}
%                     -\beta \commweightfromblock[from=b',to=\slot(b)-1,chkp=C]{\allvals}
%                     ,0
%                 \right)
%                 +\boostweight[chkp=C] 
%     }
%     {2((1-\beta)\commweightfromblock[from=b',to=s,chkp=C]{\allvals}  
%     -\attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\honatts})
%     }
%     % \\      
%     % &====================================    
%     % \\
%     % &\geq
%     % \frac
%     % {\attsetweightfromblock[from=b',to=s,val=v,when=t,chkp=C]{\allatts}-\beta\commweightfromblock[from=b',to=s,chkp=C]{\allvals} }
%     % {(1-\beta)\commweightfromblock[from=b',to=s,chkp=C]{\allvals}  
%     % -\max\left(
%     %     \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\allatts}
%     %     -\beta\commweightfromblock[from=b',to=\slot(b')-1,chkp=C]{\allvals}
%     % ,0
%     % \right)
%     % }   
%     % \\
%     % &=
%     % \frac
%     % {\attsetweightfromblock[from=b',to=s,val=v,when=t,chkp=C]{\allatts}-\beta\commweightfromblock[from=b',to=s,chkp=C]{\allvals} }
%     % {(1-\beta)
%     % \left(\commweightfromblock[from=b',to=s,chkp=C]{\allvals}  
%     %     -\frac{
%     %         \max(
%     %             \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\allatts}
%     %             -\beta\commweightfromblock[from=b',to=\slot(b')-1,chkp=C]{\allvals}
%     %         ,0
%     %         )
%     %     }
%     %     {1-\beta}
%     % \right)
%     % } 
%     % \\
%     % &=        
%     % \left(\indicatordiscfromblock[from=b',to=s,val=v,when=t,chkp=C]{\indQ}  -\beta\right)\left(\frac{1}{1-\beta}\right)  
%     % \\
%     % &>
%     % \frac{1}{2(1-\beta)}
%     %     \left( 1+
%     %         \frac
%     %         {\boostweight[chkp=C]}
%     %         {\commweightfromblock[from=b',to=s,chkp=C]{\allvals}}
%     %     \right)       
% \end{align*}    
% \end{proof}

% \begin{proof}
% \def\alignexplwidth{7cm}
% \allowdisplaybreaks
% \begin{align*}
%     &\indicatordiscfromblock[from=b',to=s,val=v,when=t,chkp=C]{\indP}
%     \\
%     &=\frac
%     {\attsetweightfromblock[from=b',to=s,val=v,when=t,chkp=C]{\honatts}}
%     {\commweightfromblock[from=b',to=s,chkp=C]{\honvals}-\attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\honatts}}
%     \\
%     &\geq
%     \frac
%     {\attsetweightfromblock[from=b',to=s,val=v,when=t,chkp=C]{\allatts}-
%     \commweightfromblock[from=b',to=s,chkp=C]{\advvals}}
%     {
%         \commweightfromblock[from=b',to=s,chkp=C]{\honvals}
%         -\attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\honatts}
%     }
%     \\
%     &=
%     \frac
%     {\attsetweightfromblock[from=b',to=s,val=v,when=t,chkp=C]{\allatts}-
%     \commweightfromblock[from=b',to=s,chkp=C]{\advvals}}
%     {\commweightfromblock[from=b',to=s,chkp=C]{\allvals} - \commweightfromblock[from=b',to=s,chkp=C]{\advvals}-\attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\honatts}}
%     \\
%     &\geq
%     \frac
%     {\attsetweightfromblock[from=b',to=s,val=v,when=t,chkp=C]{\allatts}-
%     \commweightfromblock[from=b',to=s,chkp=C]{\advvals}}
%     {\commweightfromblock[from=b',to=s,chkp=C]{\allvals} 
%     -\commweightfromblock[from=b',to=s,chkp=C]{\advvals}
%     -\max\left(
%         \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\allatts}
%         -\commweightfromblock[from=b',to=\slot(b')-1,chkp=C]{\advvals}
%     ,0\right)}
%     \\
%     &\geq
%     \frac
%     {\attsetweightfromblock[from=b',to=s,val=v,when=t,chkp=C]{\allatts}-\beta\commweightfromblock[from=b',to=s,chkp=C]{\allvals} }
%     {\commweightfromblock[from=b',to=s,chkp=C]{\allvals} 
%     -\beta\commweightfromblock[from=b',to=s,chkp=C]{\allvals} 
%     -\left(
%         \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\allatts}
%         -\commweightfromblock[from=b',to=\slot(b')-1,chkp=C]{\advvals}
%     \right)
%     }   
%     \\
%     &=
%     \frac
%     {\attsetweightfromblock[from=b',to=s,val=v,when=t,chkp=C]{\allatts}-\beta\commweightfromblock[from=b',to=s,chkp=C]{\allvals} }
%     {(1-\beta)\commweightfromblock[from=b',to=s,chkp=C]{\allvals}  
%     -\max\left(
%         \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\allatts}
%         -\commweightfromblock[from=b',to=\slot(b')-1,chkp=C]{\advvals}
%     ,0
%     \right)
%     }       
%     \\
%     &\geq
%     \frac
%     {\attsetweightfromblock[from=b',to=s,val=v,when=t,chkp=C]{\allatts}-\beta\commweightfromblock[from=b',to=s,chkp=C]{\allvals} }
%     {(1-\beta)\commweightfromblock[from=b',to=s,chkp=C]{\allvals}  
%     -\max\left(
%         \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\allatts}
%         -\beta\commweightfromblock[from=b',to=\slot(b')-1,chkp=C]{\allvals}
%     ,0
%     \right)
%     }   
%     \\
%     &=
%     \frac
%     {\attsetweightfromblock[from=b',to=s,val=v,when=t,chkp=C]{\allatts}-\beta\commweightfromblock[from=b',to=s,chkp=C]{\allvals} }
%     {(1-\beta)
%     \left(\commweightfromblock[from=b',to=s,chkp=C]{\allvals}  
%         -\frac{
%             \max(
%                 \attsetweighttobediscfromblock[from=b',to=\slot(b')-1,val=v,when=t,chkp=C]{\allatts}
%                 -\beta\commweightfromblock[from=b',to=\slot(b')-1,chkp=C]{\allvals}
%             ,0
%             )
%         }
%         {1-\beta}
%     \right)
%     } 
%     \\
%     &=        
%     \left(\indicatordiscfromblock[from=b',to=s,val=v,when=t,chkp=C]{\indQ}  -\beta\right)\left(\frac{1}{1-\beta}\right)  
%     \\
%     &>
%     \frac{1}{2(1-\beta)}
%         \left( 1+
%             \frac
%             {\boostweight[chkp=C]}
%             {\commweightfromblock[from=b',to=s,chkp=C]{\allvals}}
%         \right)       
% \end{align*}    
% \end{proof}

% \begin{proof}
% We proceed as follows.\\
% \begin{tabular}{@{}p{0.1\linewidth}p{0.43\linewidth}@{}p{\dimexpr0.45\linewidth-2\tabcolsep\relax}@{}}
%     ~$\indicatordiscfromblock[from=b',to=s,val=v,when=t,chkp=C]{\indP}$
%     &=$\frac
%     {\attsetweightfromblock[from=b',to=s,val=v,when=t,chkp=C]{\honatts}}
%     {\commweightfromblock[from=b',to=s,chkp=C]{\honvals}}$
%     &--- By definition.
%     \\
%     & $\geq
%     \frac
%     {\attsetweightfromblock[from=b',to=s,val=v,when=t,chkp=C]{\allatts}-
%     \commweightfromblock[from=b',to=s,chkp=C]{\advvals}}
%     {\commweightfromblock[from=b',to=s,chkp=C]{\honvals}}$
%     & \begin{minipage}[t]{\linewidth}
%         \begin{itemize}[nosep, left= 0pt,label=---]
%                 \item By definition, $\commweightfromblock[from=b',to=s,chkp=C]{\advvals}= \valsetfromblock[from=b',to=s,chkp=C]{\allvals}  \setminus \honvals$.
%             \end{itemize}
%     \end{minipage}
%     \\
%     & $=
%     \frac
%     {\attsetweightfromblock[from=b',to=s,val=v,when=t,chkp=C]{\allatts}-
%     \commweightfromblock[from=b',to=s,chkp=C]{\advvals}}
%     {\commweightfromblock[from=b',to=s,chkp=C]{\allvals} - \commweightfromblock[from=b',to=s,chkp=C]{\advvals}}$
%     & --- By definition, $\commweightfromblock[from=b',to=s,chkp=C]{\allvals} = \commweightfromblock[from=b',to=s,chkp=C]{\honvals} + \commweightfromblock[from=b',to=s,chkp=C]{\advvals}$.\\
%     & $\geq
%     \frac
%     {\attsetweightfromblock[from=b',to=s,val=v,when=t,chkp=C]{\allatts}-
%     \beta \commweightfromblock[from=b',to=s,chkp=C]{\allvals}}
%     {\commweightfromblock[from=b',to=s,chkp=C]{\allvals} - \beta \commweightfromblock[from=b',to=s,chkp=C]{\allvals}}$
%     & \begin{minipage}[t]{\linewidth}
%         \begin{itemize}[nosep, left= 0pt,label=---]
%                 \item By Assumption~\ref{assum:beta}, $\commweightfromblock[from=b',to=s,chkp=C]{\advvals}\leq \beta \commweightfromblock[from=b',to=s,chkp=C]{\allvals}$, and, given that $\attsetweightfromblock[from=b',to=s,val=v,when=t,chkp=C]{\allatts} \leq \commweightfromblock[from=b',to=s,chkp=C]{\allvals}$, the function $g(x)=\frac{\attsetweightfromblock[from=b',to=s,val=v,when=t,chkp=C]{\allatts}-x}{\commweightfromblock[from=b',to=s,chkp=C]{\allvals}-x}$ is monotone decreasing in $[0,\commweightfromblock[from=b',to=s,chkp=C]{\allvals}]$.
%             \end{itemize}
%     \end{minipage}\\
%     &=
%     $\frac
%     {\attsetweightfromblock[from=b',to=s,val=v,when=t,chkp=C]{\allatts}-
%     \beta \commweightfromblock[from=b',to=s,chkp=C]{\allvals}}
%     {\commweightfromblock[from=b',to=s,chkp=C]{\allvals}}
%     \left( \frac{1}{1-\beta} \right)$
%     & --- Simplification. \\

%     & $=\left(\indicatorfromblock[from=b',to=s,val=v,when=t,chkp=C]{\indQ}  -\beta\right)\left(\frac{1}{1-\beta}\right)$ & --- Simplification. \\

%     & $>
%         \frac{1}{2(1-\beta)}
%             \left( 1+
%                 \frac
%                 {\boostweight[chkp=C]}
%                 {\commweightfromblock[from=b',to=s,chkp=C]{\allvals}}
%             \right)
%     $& --- By applying the condition on $\indicatorfromblock[from=b',to=s,val=v,when=t,chkp=C]{\indQ}.$
% \end{tabular}
% \par
% \end{proof}

\include{old_proofs}

\end{document}